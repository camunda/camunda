

# Default values for Camunda Helm chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# The values file follows helm best practices https://helm.sh/docs/chart_best_practices/values/
#
# This means:
#   * Variable names should begin with a lowercase letter, and words should be separated with camelcase.
#   * Every defined property in values.yaml should be documented. The documentation string should begin with the name of the property that it describes, and then give at least a one-sentence description
#
# Furthermore, we try to apply the following pattern: # [VarName] [conjunction] [definition]
#
# VarName:
#
#  * In the documentation the variable name is started with a big letter, similar to kubernetes resource documentation.
#  * If the variable is part of a subsection/object we use a json path expression (to make it more clear where the variable belongs to).
#    The root (chart name) is omitted (e.g. zeebe). This is useful for using --set in helm.
#
# Conjunction:
#   * [defines] for mandatory configuration
#   * [can be used] for optional configuration
#   * [if true] for toggles
#   * [configuration] for section/group of variables

#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#
##########################################
 #####
#     # #       ####  #####    ##   #
#       #      #    # #    #  #  #  #
#  #### #      #    # #####  #    # #
#     # #      #    # #    # ###### #
#     # #      #    # #    # #    # #
 #####  ######  ####  #####  #    # ######
##########################################
#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#

# Global configuration for variables which can be accessed by all sub charts
## @section Global parameters
## @extra global
global:
  ## Secrets configuration.
  ## @extra global.secrets configuration for auto-generated secrets which is only used during the installation.
  secrets:
    ## @param global.secrets.autoGenerated if true, a secret object will be generated with auto-generated passwords. This secret object is NOT managed with corresponding releases and NOR part of Helm deployment/upgrade! It's generated once, and if it's deleted, you will lose the secrets.
    autoGenerated: false
    ## @param global.secrets.name defines the name of the secret object that has the auto-generated passwords.
    name: "camunda-credentials"
    ## @param global.secrets.annotations [object] defines the secret object annotations that utilize Helm hooks to keep that object out of the Helm deployment.
    annotations:
      helm.sh/hook: "pre-install"
      helm.sh/resource-policy: "keep"

  ## License configuration.
  ## @extra global.license
  license:
    ## @param global.license.key (DEPRECATED - use global.license.secret instead) if set, it will be exposed as "CAMUNDA_LICENSE_KEY" in the apps.
    key: ""
    ## @param global.license.existingSecret (DEPRECATED - use global.license.secret instead) you can provide an existing secret name for Camunda license secret.
    existingSecret: ""
    ## @param global.license.existingSecretKey (DEPRECATED - use global.license.secret instead) you can provide the key within the existing secret object for Camunda license key.
    existingSecretKey: ""
    ## @extra global.license.secret configuration to provide the license secret.
    secret:
      ## @param global.license.secret.inlineSecret can be used to provide the license as a plain-text value for non-production usage.
      inlineSecret: ""
      ## @param global.license.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the license.
      existingSecret: ""
      ## @param global.license.secret.existingSecretKey defines the key within the existing secret object.
      existingSecretKey: ""

  ## @extra global.compatibility Compatibility adaptations in the chart.
  compatibility:
    ## Compatibility adaptations for Openshift
    ##
    openshift:
      ## @param global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
      ##
      adaptSecurityContext: disabled
    ## Compatibility adaptations for Camunda Orchestration Cluster.
    ##
    orchestration:
      ## @param global.compatibility.orchestration.enabled if true, enables compatibility layer for Camunda Orchestration Cluster between Camunda 8.7 chart (12.x.x) and Camunda 8.8 chart (13.x.x).
      ##
      enabled: true

  ## @extra global.config Config used in various places.
  config:
    ## @param global.config.requestBodySize defines applications request body size which used for upload files.
    requestBodySize: 10MB

  ## Multitenancy configuration.
  ## @extra global.multitenancy
  multitenancy:
    ## @param global.multitenancy.enabled if true, then enable multitenancy in all applicable components.
    enabled: false

  ## Security configuration
  ## @extra global.security
  security:
    ## @skip global.security.allowInsecureImages
    allowInsecureImages: true

    ## @extra global.security.authentication
    authentication:
      ## @param global.security.authentication.method defines the authentication method which should be used. Possible values: basic, oidc. Could be overridden in each component.
      method: "basic"

  ## @param global.createReleaseInfo Create config that will be used in Camunda Console.
  createReleaseInfo: true

  ## @skip global.testDeprecationFlags
  testDeprecationFlags:
    ## @skip global.testDeprecationFlags.existingSecretsMustBeSet give error or warning when existingSecret is not set
    existingSecretsMustBeSet: "warning"

  ## @param global.annotations Annotations can be used to define common annotations, which should be applied to all deployments
  annotations: {}
  ## @extra global.labels can be used to apply immutable labels applied to all Camunda resources. These are also used in matchLabels fields in selectors.
  labels:
    ## @param global.labels.app Name of the application
    app: camunda-platform
  ## @param global.commonLabels can be used to apply mutable labels to all Camunda resources.
  commonLabels: {}
  ## @param global.nodeSelector can be used to define Kubernetes node selectors to run Camunda components, unless overridden by component-specific nodeSelector.
  nodeSelector: {}
  # Image configuration to be used in each sub chart
  # https://hub.docker.com/u/camunda
  image:
    ## @param global.image.registry Can be used to set container image registry.
    registry: ""
    ## @param global.image.tag defines the tag / version which should be used in the most of the apps.
    tag: ""
    ## @param global.image.pullPolicy defines the image pull policy which should be used https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy
    pullPolicy: Always
    ## @param global.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []
  ## Ingress configuration to configure the ingress resource
  ## @extra global.ingress
  ingress:
    ## @param global.ingress.enabled if true, an ingress resource is deployed. Only useful if an ingress controller is available, like Ingress-NGINX.
    enabled: false
    ## @param global.ingress.external if true, the Ingress object will not be rendered. This setting is used when a non-Ingress resource, like a service mesh, is used to access the cluster.
    external: false
    ## @param global.ingress.className Ingress.className defines the class or configuration of ingress which should be used by the controller
    className: nginx
    ## @param global.ingress.labels [object] can be used to define labels which will be applied to the global HTTP ingress resource
    labels: {}
    ## @param global.ingress.annotations [object] defines the ingress related annotations, consumed mostly by the ingress controller
    annotations:
      ingress.kubernetes.io/rewrite-target: "/"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      nginx.ingress.kubernetes.io/proxy-buffering: "on"
      # The proxy-body-size should be the same size as global.config.requestBodySize.
      nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    # Ingress.host can be used to define the host of the ingress rule. https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    ## @param global.ingress.host If not specified the rules applies to all inbound http traffic, if specified the rule applies to that host.
    host: ""
    ## @param global.ingress.pathType can be used to define the Ingress path type. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
    pathType: Prefix
    ## @extra global.ingress.tls configuration for tls on the ingress resource https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    tls:
      ## @param global.ingress.tls.enabled if true, then tls is configured on the ingress resource. If enabled the Ingress.host need to be defined.
      enabled: false
      ## @param global.ingress.tls.secretName defines the secret name which contains the TLS private key and certificate
      secretName: camunda-platform

  # Elasticsearch configuration which is shared between the sub charts
  ## @extra global.elasticsearch
  ## @param global.elasticsearch.enabled if true, enables elasticsearch for all components
  ## @param global.elasticsearch.external if true, tries to connect to an external elasticsearch
  ## @extra global.elasticsearch.tls
  ## @param global.elasticsearch.tls.enabled enable tls for external elasticsearch
  ## @param global.elasticsearch.tls.existingSecret provide an already existing tls secret for connecting to external elasticsearch
  ## @extra global.elasticsearch.auth
  ## @param global.elasticsearch.auth.username the username for external elasticsearch
  ## @param global.elasticsearch.auth.password (DEPRECATED - use global.elasticsearch.auth.secret instead) the password for external elasticsearch
  ## @param global.elasticsearch.auth.existingSecret (DEPRECATED - use global.elasticsearch.auth.secret instead) you can provide an existing secret for the external elasticsearch password
  ## @param global.elasticsearch.auth.existingSecretKey (DEPRECATED - use global.elasticsearch.auth.secret instead) you can provide an existing secret key for the external elasticsearch password
  ## @extra global.elasticsearch.tls.jks configuration to provide the jks secret.
  ## @param global.elasticsearch.tls.jks.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the jks password.
  ## @param global.elasticsearch.tls.jks.secret.existingSecretKey can be used to provide the key within the existing secret object.
  ## @param global.elasticsearch.tls.jks.secret.inlineSecret can be used to provide the jks password as a plain-text value for non-production usage.
  elasticsearch:
    enabled: true
    external: false
    tls:
      enabled: false
      existingSecret: ""
      jks:
        secret:
          existingSecret: ""
          existingSecretKey: ""
          inlineSecret: ""
    auth:
      username: ""
      password: ""
      existingSecret: ""
      existingSecretKey: "password"
      ## @extra global.elasticsearch.auth.secret configuration to provide the authentication secret.
      secret:
        ## @param global.elasticsearch.auth.secret.inlineSecret can be used to provide the password as a plain-text value for non-production usage.
        inlineSecret: ""
        ## @param global.elasticsearch.auth.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the password.
        existingSecret: ""
        ## @param global.elasticsearch.auth.secret.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: ""
    ## @param  global.elasticsearch.disableExporter (DEPRECATED - use global.elasticsearch.enabled instead) this value is not needed anymore.
    disableExporter: false
    ## @extra global.elasticsearch.url Configuration to configure elasticsearch url
    ## @param global.elasticsearch.url.protocol defines the elasticsearch access protocol.
    ## @param global.elasticsearch.url.host Elasticsearch.host defines the elasticsearch host, ideally the service name inside the namespace
    ## @param global.elasticsearch.url.port Elasticsearch.port defines the elasticsearch port, under which elasticsearch can be accessed
    url:
      protocol: http
      host: "{{ .Release.Name }}-elasticsearch"
      port: 9200
    ## @param global.elasticsearch.clusterName defines the name of the Elasticsearch cluster.
    clusterName: "elasticsearch"
    ## @param global.elasticsearch.prefix defines the prefix which is used by the old Zeebe Elasticsearch Exporter to create Elasticsearch indexes and consumed by Optimize.
    prefix: zeebe-record
  # Opensearch configuration which is shared between the sub charts
  ## @extra global.opensearch
  ## @param global.opensearch.enabled enabled external opensearch
  ## @param global.opensearch.aws.enabled Enabling AWS IRSA
  ## @extra global.opensearch.tls
  ## @param global.opensearch.tls.enabled enable tls for external opensearch
  ## @param global.opensearch.tls.existingSecret provide an already existing tls secret for connecting to external opensearch
  ## @extra global.opensearch.auth
  ## @param global.opensearch.auth.username the username for external opensearch
  ## @param global.opensearch.auth.password (DEPRECATED - use global.opensearch.auth.secret instead) the password for external opensearch
  ## @param global.opensearch.auth.existingSecret (DEPRECATED - use global.opensearch.auth.secret instead) you can provide an existing secret for the external opensearch password
  ## @param global.opensearch.auth.existingSecretKey (DEPRECATED - use global.opensearch.auth.secret instead) you can provide an existing secret key for the external opensearch password
  ## @extra global.opensearch.tls.jks configuration to provide the jks secret.
  ## @param global.opensearch.tls.jks.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the jks password.
  ## @param global.opensearch.tls.jks.secret.existingSecretKey can be used to provide the key within the existing secret object.
  ## @param global.opensearch.tls.jks.secret.inlineSecret can be used to provide the jks password as a plain-text value for non-production usage.
  opensearch:
    enabled: false
    aws:
      enabled: false
    tls:
      enabled: false
      existingSecret: ""
      jks:
        secret:
          existingSecret: ""
          existingSecretKey: ""
          inlineSecret: ""
    auth:
      username: ""
      password: ""
      existingSecret: ""
      existingSecretKey: "password"
      ## @extra global.opensearch.auth.secret configuration to provide the authentication secret.
      secret:
        ## @param global.opensearch.auth.secret.inlineSecret can be used to provide the password as a plain-text value for non-production usage.
        inlineSecret: ""
        ## @param global.opensearch.auth.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the password.
        existingSecret: ""
        ## @param global.opensearch.auth.secret.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: ""
    ## @extra global.opensearch.url Configuration to configure opensearch url
    ## @param global.opensearch.url.protocol defines the external opensearch access protocol
    ## @param global.opensearch.url.host defines the external opensearch host, ideally the service name inside the namespace
    ## @param global.opensearch.url.port defines the external opensearch port, under which opensearch can be accessed
    url:
      protocol: https
      host: ""
      port: 443
    ## @param global.opensearch.clusterName defines the name of the OpenSearch cluster.
    clusterName: "opensearch"
    ## @param global.opensearch.prefix defines the prefix which is used by the old Zeebe OpenSearch Exporter to create OpenSearch indexes and consumed by Optimize.
    prefix: zeebe-record
  ## @param global.zeebeClusterName ZeebeClusterName defines the cluster name for the Zeebe cluster. All Zeebe pods get this prefix in their name and the brokers uses that as cluster name.
  zeebeClusterName: "{{ .Release.Name }}-zeebe"

  # Identity configuration to configure identity specifics on global level, which can be accessed by other components
  identity:
    service:
      ## @param global.identity.service.url
      url: ""
    keycloak:
      # global.identity.keycloak.internal if true, it will configure an extra service with type "ExternalName".
      ## @param global.identity.keycloak.internal It's useful for using existing Keycloak in another namespace with and access it with the combined Ingress.
      internal: false
      ## @param global.identity.keycloak.url can be used incorporate with "identityKeycloak.enabled: false" to use your own Keycloak instead of the one comes with Camunda Helm chart.
      url:
        {}
        # Example to produce the following URL "https://keycloak.prod.svc.cluster.local:8443":
        # url:
        #   protocol: "https"
        #   host: "keycloak.prod.svc.cluster.local"
        #   port: "8443"
      #  defines the endpoint of Keycloak which varies between Keycloak versions.
      ## @param global.identity.keycloak.contextPath In Keycloak v16.x.x it's hard-coded as '/auth', but in v19.x.x it's '/'.
      contextPath: "/auth"
      ## @param global.identity.keycloak.realm defines Keycloak realm path used for Camunda.
      realm: "/realms/camunda-platform"
      ## @param global.identity.keycloak.auth same as "identityKeycloak.auth" but it's used for existing Keycloak.
      auth:
        {}
        # identity.keycloak.auth.adminUser can be used to configure admin user to access existing Keycloak.
        # adminUser: ""
        # identity.keycloak.auth.existingSecret can be used to configure existing Secret object which has admin password
        # to access existing Keycloak.
        # existingSecret: ""
        # identity.keycloak.auth.existingSecretKey can be used to configure the key inside existing Secret object
        # which has admin password to access existing Keycloak.
        # existingSecretKey: "admin-password"

    ## @extra global.identity.auth configuration, to configure identity authentication setup
    auth:
      ## @param global.identity.auth.enabled if true, enables authentication on Management Identity .
      enabled: false
      ## @param global.identity.auth.issuer defines the issuer name, which is used by the services to validate the JWT tokens.
      issuer: ""
      ## @param global.identity.auth.issuerBackendUrl defines the issuer backend URL, which is used by the services to validate the JWT tokens in a container to container context.
      issuerBackendUrl: ""
      ## @param global.identity.auth.authUrl defines the authentication URL, which is used by the services to to obtain authorized access.
      authUrl: ""
      ## @param global.identity.auth.tokenUrl defines the token URL, which is used by the services to request JWT tokens.
      tokenUrl: ""
      ## @param global.identity.auth.jwksUrl defines the JWKS URL, which is used by the services to validate the JWT tokens.
      jwksUrl: ""
      ## @param global.identity.auth.type defines the type of authentication which should be used. Possible values: `KEYCLOAK`, `MICROSOFT`, or `GENERIC`.
      type: "KEYCLOAK"

      #  defines the token issuer (Keycloak) URL, where the services can request JWT tokens.
      # Should be publicly accessible, per default we assume a port-forward to Keycloak (18080) is created before login.
      ## @param global.identity.auth.publicIssuerUrl Can be overwritten if ingress is in use and an external IP is available.
      publicIssuerUrl: "http://localhost:18080/auth/realms/camunda-platform"

      ## @extra global.identity.auth.admin configuration to configure Connectors authentication specifics on global level, which can be accessed by other components
      admin:
        ## @param global.identity.auth.admin.enabled if true, creates the admin client which is used in administration operations if needed.
        enabled: false
        ## @param global.identity.auth.admin.clientId defines the client id.
        clientId: admin
        ## @param global.identity.auth.admin.existingSecret [string,object] (DEPRECATED - use global.identity.auth.admin.secret instead) A string literal password can be provided. If not set, a random secret is generated. Recommended: reference an existing Kubernetes Secret using global.identity.auth.admin.existingSecret.name.
        existingSecret: ""
        ## @param global.identity.auth.admin.existingSecretKey (DEPRECATED - use global.identity.auth.admin.secret instead) defines the key within the existing secret object.
        existingSecretKey: identity-admin-client-token
        ## @extra global.identity.auth.admin.secret configuration to provide the admin client secret.
        secret:
          ## @param global.identity.auth.admin.secret.inlineSecret can be used to provide the client secret as a plain-text value for non-production usage.
          inlineSecret: ""
          ## @param global.identity.auth.admin.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the client secret.
          existingSecret: ""
          ## @param global.identity.auth.admin.secret.existingSecretKey defines the key within the existing secret object.
          existingSecretKey: ""

      #####################
      # Management Identity
      #####################

      ## @extra global.identity.auth.identity configuration to configure Management Identity authentication specifics on global level, which can be accessed by other components
      identity:
        ## @param global.identity.auth.identity.clientId defines the client id, which is used by Management Identity in authentication flows.
        clientId: camunda-identity
        ## @param global.identity.auth.identity.audience defines the audience, which is used by Management Identity.
        audience: camunda-identity-resource-server
        ## @param global.identity.auth.identity.existingSecret [string,object] (DEPRECATED - use global.identity.auth.identity.secret instead) can be used to reference an existing secret. This should ONLY be used for an external OIDC provider. If not set, a random secret is generated.
        existingSecret: ""
        ## @param global.identity.auth.identity.existingSecretKey (DEPRECATED - use global.identity.auth.identity.secret instead) defines the key within the existing secret object.
        existingSecretKey: identity-oidc-client-token
        ## @extra global.identity.auth.identity.secret configuration to provide the identity client secret.
        secret:
          ## @param global.identity.auth.identity.secret.inlineSecret can be used to provide the client secret as a plain-text value for non-production usage.
          inlineSecret: ""
          ## @param global.identity.auth.identity.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the client secret. This should ONLY be used for an external OIDC provider. If not set, a random secret is generated.
          existingSecret: ""
          ## @param global.identity.auth.identity.secret.existingSecretKey defines the key within the existing secret object.
          existingSecretKey: ""
        ## @param global.identity.auth.identity.initialClaimName defines the initial claim name, which is used by Management Identity to configure initial mapping rules,
        # defaults to "oid".
        initialClaimName: "oid"
        ## @param global.identity.auth.identity.initialClaimValue defines the initial claim value, which is used by Management  Identity to configure initial mapping rules.
        initialClaimValue: ""

      #####################
      # Console
      #####################

      ## @extra global.identity.auth.console configuration to configure Console authentication specifics on global level, which can be accessed by other components
      console:
        ## @param global.identity.auth.console.clientId defines the client id, which is used by Console in authentication flows.
        clientId: console
        ## @param global.identity.auth.console.audience defines the audience which is used by Console's client API.
        audience: console-api
        ## @param global.identity.auth.console.wellKnown defines the uri for the well known config which is used by Console (optional).
        wellKnown: https://well-known-uri
        ## @param global.identity.auth.console.redirectUrl defines the root URL which is used by Keycloak to access WebModeler.
        # Should be publicly accessible, the default value works if a port-forward to WebModeler is created to 8080.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8087"

      #####################
      # Webmodeler
      #####################

      ## @extra global.identity.auth.webModeler configuration to configure WebModeler authentication specifics on global level, which can be accessed by other components
      webModeler:
        ## @param global.identity.auth.webModeler.clientId defines the client id, which is used by WebModeler in authentication flows.
        clientId: web-modeler
        ## @param global.identity.auth.webModeler.clientApiAudience defines the audience which is used by WebModeler's client API.
        clientApiAudience: web-modeler-api
        ## @param global.identity.auth.webModeler.publicApiAudience defines the audience which is used by WebModeler's public API.
        publicApiAudience: web-modeler-public-api
        ## @param global.identity.auth.webModeler.redirectUrl defines the root URL which is used by Keycloak to access WebModeler.
        # Should be publicly accessible, the default value works if a port-forward to WebModeler is created to 8084.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8070"

      #####################
      # Optimize
      #####################
      ## @extra global.identity.auth.optimize configuration to configure Optimize authentication specifics on global level, which can be accessed by other components
      optimize:
        ## @param global.identity.auth.optimize.audience defines the audience, which is used by Optimize.
        audience: optimize-api
        ## @param global.identity.auth.optimize.clientId defines the client id, which is used by Optimize in authentication flows.
        clientId: optimize
        ## @param global.identity.auth.optimize.existingSecret [string,object] (DEPRECATED - use global.identity.auth.optimize.secret instead) A string literal secret can be provided. If not set, a random secret is generated. Recommended: reference an existing Kubernetes Secret using global.identity.auth.optimize.existingSecret.name.
        existingSecret: ""
        ## @param global.identity.auth.optimize.existingSecretKey (DEPRECATED - use global.identity.auth.optimize.secret instead) defines the key within the existing secret object.
        existingSecretKey: identity-optimize-client-token
        ## @extra global.identity.auth.optimize.secret configuration to provide the optimize client secret.
        secret:
          ## @param global.identity.auth.optimize.secret.inlineSecret can be used to provide the client secret as a plain-text value for non-production usage.
          inlineSecret: ""
          ## @param global.identity.auth.optimize.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the client secret.
          existingSecret: ""
          ## @param global.identity.auth.optimize.secret.existingSecretKey defines the key within the existing secret object.
          existingSecretKey: ""
        ## @param global.identity.auth.optimize.redirectUrl defines the root (or redirect) URL, which is used by Keycloak to access Optimize.
        # Should be publicly accessible, the default value works if a port-forward to Optimize is created to 8083.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8083"

  # Multiregion options for Zeebe
  #
  ## WARNING: Customers must develop and test the operational procedure described below in non-production environments based on the framework steps
  # outlined by Camunda before applying them in production setups.
  # Before advancing to production go-live, validating these procedures with Camunda is strongly recommended.
  # Customers are solely responsible for detecting any regional failures and implementing the necessary operational procedure described.
  multiregion:
    ## @skip global.multiregion.regions number of regions that this Camunda Platform instance is stretched across
    regions: 1
    ## @skip global.multiregion.regionId unique id of the region. MUST start at 0 for the computation to work correctly. With 2 regions, you would have region 0 and 1.
    regionId: 0

  ## Document Store Configuration
  ## @extra global.documentStore These parameters are used to configure the document storage backend across all Camunda components.
  documentStore:
    ## @param global.documentStore.activeStoreId The default document store to use. Valid values: inmemory, aws, and gcp.
    activeStoreId: "inmemory"
    type:
      aws:
        ## @param global.documentStore.type.aws.enabled Enable AWS document store configuration.
        enabled: false
        ## @param global.documentStore.type.aws.storeId Custom prefix for AWS. Default will generate env vars containing 'storeId' such as DOCUMENT_STORE_AWS_CLASS.
        storeId: "AWS"
        ## @param global.documentStore.type.aws.region AWS region for the S3 bucket. (example: us-east-1)
        region: ""
        ## @param global.documentStore.type.aws.bucket Name of the AWS S3 bucket.
        bucket: "your-aws-bucket"
        ## @param global.documentStore.type.aws.bucketPath (Optional) Path/prefix within the S3 bucket.
        bucketPath: ""
        ## @param global.documentStore.type.aws.bucketTtl (Optional) Time-to-live for documents in the S3 bucket (number in days).
        bucketTtl: 0
        ## @param global.documentStore.type.aws.class Fully qualified class name for the AWS document store provider.
        class: "io.camunda.document.store.aws.AwsDocumentStoreProvider"
        ## @param global.documentStore.type.aws.existingSecret (DEPRECATED - use global.documentStore.type.aws.accessKeyId.secret and global.documentStore.type.aws.secretAccessKey.secret instead) Reference to an existing Kubernetes secret containing AWS credentials.
        existingSecret: "aws-credentials"
        ## @param global.documentStore.type.aws.accessKeyIdKey (DEPRECATED - use global.documentStore.type.aws.accessKeyId.secret instead) Key within the AWS credentials secret for AWS_ACCESS_KEY_ID.
        accessKeyIdKey: "awsAccessKeyId"
        ## @param global.documentStore.type.aws.secretAccessKeyKey (DEPRECATED - use global.documentStore.type.aws.secretAccessKey.secret instead) Key within the AWS credentials secret for AWS_SECRET_ACCESS_KEY.
        secretAccessKeyKey: "awsSecretAccessKey"
        ## @extra global.documentStore.type.aws.accessKeyId configuration to provide the AWS access key ID.
        accessKeyId:
          ## @extra global.documentStore.type.aws.accessKeyId.secret configuration to provide the AWS access key ID secret.
          secret:
            ## @param global.documentStore.type.aws.accessKeyId.secret.inlineSecret can be used to provide the access key ID as a plain-text value for non-production usage.
            inlineSecret: ""
            ## @param global.documentStore.type.aws.accessKeyId.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the access key ID.
            existingSecret: ""
            ## @param global.documentStore.type.aws.accessKeyId.secret.existingSecretKey defines the key within the existing secret object.
            existingSecretKey: "access-key-id"
        ## @extra global.documentStore.type.aws.secretAccessKey configuration to provide the AWS secret access key.
        secretAccessKey:
          ## @extra global.documentStore.type.aws.secretAccessKey.secret configuration to provide the AWS secret access key secret.
          secret:
            ## @param global.documentStore.type.aws.secretAccessKey.secret.inlineSecret can be used to provide the secret access key as a plain-text value for non-production usage.
            inlineSecret: ""
            ## @param global.documentStore.type.aws.secretAccessKey.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the secret access key.
            existingSecret: ""
            ## @param global.documentStore.type.aws.secretAccessKey.secret.existingSecretKey defines the key within the existing secret object.
            existingSecretKey: "secret-access-key"
      gcp:
        ## @param global.documentStore.type.gcp.enabled Enable GCP document store configuration.
        enabled: false
        ## @param global.documentStore.type.gcp.storeId Custom prefix for GCP. Default will generate env vars containing 'storeId' such as DOCUMENT_STORE_GCP_CLASS.
        storeId: "GCP"
        ## @param global.documentStore.type.gcp.bucket Name of the GCP bucket.
        bucket: "your-gcp-bucket"
        ## @param global.documentStore.type.gcp.class Fully qualified class name for the GCP document store provider.
        class: "io.camunda.document.store.gcp.GcpDocumentStoreProvider"
        ## @param global.documentStore.type.gcp.existingSecret (DEPRECATED - use global.documentStore.type.gcp.serviceAccount.secret instead) Reference to an existing Kubernetes secret containing GCP credentials.
        existingSecret: "gcp-credentials"
        ## @param global.documentStore.type.gcp.credentialsKey (DEPRECATED - use global.documentStore.type.gcp.serviceAccount.secret instead) Key in the GCP credentials secret that contains the service-account JSON.
        credentialsKey: "service-account.json"
        ## @param global.documentStore.type.gcp.mountPath Mount path for the GCP credentials secret.
        mountPath: "/var/secrets/gcp"
        ## @param global.documentStore.type.gcp.fileName The file name for the GCP credentials JSON.
        fileName: "service-account.json"
        ## @extra global.documentStore.type.gcp.secret configuration to provide the GCP service account credentials secret.
        secret:
          ## @param global.documentStore.type.gcp.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the service account JSON.
          existingSecret: ""
          ## @param global.documentStore.type.gcp.secret.existingSecretKey defines the key within the existing secret object.
          existingSecretKey: "service-account.json"
      inmemory:
        ## @param global.documentStore.type.inmemory.enabled Enable in-memory document store configuration.
        enabled: true
        ## @param global.documentStore.type.inmemory.storeId Custom prefix for in-memory. Default will generate env vars containing 'storeId' such as DOCUMENT_STORE_INMEMORY_CLASS.
        storeId: "INMEMORY"
        ## @param global.documentStore.type.inmemory.class Fully qualified class name for the in-memory document store provider.
        class: "io.camunda.document.store.inmemory.InMemoryDocumentStoreProvider"

  ## @param global.extraManifests Array of extra objects to deploy with the release.
  #Example:
  # extraManifests:
  #   - |
  #     apiVersion: v1
  #     kind: ConfigMap
  #     metadata:
  #       name: example-cm
  #     data:
  #       test: test
  extraManifests: []

  ## @param global.noSecondaryStorage if true, enables engine-only/no-secondary-storage mode; this disables all secondary-storage-dependent features and components.
  noSecondaryStorage: false

############################################
###
 #  #####  ###### #    # ##### # ##### #   #
 #  #    # #      ##   #   #   #   #    # #
 #  #    # #####  # #  #   #   #   #     #
 #  #    # #      #  # #   #   #   #     #
 #  #    # #      #   ##   #   #   #     #
### #####  ###### #    #   #   #   #     #
############################################

## @section Management Identity Parameters
# Management Identity configuration for the identity sub chart.
identity:
  ## @param identity.enabled if true, the identity deployment and its related resources are deployed via a helm release
  #
  # Note: Management Identity is always required by WebModeler. By default, if no OIDC provider is specified, Keycloak is used by identity.
  #       If you don't need WebModeler, make sure to disable Management Identity authentication, keycloak, and the WebModeler application by setting:
  #         global.identity.auth.enabled=false
  #         webModeler.enabled=false
  #         identityKeycloak.enabled=false
  enabled: false

  ## @param identity.fullnameOverride can be used to override the full name of the Management Identity resources
  fullnameOverride: ""
  ## @param identity.nameOverride can be used to partly override the name of the Management Identity resources (names will still be prefixed with the release name)
  nameOverride: ""

  ## @extra identity.firstUser configuration to configure properties of the first Management Identity user, which can be used to access all
  # web applications
  firstUser:
    ## @param identity.firstUser.enabled if true, Management Identity will seed the first user in Keycloak.
    enabled: true
    ## @param identity.firstUser.username defines the username of the first user, needed to log in into the web applications
    username: demo
    ## @param identity.firstUser.password (DEPRECATED - use identity.firstUser.secret instead) defines the password of the first user, needed to log in into the web applications
    password: demo
    ## @param identity.firstUser.email defines the email address of the first user; a valid email address is required to use WebModeler
    email: demo@example.org
    ## @param identity.firstUser.firstName defines the first name of the first user; a name is required to use WebModeler
    firstName: Demo
    ## @param identity.firstUser.lastName defines the last name of the first user; a name is required to use WebModeler
    lastName: User
    ## @param identity.firstUser.existingSecret (DEPRECATED - use identity.firstUser.secret instead) can be used to use an own existing secret for Management Identity first user.
    existingSecret: camunda-credentials
    ## @param identity.firstUser.existingSecretKey (DEPRECATED - use identity.firstUser.secret instead) defines the key within the existing secret object.
    existingSecretKey: identity-firstuser-password
    ## @extra identity.firstUser.secret configuration to provide the first user password secret.
    secret:
      ## @param identity.firstUser.secret.inlineSecret can be used to provide the password as a plain-text value for non-production usage.
      inlineSecret: ""
      ## @param identity.firstUser.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the password.
      existingSecret: ""
      ## @param identity.firstUser.secret.existingSecretKey defines the key within the existing secret object.
      existingSecretKey: ""

  ## @param identity.users configuration to configure properties of the Management Identity users, which can be used to access web applications.
  # Example:
  # - username: foo
  #   secret:
  #     existingSecret: foo-secret
  #     existingSecretKey: foo-secret-key
  #   firstName: Foo
  #   lastName: Bar
  #   email: foo.bar@camunda.com
  #   roles:
  #     - ManagementIdentity
  #     - Optimize
  #     - Console
  users: []
  ## @param identity.clients configuration to configure properties of the Management Idnetity custom clients.
  # Example:
  # - id: test
  #   name: Test
  #   existingSecret: test-secret
  #   existingSecretKey: test-secret-key
  #   redirectUris: /dummy
  #   rootUrl: http://dummy
  #   type: confidential
  #   permissions:
  #     - resourceServerId: camunda-identity-resource-server
  #       definition: read
  clients: []
  ## @extra identity.image configuration to configure the identity image specifics
  image:
    ## @param identity.image.registry can be used to set container image registry.
    registry: ""
    ## @param identity.image.repository defines which image repository to use
    repository: camunda/identity
    ## @param identity.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.5
    ## @param identity.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""
    ## @param identity.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## Multitenancy configuration
  ## @extra identity.multitenancy
  multitenancy:
    ## @param identity.multitenancy.enabled can be used to enable multitenancy in management identity
    enabled: false

  ## @param identity.sidecars can be used to attach extra containers to the identity deployment
  sidecars: []
  ## @param identity.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []
  ## @param identity.fullURL can be used when Ingress is configured (for both multi and single domain setup).
  fullURL: ""

  # Note: Management Identity cannot be accessed over HTTP if a "contextPath" is configured.
  #       Which means that Management Identity cannot be configured in combined Ingress without HTTPS.
  #       To use Management Identity over HTTP, setup a separated Ingress using "identity.ingress" and don't set "contextPath".
  ## @param identity.contextPath can be used to make Management Identity web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  # contextPath: "/identity"
  contextPath: ""

  ## @param identity.podAnnotations can be used to define extra Management Identity pod annotations
  podAnnotations: {}
  ## @param identity.podLabels can be used to define extra Management Identity pod labels
  podLabels: {}

  ## @extra identity.logging configuration for the Management Identity logging. This template will be directly included in the Management Identity configuration YAML file
  ## @param identity.logging.level.ROOT
  ## @param identity.logging.level.io.camunda.identity https://docs.camunda.io/docs/next/self-managed/identity/user-guide/configuration/configure-logging/#general-configuration-options
  logging:
    level:
      ROOT: INFO
      io.camunda.identity: INFO

  ## @extra identity.service configuration to configure the identity service.
  service:
    ## @param identity.service.annotations can be used to define annotations, which will be applied to the identity service
    annotations: {}
    ## @param identity.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param identity.service.port defines the port of the service on which the identity application will be available
    port: 80
    ## @param identity.service.metricsPort defines the port of the service on which the identity metrics will be available
    metricsPort: 82
    ## @param identity.service.metricsName defines the name of the service on which the identity metrics will be available
    metricsName: metrics

  ## @extra identity.podSecurityContext defines the security options the Management Identity pod should be run with
  podSecurityContext:
    ## @param identity.podSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param identity.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra identity.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param identity.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra identity.containerSecurityContext defines the security options the Management Identity container should be run with
  containerSecurityContext:
    ## @param identity.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param identity.containerSecurityContext.privileged
    privileged: false
    ## @param identity.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param identity.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param identity.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra identity.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param identity.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra identity.startupProbe configuration
  startupProbe:
    ## @param identity.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param identity.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health
    ## @param identity.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param identity.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param identity.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra identity.readinessProbe configuration
  readinessProbe:
    ## @param identity.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param identity.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health
    ## @param identity.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param identity.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param identity.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra identity.livenessProbe configuration
  livenessProbe:
    ## @param identity.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param identity.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /actuator/health
    ## @param identity.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param identity.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param identity.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param identity.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @param identity.nodeSelector can be used to define on which nodes the Management Identity pods should run
  nodeSelector: {}
  ## @param identity.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param identity.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## @extra identity.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param identity.resources.requests.memory
  ## @param identity.resources.limits.cpu
  ## @param identity.resources.requests.cpu
  ## @param identity.resources.limits.memory
  resources:
    requests:
      cpu: 600m
      memory: 400Mi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param identity.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
  ## @param identity.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param identity.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param identity.extraVolumes can be used to define extra volumes for the identity pods, useful for tls and self-signed certificates
  extraVolumes: []
  ## @param identity.extraVolumeMounts can be used to mount extra volumes for the identity pods, useful for tls and self-signed certificates
  extraVolumeMounts: []

  ## @extra identity.serviceAccount configuration for the service account where the identity pods are assigned to
  serviceAccount:
    ## @param identity.serviceAccount.enabled if true, enables the identity service account
    enabled: true
    ## @param identity.serviceAccount.name can be used to set the name of the identity service account
    name: ""
    ## @param identity.serviceAccount.annotations can be used to set the annotations of the identity service account
    annotations: {}
    ## @param identity.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: true

  ## External PostgreSQL configuration
  ## All of these values are only used when postgresql.enabled is set to false
  ## @param identity.externalDatabase.enabled
  ## @param identity.externalDatabase.host Database host
  ## @param identity.externalDatabase.port Database port number
  ## @param identity.externalDatabase.username Non-root username
  ## @param identity.externalDatabase.password (DEPRECATED - use identity.externalDatabase.secret instead) Password for the non-root username
  ## @param identity.externalDatabase.database The database name
  ## @param identity.externalDatabase.existingSecret (DEPRECATED - use identity.externalDatabase.secret instead) Name of an existing Kubernetes Secret containing the external database credentials for Management Identity.
  ## @param identity.externalDatabase.existingSecretPasswordKey (DEPRECATED - use identity.externalDatabase.secret instead) Name of an existing secret key containing the database credentials
  ##
  externalDatabase:
    enabled: false
    host: ""
    port: 5432
    username: ""
    database: ""
    password: ""
    existingSecret: ""
    existingSecretPasswordKey: ""
    ## @extra identity.externalDatabase.secret configuration to provide the external database password secret.
    secret:
      ## @param identity.externalDatabase.secret.inlineSecret can be used to provide the password as a plain-text value for non-production usage.
      inlineSecret: ""
      ## @param identity.externalDatabase.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the password.
      existingSecret: ""
      ## @param identity.externalDatabase.secret.existingSecretKey defines the key within the existing secret object.
      existingSecretKey: ""

  ## @param identity.configuration if specified, contents will be used as the application.yaml
  configuration: ""
  ## @param identity.extraConfiguration if specified, contents will be used for any extra configuration files such as the log4j2.xml
  extraConfiguration: {}
  ## @param identity.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param identity.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

  ## @extra identity.persistence configuration for optional PVC creation
  persistence:
    ## @param identity.persistence.enabled can be used to create a PVC for persistent storage instead of using emptyDir
    enabled: false
    ## @param identity.persistence.size can be used to define the size of the persistent volume claim
    size: "10Gi"
    ## @param identity.persistence.accessModes can be used to define the access modes for the persistent volume claim
    accessModes: ["ReadWriteOnce"]
    ## @param identity.persistence.storageClassName can be used to define the storage class to use for the persistent volume claim
    # Set to "-" to disable use of default storage class
    storageClassName: ""
    ## @param identity.persistence.existingClaim can be used to specify an existing PVC instead of creating a new one
    existingClaim: ""
    ## @param identity.persistence.annotations can be used to define annotations to add to the persistent volume claim
    annotations: {}
    ## @param identity.persistence.selector can be used to define a label selector for the persistent volume claim
    selector: {}

# Management Identity.
#####   ####   ####  #####  ####  #####  ######  ####   ####  #
#    # #    # #        #   #    # #    # #      #      #    # #
#    # #    #  ####    #   #      #    # #####   ####  #    # #
#####  #    #      #   #   #  ### #####  #           # #  # # #
#      #    # #    #   #   #    # #   #  #      #    # #   #  #
#       ####   ####    #    ####  #    # ######  ####   ### # ######
## @section Management Identity - PostgreSQL Parameters
## @extra identityPostgresql configuration for the PostgreSQL dependency chart used by Management Identity. For more details, check [Bitnami package for PostgreSQL](https://artifacthub.io/packages/helm/bitnami/postgresql#parameters) documentation.
identityPostgresql:
  ## @param identityPostgresql.enabled Enable Management Identity PostgreSQL Helm chart. Required for Multi-Tenancy.
  ##
  enabled: false
  ## @extra identityPostgresql.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param identityPostgresql.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: '{{ .Values.global.compatibility.openshift.adaptSecurityContext | default "disabled" }}'
  # https://hub.docker.com/r/bitnami/postgresql/tags
  ## @param identityPostgresql.image.repository PostgreSQL repo
  ## @param identityPostgresql.image.tag PostgreSQL image tag
  ## @param identityPostgresql.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
  ##
  image:
    repository: bitnamilegacy/postgresql
    tag: 15.10.0-debian-12-r2
    digest: ""
  ## @param identityPostgresql.nameOverride the name used for Management Identity PostgreSQL.
  ##
  nameOverride: identity-postgresql
  auth:
    ## @param identityPostgresql.auth.username Non-root username
    ##
    username: identity
    ## @param identityPostgresql.auth.database The database name
    ##
    database: identity
    ## @param identityPostgresql.auth.password Password for the non-root username
    ##
    password: ""
    ## @param identityPostgresql.auth.existingSecret Name of an existing secret resource containing the database credentials
    ##
    existingSecret: ""
    secretKeys:
      ## @param identityPostgresql.auth.secretKeys.adminPasswordKey defines the key within the existing secret object for PostgreSQL admin.
      adminPasswordKey: "identity-postgresql-admin-password"
      ## @param identityPostgresql.auth.secretKeys.userPasswordKey defines the key within the existing secret object for PostgreSQL user.
      userPasswordKey: "identity-postgresql-user-password"
  volumePermissions:
    image:
      ## @param identityPostgresql.volumePermissions.image.repository
      repository: bitnamilegacy/os-shell
  metrics:
    image:
      ## @param identityPostgresql.metrics.image.repository
      repository: bitnamilegacy/postgres-exporter

# Management Identity.
#    # ###### #   #  ####  #       ####    ##   #    #
#   #  #       # #  #    # #      #    #  #  #  #   #
####   #####    #   #      #      #    # #    # ####
#  #   #        #   #      #      #    # ###### #  #
#   #  #        #   #    # #      #    # #    # #   #
#    # ######   #    ####  ######  ####  #    # #    #
## @section Management Identity - Keycloak Parameters
## @extra identityKeycloak configuration, for the Keycloak dependency chart which is used by Management Identity. For more details, check [Bitnami package for Keycloak](https://artifacthub.io/packages/helm/bitnami/keycloak#parameters) documentation.
identityKeycloak:
  ## @param identityKeycloak.enabled Enable Management Identity Keycloak Helm chart. It is used incorporate with "global.identity.keycloak" to use your own Keycloak instead of the one comes with Camunda Helm chart
  enabled: false
  ## @extra identityKeycloak.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param identityKeycloak.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: '{{ .Values.global.compatibility.openshift.adaptSecurityContext | default "disabled" }}'
    security:
      ## @param identityKeycloak.global.security.allowInsecureImages Allows the use of the Camunda build Keycloak image (including the Management Identity login theme)
      allowInsecureImages: true

  ## @param identityKeycloak.nameOverride the name used for Keycloak.
  nameOverride: "keycloak"

  ## @extra identityKeycloak.image configuration.
  # https://hub.docker.com/r/bitnami/keycloak/tags
  image:
    ## @param identityKeycloak.image.repository image repo
    repository: camunda/keycloak
    ## @param identityKeycloak.image.tag image tag
    tag: 26.3.3
    ## @param identityKeycloak.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""

  ## @extra identityKeycloak.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param identityKeycloak.resources.requests.cpu
  ## @param identityKeycloak.resources.requests.memory
  ## @param identityKeycloak.resources.limits.cpu
  ## @param identityKeycloak.resources.limits.memory
  resources:
    requests:
      cpu: 1000m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @extra identityKeycloak.postgresql configuration.
  postgresql:
    # https://hub.docker.com/r/bitnami/postgresql/tags
    image:
      ## @param identityKeycloak.postgresql.image.repository image repo
      repository: bitnamilegacy/postgresql
      ## @param identityKeycloak.postgresql.image.tag image tag
      tag: 15.10.0-debian-12-r2
      ## @param identityKeycloak.postgresql.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
      digest: ""
    auth:
      ## @param identityKeycloak.postgresql.auth.existingSecret defines the existing secret resource containing the database credentials
      existingSecret: camunda-credentials
      secretKeys:
        ## @param identityKeycloak.postgresql.auth.secretKeys.adminPasswordKey defines the key within the existing secret object for PostgreSQL admin.
        adminPasswordKey: "identity-keycloak-postgresql-admin-password"
        ## @param identityKeycloak.postgresql.auth.secretKeys.userPasswordKey defines the key within the existing secret object for PostgreSQL user.
        userPasswordKey: "identity-keycloak-postgresql-user-password"
    primary:
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.enabled
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.privileged
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.readOnlyRootFilesystem
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.allowPrivilegeEscalation
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.runAsNonRoot
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.runAsUser
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.capabilities.drop
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.seccompProfile.type
      containerSecurityContext:
        enabled: true
        privileged: false
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false
        runAsNonRoot: true
        runAsUser: 1001
        capabilities:
          drop: ["ALL"]
        seccompProfile:
          type: RuntimeDefault
      ## @param identityKeycloak.postgresql.primary.podSecurityContext.enabled
      ## @param identityKeycloak.postgresql.primary.podSecurityContext.runAsNonRoot
      ## @param identityKeycloak.postgresql.primary.podSecurityContext.fsGroup
      podSecurityContext:
        enabled: true
        runAsNonRoot: true
        fsGroup: 1001
    volumePermissions:
      image:
        ## @param identityKeycloak.postgresql.volumePermissions.image.repository
        repository: bitnamilegacy/os-shell
    metrics:
      image:
        ## @param identityKeycloak.postgresql.metrics.image.repository
        repository: bitnamilegacy/postgres-exporter
  # Keycloak.proxy defines the proxy mode depends on the TLS termination in your environment.
  # Docs: https://www.keycloak.org/server/reverseproxy
  ## @param identityKeycloak.proxy keycloak proxy
  proxy: edge

  ## @extra identityKeycloak.tls can be used to enable TLS encryption. Required for HTTPs traffic.
  tls:
    ## @param identityKeycloak.tls.enabled enabling tls
    enabled: false

  # NOTE: Since Helm v3 (latest checked 3.10.x) doesn't merge lists with custom values files, then you will need to
  # add this to your own values file if you override any of "extraVolumes", "initContainers", or "extraVolumeMounts".
  ## @skip identityKeycloak.extraVolumes [object] Extra volumes for keycloak
  ## @skip identityKeycloak.extraVolumes[0].name
  ## @skip identityKeycloak.extraVolumes[0].emptyDir
  ## @skip identityKeycloak.extraVolumes[1].name
  ## @skip identityKeycloak.extraVolumes[1].emptyDir
  extraVolumes:
    - name: data-tmp
      emptyDir: {}
  ## @param identityKeycloak.extraVolumeMounts[0].name
  ## @param identityKeycloak.extraVolumeMounts[0].mountPath
  extraVolumeMounts:
    - name: data-tmp
      mountPath: /opt/bitnami/keycloak/data/tmp

  ## @param identityKeycloak.containerSecurityContext.privileged
  ## @param identityKeycloak.containerSecurityContext.readOnlyRootFilesystem
  ## @param identityKeycloak.containerSecurityContext.allowPrivilegeEscalation
  ## @param identityKeycloak.containerSecurityContext.runAsNonRoot
  ## @param identityKeycloak.containerSecurityContext.runAsUser
  ## @param identityKeycloak.containerSecurityContext.capabilities.drop
  ## @param identityKeycloak.containerSecurityContext.seccompProfile.type
  containerSecurityContext:
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsNonRoot: true
    runAsUser: 1001
    capabilities:
      drop: ["ALL"]
    seccompProfile:
      type: RuntimeDefault
  ## @param identityKeycloak.podSecurityContext.runAsNonRoot
  ## @param identityKeycloak.podSecurityContext.fsGroup
  podSecurityContext:
    runAsNonRoot: true
    fsGroup: 1001
  ## @param identityKeycloak.httpRelativePath defines the context for Keycloak. This config is valid for Keycloak v19.x.x only
  # where in Keycloak v16.x.x it's hard-coded as '/auth', but in v19.x.x it's configurable.
  # NOTE: This should be the same as ".Values.global.identity.keycloak.contextPath" plus a trailing slash,
  # but it cannot be referenced directly because of a bug in Helm (tested with Helm v3.9.3).
  # NOTE: In Keycloak v23, accessing this path without the trailing slash will return "Internal Server Error".
  httpRelativePath: /auth/
  ## @param identityKeycloak.extraEnvVars can be used set extra environment variables to be set on Keycloak container.
  extraEnvVars: []

  # under "global.ingress" is enabled. However, it's possible to setup Keycloak on a separate Ingress if needed.
  # For more details: https://github.com/bitnami/charts/tree/main/bitnami/keycloak#configure-ingress
  ingress:
    ## @param identityKeycloak.ingress.enabled can be used enable ingress record generation for Keycloak.
    enabled: false
    ## @param identityKeycloak.ingress.tls can be used to enable TLS configuration for the host defined at ingress.hostname parameter.
    tls: false
    ## @param identityKeycloak.ingress.extraTls configuration for additional hostnames to be covered with this ingress record.
    extraTls: []
    ## @param identityKeycloak.ingress.labels [object] can be used to define labels which will be applied to the Keycloak ingress resource
    labels: {}
    ## @param identityKeycloak.ingress.annotations [object] configures annotations to be applied to the ingress record.
    annotations:
      ## @skip identityKeycloak.ingress.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
      nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      nginx.ingress.kubernetes.io/proxy-buffering: "on"
    ## @param identityKeycloak.ingress.pathType defines Ingress path type.
    pathType: Prefix

  ## @extra identityKeycloak.service configuration, to configure the service which is deployed along with keycloak
  service:
    ## @param identityKeycloak.service.type can be set to change the service type.
    # We use clusterIP for keycloak service, since per default LoadBalancer is used, which is not supported on all cloud providers.
    # This might prevent scheduling of the service.
    type: ClusterIP
  ## Keycloak authentication parameters
  ## ref: https://github.com/bitnami/bitnami-docker-keycloak#admin-credentials
  ##
  ## @extra identityKeycloak.auth uses the secrets generated by keycloak, to access keycloak.
  auth:
    ## @param identityKeycloak.auth.adminUser defines the keycloak administrator user
    adminUser: admin
    ## @param identityKeycloak.auth.existingSecret can be used to reuse an existing secret containing authentication information.
    # See https://docs.bitnami.com/kubernetes/apps/keycloak/configuration/manage-passwords/ for more details.
    existingSecret: camunda-credentials
    ## @param identityKeycloak.auth.passwordSecretKey defines the key within the existing secret object.
    passwordSecretKey: identity-keycloak-admin-password
  keycloakConfigCli:
    image:
      ## @param identityKeycloak.keycloakConfigCli.image.repository
      repository: bitnamilegacy/keycloak-config-cli

#################################################
 #####
#     #  ####  #    #  ####   ####  #      ######
#       #    # ##   # #      #    # #      #
#       #    # # #  #  ####  #    # #      #####
#       #    # #  # #      # #    # #      #
#     # #    # #   ## #    # #    # #      #
 #####   ####  #    #  ####   ####  ###### ######
#################################################

## @section Console Parameters
## @extra console configuration for the Console.
console:
  ## @param console.enabled if true, the Console deployment and its related resources are deployed via a helm release
  enabled: false

  ## @param console.configuration Configuration passed directly to Console as YAML file. More details on [Console official documenations](https://docs.camunda.io/docs/self-managed/console-deployment/configuration/)
  configuration: ""
  ##@param console.overrideConfiguration When populated, it will override the configuration passed to Console, either auto-generated configuration or passed via `console.configuration`
  overrideConfiguration: ""

  ## console.image configuration to configure the Console image specifics
  # https://hub.docker.com/r/camunda/console/tags
  image:
    ## @param console.image.registry can be used to set container image registry.
    registry: ""
    ## @param console.image.repository defines which image repository to use
    repository: camunda/console
    ## @param console.image.tag can be used to set the Docker image tag for the Console image (overwrites global.image.tag)
    tag: 8.8.69
    ## @param console.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""
    ## @param console.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param console.sidecars can be used to attach extra containers to the console deployment
  sidecars: []

  ## @param console.replicas Number of Console replicas
  replicas: 1

  ## console.tls Configure the Console TLS options
  tls:
    ## @param console.tls.enabled Enable TLS traffic for console
    enabled: false
    ## @param console.tls.existingSecret The name of the existing secret that contains the TLS certificates. Each key of the secret corresponds to a certificate filename, and each value of a key corresponds to the content of the certificate file.
    existingSecret: ""
    ## @param console.tls.certKeyFilename Certificate Key filename
    certKeyFilename: ""

  ## console.keycloak configuration to configure Keycloak authentication settings.
  keycloak:
    ## @param console.keycloak.realm Specifies the Keycloak realm used for authentication.
    realm: "camunda-platform"

  ## @param console.contextPath can be used to make Console web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param console.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []

  ## @param console.podAnnotations can be used to define extra Console pod annotations
  podAnnotations: {}
  ## @param console.podLabels can be used to define extra Console pod labels
  podLabels: {}

  ## @param console.logging configuration for the Console logging. This template will be directly included in the configuration YAML file
  logging: {}

  ## console.service configuration to configure the Console service.
  service:
    ## @param console.service.annotations can be used to define annotations, which will be applied to the Console service
    annotations: {}
    ## @param console.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param console.service.port defines the port number where the web application will be available
    port: 80
    ## @param console.service.serverName defines the port name where the web application will be available
    serverName: http
    ## @param console.service.managementPort defines the management port used to access metrics and app status
    managementPort: 9100

  ## console.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param console.resources.requests.memory
  ## @skip console.resources.limits.cpu
  ## @param console.resources.limits.memory
  ## @skip console.resources.requests.cpu
  ## TODO: remove the skip tag on the cpu keys and add [number, string] modifiers when this issue is resolved: https://github.com/bitnami/readme-generator-for-helm/issues/173
  resources:
    requests:
      cpu: 1000m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param console.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
  ## @param console.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param console.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param console.extraVolumes can be used to define extra volumes for the Console pods, useful for TLS and self-signed certificates
  extraVolumes: []
  ## @param console.extraVolumeMounts can be used to mount extra volumes for the Console pods, useful for TLS and self-signed certificates
  extraVolumeMounts: []

  ## console.startupProbe configuration
  startupProbe:
    ## @param console.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param console.startupProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param console.startupProbe.probePath defines the startup probe route used on the app
    probePath: /health/readiness
    ## @param console.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param console.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param console.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param console.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param console.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## console.readinessProbe configuration
  readinessProbe:
    ## @param console.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param console.readinessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param console.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /health/readiness
    ## @param console.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param console.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param console.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param console.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param console.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## console.livenessProbe configuration
  livenessProbe:
    ## @param console.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param console.livenessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param console.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /health/liveness
    ## @param console.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param console.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param console.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param console.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param console.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## console.metrics configuration
  metrics:
    ## @param console.metrics.prometheus Prometheus metrics endpoint
    prometheus: /prometheus

  ## console.serviceAccount configuration for the service account where the Console pods are assigned to
  serviceAccount:
    ## @param console.serviceAccount.enabled if true, enables the Console service account
    enabled: true
    ## @param console.serviceAccount.name can be used to set the name of the Console service account
    name: ""
    ## @param console.serviceAccount.annotations can be used to set the annotations of the service account
    annotations: {}
    ## @param console.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra console.podSecurityContext defines the security options the Console broker pod should be run with
  podSecurityContext:
    ## @param console.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param console.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra console.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param console.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  # ContainerSecurityContext defines the security options the Console broker container should be run with
  containerSecurityContext:
    ## @param console.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param console.containerSecurityContext.privileged
    privileged: false
    ## @param console.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param console.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param console.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra console.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param console.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @param console.nodeSelector can be used to define on which nodes the Console pods should run
  nodeSelector: {}
  ## @param console.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param console.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  ## @param console.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param console.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

#######################################################################
#     #               #     #
#  #  # ###### #####  ##   ##  ####  #####  ###### #      ###### #####
#  #  # #      #    # # # # # #    # #    # #      #      #      #    #
#  #  # #####  #####  #  #  # #    # #    # #####  #      #####  #    #
#  #  # #      #    # #     # #    # #    # #      #      #      #####
#  #  # #      #    # #     # #    # #    # #      #      #      #   #
## ##  ###### #####  #     #  ####  #####  ###### ###### ###### #    #
#######################################################################
## @section WebModeler Parameters
# WebModeler configuration of the WebModeler deployment
webModeler:
  ## @param webModeler.enabled if true, the WebModeler deployment and its related resources are deployed via a helm release
  enabled: false

  ## @param webModeler.fullnameOverride can be used to override the full name of the WebModeler resources
  fullnameOverride: ""
  ## @param webModeler.nameOverride can be used to partly override the name of the WebModeler resources (names will still be prefixed with the release name)
  nameOverride: ""

  ## @extra webModeler.image configuration of the WebModeler Docker images
  image:
    ## @param webModeler.image.registry can be used to set the Docker registry for the WebModeler images (overwrites global.image.registry)
    registry: ""
    ## @param webModeler.image.tag can be used to set the Docker image tag for the WebModeler images (overwrites global.image.tag)
    # renovate: datasource=docker depName=camunda/web-modeler-restapi
    tag: 8.8.4
    ## @param webModeler.image.pullSecrets can be used to configure image pull secrets, see https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  # Note: The WebSocket application will be exposed on the configured path suffixed with "-ws", e.g. "/modeler-ws"
  # contextPath: "/modeler"
  ## @param webModeler.contextPath can be used to make WebModeler available on a custom sub-path. This is mainly used to run the Camunda web applications under a single domain.
  contextPath: ""

  security:
    ## Authentication configuration
    ## @extra webModeler.security.authentication
    authentication:
      ## @param webModeler.security.authentication.method defines the authentication method which should be used. Possible values: `basic`, `oidc`, or `none`. It could be used to override `global.security.authentication.method`.
      method: ""

  # WebModeler.
  ######                         #    ######  ###
  #     # ######  ####  #####   # #   #     #  #
  #     # #      #        #    #   #  #     #  #
  ######  #####   ####    #   #     # ######   #
  #   #   #           #   #   ####### #        #
  #    #  #      #    #   #   #     # #        #
  #     # ######  ####    #   #     # #       ###
  ## @section WebModeler - RestAPI Parameters
  ## @extra webModeler.restapi configuration of the WebModeler restapi component
  restapi:
    ## @extra webModeler.restapi.image configuration of the restapi Docker image
    image:
      ## @param webModeler.restapi.image.repository defines which image repository to use for the restapi Docker image
      repository: camunda/web-modeler-restapi
      ## @param webModeler.restapi.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
      digest: ""

    ## @param webModeler.restapi.sidecars can be used to attach extra containers to the restapi deployment
    sidecars: []
    ## @param webModeler.restapi.initContainers can be used to set up extra init containers for the application Pod
    initContainers: []

    ## @extra webModeler.restapi.externalDatabase can be used to configure a connection to an external database; will only be applied if the postgresql dependency chart is disabled (with `postgresql.enabled=false`)
    externalDatabase:
      ## @param webModeler.restapi.externalDatabase.url defines the JDBC url of the database instance.
      # Note: If url is provided, it takes precedence over individual connection parameters (host, port, database)
      url: ""
      ## @param webModeler.restapi.externalDatabase.host Database host (used when url is not provided)
      host: ""
      ## @param webModeler.restapi.externalDatabase.port Database port number (used when url is not provided)
      port: 5432
      ## @param webModeler.restapi.externalDatabase.database The database name (used when url is not provided)
      database: "web-modeler"
      ## @param webModeler.restapi.externalDatabase.user defines the database user
      user: ""
      ## @param webModeler.restapi.externalDatabase.password (DEPRECATED - use webModeler.restapi.externalDatabase.secret instead) can be used to provide the database user's password; ignored if `webModeler.restapi.externalDatabase.existingSecret` is set
      password: ""
      ## @param webModeler.restapi.externalDatabase.existingSecret [string,object] (DEPRECATED - use webModeler.restapi.externalDatabase.secret instead) Reference an existing Kubernetes Secret for the DB password (object form with `.name` is recommended in 8.48.7; string form will be treated as a literal password).
      ## @skip webModeler.restapi.externalDatabase.existingSecret.name string Name of the Kubernetes Secret containing the DB password; required when using the object form of `existingSecret`.
      ##    **String form** (schemanative, but in 8.48.7 it will be treated as the literal password rather than the secret name).
      ##   **Object form** (recommended workaround until 8.8 GA):
      ##       existingSecret:
      ##         name: my-webmodeler-db-secret
      existingSecret: ""
      ## @param webModeler.restapi.externalDatabase.existingSecretPasswordKey (DEPRECATED - use webModeler.restapi.externalDatabase.secret instead) string Key in the Secret data that holds the DB password; defaults to `"password"`.
      existingSecretPasswordKey: "database-password"
      ## @extra webModeler.restapi.externalDatabase.secret configuration to provide the database password secret.
      secret:
        ## @param webModeler.restapi.externalDatabase.secret.inlineSecret can be used to provide the password as a plain-text value for non-production usage.
        inlineSecret: ""
        ## @param webModeler.restapi.externalDatabase.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the password.
        existingSecret: ""
        ## @param webModeler.restapi.externalDatabase.secret.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: ""

    ## @extra webModeler.restapi.mail configuration for emails sent by WebModeler
    mail:
      ## @param webModeler.restapi.mail.smtpHost defines the host name of the SMTP server to be used by WebModeler
      smtpHost: ""
      ## @param webModeler.restapi.mail.smtpPort defines the port number of the SMTP server
      smtpPort: 587
      ## @param webModeler.restapi.mail.smtpUser can be used to provide a user for the SMTP server
      smtpUser: ""
      ## @param webModeler.restapi.mail.smtpPassword (DEPRECATED - use webModeler.restapi.mail.secret instead) can be used to provide a password for the SMTP server; ignored if `webModeler.restapi.mail.existingSecret` is set
      smtpPassword: ""
      ## @param webModeler.restapi.mail.smtpTlsEnabled if true, enforces TLS encryption for SMTP connections (using STARTTLS)
      smtpTlsEnabled: true
      ## @param webModeler.restapi.mail.existingSecret [string,object] (DEPRECATED - use webModeler.restapi.mail.secret instead) A string literal SMTP password can be provided. Recommended: reference an existing Kubernetes Secret using webModeler.restapi.mail.existingSecret.name.
      existingSecret: ""
      ## @param webModeler.restapi.mail.existingSecretPasswordKey (DEPRECATED - use webModeler.restapi.mail.secret instead) can be used to provide the name of an existing secret key containing the SMTP password
      existingSecretPasswordKey: "smtp-password"
      ## @extra webModeler.restapi.mail.secret configuration to provide the SMTP password secret.
      secret:
        ## @param webModeler.restapi.mail.secret.inlineSecret can be used to provide the SMTP password as a plain-text value for non-production usage.
        inlineSecret: ""
        ## @param webModeler.restapi.mail.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the SMTP password.
        existingSecret: ""
        ## @param webModeler.restapi.mail.secret.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: ""
      ## @param webModeler.restapi.mail.fromAddress defines the email address that will be displayed as the sender of emails sent by WebModeler
      # NOTE: This value is mandatory.
      fromAddress: ""
      ## @param webModeler.restapi.mail.fromName defines the name that will be displayed as the sender of emails sent by WebModeler
      fromName: "Camunda 8"
    ## @extra webModeler.restapi.pusher configuration for Pusher integration
    pusher:
      ## @extra webModeler.restapi.pusher.secret configuration to provide the Pusher app secret
      secret:
        ## @param webModeler.restapi.pusher.secret.inlineSecret can be used to provide the Pusher app secret as a plain-text value for non-production usage
        inlineSecret: ""
        ## @param webModeler.restapi.pusher.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the Pusher app secret
        existingSecret: ""
        ## @param webModeler.restapi.pusher.secret.existingSecretKey defines the key within the existing secret object
        existingSecretKey: ""

    ## @param webModeler.restapi.clusters can be used to configure Camunda 8 clusters that will be available in Web Modeler (will override default cluster configuration that is used if `orchestration.enabled=true`)
    clusters: []
    #  - id: "default-cluster"
    #    name: "Default cluster"
    #    version: "8.8.0"
    #    authentication: "BEARER_TOKEN"
    #    url:
    #      grpc: "grpc://camunda-platform-orchestration:26500"
    #      rest: "http://camunda-platform-orchestration:8080"
    #      web-app: "http://localhost:8088"

    ## @param webModeler.restapi.podAnnotations can be used to define extra restapi pod annotations
    podAnnotations: {}
    ## @param webModeler.restapi.podLabels can be used to define extra restapi pod labels
    podLabels: {}

    ## @extra webModeler.restapi.logging configuration for the restapi logging. This template will be directly included in the webModeler.restapi configuration YAML file
    ## @param webModeler.restapi.logging.level.io.camunda.modeler https://docs.camunda.io/docs/next/self-managed/modeler/web-modeler/troubleshooting/troubleshoot-zeebe-connection/#how-can-i-debug-log-grpc--zeebe-communication
    ## @param webModeler.restapi.logging.level.io.grpc
    logging:
      level:
        io.camunda.modeler: INFO
        io.grpc: INFO

    ## @param webModeler.restapi.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
    env: []
    ## @param webModeler.restapi.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param webModeler.restapi.command can be used to override the default command provided by the container image, see https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
    command: []
    ## @param webModeler.restapi.extraVolumes can be used to define extra volumes for the restapi pods, useful for TLS and self-signed certificates
    extraVolumes: []
    ## @param webModeler.restapi.extraVolumeMounts can be used to mount extra volumes for the restapi pods, useful for TLS and self-signed certificates
    extraVolumeMounts: []

    ## @param webModeler.restapi.replicas can be used to set the number of replicas for the restapi deployment
    replicas: 1

    ## @extra webModeler.restapi.podSecurityContext can be used to define the security options the restapi pod should be run with
    podSecurityContext:
      ## @param webModeler.restapi.podSecurityContext.runAsNonRoot
      ## @param webModeler.restapi.podSecurityContext.fsGroup
      runAsNonRoot: true
      fsGroup: 1001
      ## @extra webModeler.restapi.podSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.restapi.podSecurityContext.seccompProfile.type
        type: RuntimeDefault
    ## @extra webModeler.restapi.containerSecurityContext can be used to define the security options the restapi container should be run with
    ## @param webModeler.restapi.containerSecurityContext.privileged
    ## @param webModeler.restapi.containerSecurityContext.readOnlyRootFilesystem
    ## @param webModeler.restapi.containerSecurityContext.allowPrivilegeEscalation
    ## @param webModeler.restapi.containerSecurityContext.runAsNonRoot
    ## @param webModeler.restapi.containerSecurityContext.runAsUser
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      ## @extra webModeler.restapi.containerSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.restapi.containerSecurityContext.seccompProfile.type
        type: RuntimeDefault

    ## @extra webModeler.restapi.startupProbe configuration of the restapi startup probe
    startupProbe:
      ## @param webModeler.restapi.startupProbe.enabled if true, the startup probe will be enabled for the restapi container
      enabled: false
      ## @param webModeler.restapi.startupProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.restapi.startupProbe.probePath defines the HTTP endpoint used for the startup probe
      probePath: /health/liveness
      ## @param webModeler.restapi.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 30
      ## @param webModeler.restapi.startupProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.restapi.startupProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.restapi.startupProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.restapi.startupProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.restapi.readinessProbe configuration of the restapi readiness probe
    readinessProbe:
      ## @param webModeler.restapi.readinessProbe.enabled if true, the readiness probe will be enabled for the restapi container
      enabled: true
      ## @param webModeler.restapi.readinessProbe.scheme defines the readiness probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.restapi.readinessProbe.probePath defines the HTTP endpoint used for the readiness probe
      probePath: /health/readiness
      ## @param webModeler.restapi.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 30
      ## @param webModeler.restapi.readinessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.restapi.readinessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.restapi.readinessProbe.failureThreshold defines when the probe is considered failed so the Pod will be marked unready
      failureThreshold: 5
      ## @param webModeler.restapi.readinessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.restapi.livenessProbe configuration of the restapi liveness probe
    livenessProbe:
      ## @param webModeler.restapi.livenessProbe.enabled if true, the liveness probe will be enabled for the restapi container
      enabled: false
      ## @param webModeler.restapi.livenessProbe.scheme defines the liveness probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.restapi.livenessProbe.probePath defines the HTTP endpoint used for the liveness probe
      probePath: /health/liveness
      ## @param webModeler.restapi.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 30
      ## @param webModeler.restapi.livenessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.restapi.livenessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.restapi.livenessProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.restapi.livenessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## Metrics configuration
    metrics:
      ## @param webModeler.restapi.metrics.prometheus Prometheus metrics endpoint
      prometheus: /metrics

    ## @param webModeler.restapi.nodeSelector can be used to select the nodes the restapi pods should run on
    nodeSelector: {}
    ## @param webModeler.restapi.tolerations can be used to define pod tolerations, see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []
    ## @param webModeler.restapi.affinity can be used to define pod affinity or anti-affinity, see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

    ## @extra webModeler.restapi.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param webModeler.restapi.resources.requests.cpu
    ## @param webModeler.restapi.resources.requests.memory
    ## @param webModeler.restapi.resources.limits.cpu
    ## @param webModeler.restapi.resources.limits.memory
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 1000m
        memory: 2Gi

    ## @extra webModeler.restapi.service configuration of the WebModeler restapi service
    service:
      ## @param webModeler.restapi.service.annotations can be used to define annotations which will be applied to the service
      annotations: {}
      ## @param webModeler.restapi.service.type defines the type of the service, see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
      ## @param webModeler.restapi.service.port defines the default port of the service
      port: 80
      ## @param webModeler.restapi.service.managementPort defines the management port of the service
      managementPort: 8091

    ## @param webModeler.restapi.configuration if specified, contents will be used as the application.yaml
    configuration: ""
    ## @param webModeler.restapi.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
    extraConfiguration: {}
    ## @param webModeler.restapi.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: ""
    ## @param webModeler.restapi.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
    dnsConfig: {}

  # WebModeler.
  #    # ###### #####    ##   #####  #####
  #    # #      #    #  #  #  #    # #    #
  #    # #####  #####  #    # #    # #    #
  # ## # #      #    # ###### #####  #####
  ##  ## #      #    # #    # #      #
  #    # ###### #####  #    # #      #
  ## @section WebModeler - WebApp Parameters
  ## @extra webModeler.webapp. configuration of the WebModeler webapp component
  webapp:
    ## @extra webModeler.webapp.image configuration of the webapp Docker image
    image:
      ## @param webModeler.webapp.image.repository defines which image repository to use for the webapp Docker image
      repository: camunda/web-modeler-webapp
      ## @param webModeler.webapp.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
      digest: ""

    ## @param webModeler.webapp.sidecars can be used to attach extra containers to the modeler webapp deployment
    sidecars: []
    ## @param webModeler.webapp.initContainers can be used to set up extra init containers for the application Pod
    initContainers: []

    ## @param webModeler.webapp.podAnnotations can be used to define extra webapp pod annotations
    podAnnotations: {}
    ## @param webModeler.webapp.podLabels can be used to define extra webapp pod labels
    podLabels: {}

    ## @param webModeler.webapp.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
    env: []
    ## @param webModeler.webapp.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param webModeler.webapp.command can be used to override the default command provided by the container image, see https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
    command: []
    ## @param webModeler.webapp.extraVolumes can be used to define extra volumes for the webapp pods, useful for TLS and self-signed certificates
    extraVolumes: []
    ## @param webModeler.webapp.extraVolumeMounts can be used to mount extra volumes for the webapp pods, useful for TLS and self-signed certificates
    extraVolumeMounts: []

    ## @param webModeler.webapp.replicas can be used to set the number of replicas for the webapp deployment
    replicas: 1

    ## @extra webModeler.webapp.podSecurityContext can be used to define the security options the webapp pod should be run with
    ## @param webModeler.webapp.podSecurityContext.runAsNonRoot
    ## @param webModeler.webapp.podSecurityContext.fsGroup
    podSecurityContext:
      runAsNonRoot: true
      fsGroup: 1001
      ## @extra webModeler.webapp.podSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.webapp.podSecurityContext.seccompProfile.type
        type: RuntimeDefault
    ## @extra webModeler.webapp.containerSecurityContext can be used to define the security options the webapp container should be run with
    ## @param webModeler.webapp.containerSecurityContext.privileged
    ## @param webModeler.webapp.containerSecurityContext.readOnlyRootFilesystem
    ## @param webModeler.webapp.containerSecurityContext.allowPrivilegeEscalation
    ## @param webModeler.webapp.containerSecurityContext.runAsNonRoot
    ## @param webModeler.webapp.containerSecurityContext.runAsUser
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      ## @extra webModeler.webapp.containerSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.webapp.containerSecurityContext.seccompProfile.type
        type: RuntimeDefault

    ## @extra webModeler.webapp.startupProbe configuration of the webapp startup probe
    startupProbe:
      ## @param webModeler.webapp.startupProbe.enabled if true, the startup probe will be enabled for the webapp container
      enabled: false
      ## @param webModeler.webapp.startupProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.webapp.startupProbe.probePath defines the HTTP endpoint used for the startup probe
      probePath: /health/liveness
      ## @param webModeler.webapp.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 15
      ## @param webModeler.webapp.startupProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.webapp.startupProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.webapp.startupProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.webapp.startupProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.webapp.readinessProbe configuration of the webapp readiness probe
    readinessProbe:
      ## @param webModeler.webapp.readinessProbe.enabled if true, the readiness probe will be enabled for the webapp container
      enabled: true
      ## @param webModeler.webapp.readinessProbe.scheme defines the readiness probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.webapp.readinessProbe.probePath defines the HTTP endpoint used for the readiness probe
      probePath: /health/readiness
      ## @param webModeler.webapp.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 15
      ## @param webModeler.webapp.readinessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.webapp.readinessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.webapp.readinessProbe.failureThreshold defines when the probe is considered failed so the Pod will be marked unready
      failureThreshold: 5
      ## @param webModeler.webapp.readinessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.webapp.livenessProbe configuration of the webapp liveness probe
    livenessProbe:
      ## @param webModeler.webapp.livenessProbe.enabled if true, the liveness probe will be enabled for the webapp container
      enabled: false
      ## @param webModeler.webapp.livenessProbe.scheme defines the liveness probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.webapp.livenessProbe.probePath defines the HTTP endpoint used for the liveness probe
      probePath: /health/liveness
      ## @param webModeler.webapp.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 15
      ## @param webModeler.webapp.livenessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.webapp.livenessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.webapp.livenessProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.webapp.livenessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## Metrics configuration
    metrics:
      ## @param webModeler.webapp.metrics.prometheus Prometheus metrics endpoint
      prometheus: /metrics

    ## @param webModeler.webapp.nodeSelector can be used to select the nodes the webapp pods should run on
    nodeSelector: {}
    ## @param webModeler.webapp.tolerations can be used to define pod tolerations, see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []
    ## @param webModeler.webapp.affinity can be used to define pod affinity or anti-affinity, see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

    ## @extra webModeler.webapp.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param webModeler.webapp.resources.requests.cpu
    ## @param webModeler.webapp.resources.requests.memory
    ## @param webModeler.webapp.resources.limits.cpu
    ## @param webModeler.webapp.resources.limits.memory
    resources:
      requests:
        cpu: 400m
        memory: 256Mi
      limits:
        cpu: 800m
        memory: 512Mi

    ## @extra webModeler.webapp.service configuration of the WebModeler webapp service
    service:
      ## @param webModeler.webapp.service.annotations can be used to define annotations which will be applied to the service
      annotations: {}
      ## @param webModeler.webapp.service.type defines the type of the service, see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
      ## @param webModeler.webapp.service.port defines the port of the service
      port: 80
      ## @param webModeler.webapp.service.managementPort defines the management port of the service
      managementPort: 8071

    ## @param webModeler.webapp.configuration if specified, contents will be used as the application.yaml
    configuration: ""
    ## @param webModeler.webapp.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
    extraConfiguration: {}
    ## @param webModeler.webapp.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: ""
    ## @param webModeler.webapp.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
    dnsConfig: {}

  # WebModeler.
  #    # ###### #####   ####   ####   ####  #    # ###### #####  ####
  #    # #      #    # #      #    # #    # #   #  #        #   #
  #    # #####  #####   ####  #    # #      ####   #####    #    ####
  # ## # #      #    #      # #    # #      #  #   #        #        #
  ##  ## #      #    # #    # #    # #    # #   #  #        #   #    #
  #    # ###### #####   ####   ####   ####  #    # ######   #    ####
  ## @section WebModeler - WebSockets Parameters
  ## @extra webModeler.websockets configuration of the WebModeler websockets component
  websockets:
    ## @extra webModeler.websockets.image configuration of the websockets Docker image
    image:
      ## @param webModeler.websockets.image.repository defines which image repository to use for the websockets Docker image
      repository: camunda/web-modeler-websockets
      ## @param webModeler.websockets.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
      digest: ""

    ## @param webModeler.websockets.sidecars can be used to attach extra containers to the modeler websockets deployment
    sidecars: []
    ## @param webModeler.websockets.initContainers can be used to set up extra init containers for the application Pod
    initContainers: []

    ## @param webModeler.websockets.publicHost can be used to define the host on which the WebSockets server can be reached from the WebModeler client in the browser.
    # The default value assumes that a port-forwarding to the websockets service has been created.
    # Note: The host will only be used if the Ingress resource for WebModeler is disabled.
    publicHost: localhost
    ## @param webModeler.websockets.publicPort can be used to define the port number on which the WebSockets server can be reached from the WebModeler client in the browser.
    # The default value assumes that a port-forwarding to the websockets service on port 8085 has been created.
    # Note: The port will only be used if the Ingress resource for WebModeler is disabled.
    publicPort: 8085

    ## @param webModeler.websockets.podAnnotations can be used to define extra websockets pod annotations
    podAnnotations: {}
    ## @param webModeler.websockets.podLabels can be used to define extra websockets pod labels
    podLabels: {}

    ## @param webModeler.websockets.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
    env: []
    ## @param webModeler.websockets.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param webModeler.websockets.command can be used to override the default command provided by the container image, see https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
    command: []
    ## @param webModeler.websockets.extraVolumes can be used to define extra volumes for the websockets pod; useful for logging to a file
    extraVolumes: []
    ## @param webModeler.websockets.extraVolumeMounts can be used to mount extra volumes for the websockets pod; useful for logging to a file
    extraVolumeMounts: []

    ## @extra webModeler.websockets.podSecurityContext can be used to define the security options the websockets pod should be run with
    ## @param webModeler.websockets.podSecurityContext.runAsNonRoot
    ## @param webModeler.websockets.podSecurityContext.fsGroup
    podSecurityContext:
      runAsNonRoot: true
      fsGroup: 1001
      ## @extra webModeler.websockets.podSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.websockets.podSecurityContext.seccompProfile.type
        type: RuntimeDefault
    ## @extra webModeler.websockets.containerSecurityContext can be used to define the security options the websockets container should be run with
    ## @param webModeler.websockets.containerSecurityContext.privileged
    ## @param webModeler.websockets.containerSecurityContext.readOnlyRootFilesystem
    ## @param webModeler.websockets.containerSecurityContext.allowPrivilegeEscalation
    ## @param webModeler.websockets.containerSecurityContext.runAsNonRoot
    ## @param webModeler.websockets.containerSecurityContext.runAsUser
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      ## @extra webModeler.websockets.containerSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.websockets.containerSecurityContext.seccompProfile.type
        type: RuntimeDefault

    ## @extra webModeler.websockets.startupProbe configuration of the websockets startup probe
    startupProbe:
      ## @param webModeler.websockets.startupProbe.enabled if true, the startup probe will be enabled for the websockets container
      enabled: false
      ## @param webModeler.websockets.startupProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.websockets.startupProbe.probePath defines the HTTP endpoint used for the startup probe
      probePath: /up
      ## @param webModeler.websockets.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 10
      ## @param webModeler.websockets.startupProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.websockets.startupProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.websockets.startupProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.websockets.startupProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.websockets.readinessProbe configuration of the websockets readiness probe
    readinessProbe:
      ## @param webModeler.websockets.readinessProbe.enabled if true, the readiness probe will be enabled for the websockets container
      enabled: true
      ## @param webModeler.websockets.readinessProbe.scheme defines the readiness probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.websockets.readinessProbe.probePath defines the HTTP endpoint used for the readiness probe
      probePath: /up
      ## @param webModeler.websockets.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 10
      ## @param webModeler.websockets.readinessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.websockets.readinessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.websockets.readinessProbe.failureThreshold defines when the probe is considered failed so the Pod will be marked unready
      failureThreshold: 5
      ## @param webModeler.websockets.readinessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.websockets.livenessProbe configuration of the websockets liveness probe
    livenessProbe:
      ## @param webModeler.websockets.livenessProbe.enabled if true, the liveness probe will be enabled for the websockets container
      enabled: false
      ## @param webModeler.websockets.livenessProbe.scheme defines the liveness probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.websockets.livenessProbe.probePath defines the HTTP endpoint used for the liveness probe
      probePath: /up
      ## @param webModeler.websockets.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 10
      ## @param webModeler.websockets.livenessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.websockets.livenessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.websockets.livenessProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.websockets.livenessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @param webModeler.websockets.nodeSelector can be used to select the nodes the websockets pods should run on
    nodeSelector: {}
    ## @param webModeler.websockets.tolerations can be used to define pod tolerations, see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []
    ## @param webModeler.websockets.affinity can be used to define pod affinity or anti-affinity, see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

    ## @extra webModeler.websockets.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param webModeler.websockets.resources.requests.cpu
    ## @param webModeler.websockets.resources.requests.memory
    ## @param webModeler.websockets.resources.limits.cpu
    ## @param webModeler.websockets.resources.limits.memory
    resources:
      requests:
        cpu: 100m
        memory: 64Mi
      limits:
        cpu: 200m
        memory: 128Mi

    ## @extra webModeler.websockets.service configuration of the WebModeler websockets service
    service:
      ## @param webModeler.websockets.service.annotations can be used to define annotations which will be applied to the service
      annotations: {}
      ## @param webModeler.websockets.service.type defines the type of the service, see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
      ## @param webModeler.websockets.service.port defines the port of the service
      port: 80
    ## @param webModeler.websockets.configuration if specified, contents will be used as the application.yaml
    configuration: ""
    ## @param webModeler.websockets.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
    extraConfiguration: {}
    ## @param webModeler.websockets.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: ""
    ## @param webModeler.websockets.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
    dnsConfig: {}

  ## @extra webModeler.serviceAccount configuration for the service account the WebModeler pods are assigned to
  serviceAccount:
    ## @param webModeler.serviceAccount.enabled if true, enables the WebModeler service account
    enabled: true
    ## @param webModeler.serviceAccount.name can be used to set the name of the WebModeler service account
    name: ""
    ## @param webModeler.serviceAccount.annotations can be used to set the annotations of the WebModeler service account
    annotations: {}
    ## @param webModeler.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra webModeler.persistence configuration for optional PVC creation
  persistence:
    ## @param webModeler.persistence.enabled can be used to create a PVC for persistent storage instead of using emptyDir
    enabled: false
    ## @param webModeler.persistence.size can be used to define the size of the persistent volume claim
    size: "5Gi"
    ## @param webModeler.persistence.accessModes can be used to define the access modes for the persistent volume claim
    accessModes: ["ReadWriteOnce"]
    ## @param webModeler.persistence.storageClassName can be used to define the storage class to use for the persistent volume claim
    # Set to "-" to disable use of default storage class
    storageClassName: ""
    ## @param webModeler.persistence.existingClaim can be used to specify an existing PVC instead of creating a new one
    existingClaim: ""
    ## @param webModeler.persistence.annotations can be used to define annotations to add to the persistent volume claim
    annotations: {}
    ## @param webModeler.persistence.selector can be used to define a label selector for the persistent volume claim
    selector: {}

  ## @extra webModeler.serviceAccount configuration for the service account the WebModeler pods are assigned to

# WebModeler.
#####   ####   ####  #####  ####  #####  ######  ####   ####  #
#    # #    # #        #   #    # #    # #      #      #    # #
#    # #    #  ####    #   #      #    # #####   ####  #    # #
#####  #    #      #   #   #  ### #####  #           # #  # # #
#      #    # #    #   #   #    # #   #  #      #    # #   #  #
#       ####   ####    #    ####  #    # ######  ####   ### # ######
## @section WebModeler - PostgreSQL Parameters
## @extra postgresql configuration for the postgresql dependency chart used by WebModeler. See the chart documentation https://github.com/bitnami/charts/tree/master/bitnami/postgresql#parameters for more details.
webModelerPostgresql:
  ## @param webModelerPostgresql.enabled if true, a PostgreSQL database will be deployed as part of the Helm release by using the dependency chart
  # Note: If WebModeler is enabled, and WebModeler Postgresql is disabled, the external database configuration must be set under "webModeler.restapi.externalDatabase".
  enabled: false
  ## @extra postgresql.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param webModelerPostgresql.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: '{{ .Values.global.compatibility.openshift.adaptSecurityContext | default "disabled" }}'
  ## @param webModelerPostgresql.nameOverride defines the name of the Postgres resources (names will be prefixed with the release name), see https://github.com/bitnami/charts/tree/main/bitnami/postgresql#common-parameters
  # Note: Don't use the name "postgresql" which is already used for Keycloak's database.
  nameOverride: postgresql-web-modeler
  # https://hub.docker.com/r/bitnami/postgresql/tags
  ## @param webModelerPostgresql.image.repository PostgreSQL repo
  ## @param webModelerPostgresql.image.tag PostgreSQL image tag
  ## @param webModelerPostgresql.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
  image:
    repository: bitnamilegacy/postgresql
    tag: 14.18.0-debian-12-r0
    digest: ""
  ## @extra postgresql.auth configuration of the database authentication
  auth:
    ## @param webModelerPostgresql.auth.username defines the name of the database user to be created for WebModeler
    username: web-modeler
    ## @param webModelerPostgresql.auth.password can be used to provide the database user's password; a random password will be generated if left empty / ignored if `postgresql.auth.existingSecret` is set
    password: ""
    ## @param webModelerPostgresql.auth.database defines the name of the database to be created for WebModeler
    database: web-modeler
    ## @param webModelerPostgresql.auth.existingSecret can be used to provide the name of an existing secret resource containing the database password
    existingSecret: ""
    secretKeys:
      ## @param webModelerPostgresql.auth.secretKeys.adminPasswordKey defines the key within the existing secret object for PostgreSQL admin.
      adminPasswordKey: "web-modeler-postgresql-admin-password"
      ## @param webModelerPostgresql.auth.secretKeys.userPasswordKey defines the key within the existing secret object for PostgreSQL user.
      userPasswordKey: "web-modeler-postgresql-user-password"

  ## @param webModelerPostgresql.primary.containerSecurityContext.enabled
  ## @param webModelerPostgresql.primary.containerSecurityContext.allowPrivilegeEscalation
  ## @param webModelerPostgresql.primary.containerSecurityContext.privileged
  ## @param webModelerPostgresql.primary.containerSecurityContext.readOnlyRootFilesystem
  ## @param webModelerPostgresql.primary.containerSecurityContext.runAsNonRoot
  ## @param webModelerPostgresql.primary.containerSecurityContext.runAsUser
  ## @param webModelerPostgresql.primary.containerSecurityContext.capabilities.drop
  ## @param webModelerPostgresql.primary.containerSecurityContext.seccompProfile.type
  primary:
    containerSecurityContext:
      enabled: true
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: RuntimeDefault
    ## @param webModelerPostgresql.primary.podSecurityContext.enabled
    ## @param webModelerPostgresql.primary.podSecurityContext.runAsNonRoot
    ## @param webModelerPostgresql.primary.podSecurityContext.fsGroup
    podSecurityContext:
      enabled: true
      runAsNonRoot: true
      fsGroup: 1001

#####################################################################
 #####
#     #  ####  #    # #    # ######  ####  #####  ####  #####   ####
#       #    # ##   # ##   # #      #    #   #   #    # #    # #
#       #    # # #  # # #  # #####  #        #   #    # #    #  ####
#       #    # #  # # #  # # #      #        #   #    # #####       #
#     # #    # #   ## #   ## #      #    #   #   #    # #   #  #    #
 #####   ####  #    # #    # ######  ####    #    ####  #    #  ####
#####################################################################
## @section Connectors Parameters
## @extra connectors configuration for the Connectors.
connectors:
  ## @param connectors.enabled if true, the Connectors deployment and its related resources are deployed via a helm release
  enabled: true

  ## @extra connectors.security.authentication.oidc configuration to configure Connectors authentication specifics on global level, which can be accessed by other components
  security:
    ## Authentication configuration
    ## @extra connectors.security.authentication
    authentication:
      ## @param connectors.security.authentication.method defines the authentication method which should be used. Possible values: `basic`, `oidc`, or `none`. It could be used to override `global.security.authentication.method`.
      method: ""
      oidc:
        ## @param connectors.security.authentication.oidc.clientId defines the client id, which is used by Connectors in authentication flows.
        clientId: connectors
        ## @param connectors.security.authentication.oidc.tokenScope defines the token scope, which is used by Connectors.
        tokenScope: ""
        ## @param connectors.security.authentication.oidc.existingSecret [string,object] (DEPRECATED - use connectors.security.authentication.oidc.secret instead) A string literal secret can be provided. If not set, a random secret is generated. Recommended: reference an existing Kubernetes Secret using connectors.security.authentication.oidc.existingSecret.name.
        existingSecret: ""
        ## @param connectors.security.authentication.oidc.existingSecretKey (DEPRECATED - use connectors.security.authentication.oidc.secret instead) defines the key within the existing secret object.
        existingSecretKey: identity-connectors-client-token
        ## @extra connectors.security.authentication.oidc.secret configuration to provide the connectors client secret.
        secret:
          ## @param connectors.security.authentication.oidc.secret.inlineSecret can be used to provide the client secret as a plain-text value for non-production usage.
          inlineSecret: ""
          ## @param connectors.security.authentication.oidc.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the client secret.
          existingSecret: ""
          ## @param connectors.security.authentication.oidc.secret.existingSecretKey defines the key within the existing secret object.
          existingSecretKey: ""

  ## @extra connectors.image configuration to configure the Connectors image specifics
  # https://hub.docker.com/r/camunda/connectors-bundle/tags
  image:
    ## @param connectors.image.registry can be used to set container image registry.
    registry: ""
    ## @param connectors.image.repository defines which image repository to use
    repository: camunda/connectors-bundle
    ## @param connectors.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.4
    ## @param connectors.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""
    ## @param connectors.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param connectors.sidecars can be used to attach extra containers to the connectors deployment
  sidecars: []
  ## @param connectors.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []

  ## @param connectors.replicas number of Connectors replicas
  replicas: 1

  # contextPath: "/connectors"
  ## @param connectors.contextPath can be used to make Connectors web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param connectors.podAnnotations can be used to define extra Connectors pod annotations
  podAnnotations: {}
  ## @param connectors.podLabels can be used to define extra Connectors pod labels
  podLabels: {}

  ## @extra connectors.logging configuration for the Connectors logging. This template will be directly included in the connector configuration YAML file
  ## @param connectors.logging.level.io.camunda.connector
  logging:
    level:
      io.camunda.connector: INFO

  ## @extra connectors.service configuration to configure the Connectors service.
  service:
    ## @param connectors.service.annotations can be used to define annotations, which will be applied to the Connectors service
    annotations: {}
    ## @param connectors.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param connectors.service.serverPort defines the port number where the Connector web application will be available
    serverPort: 8080
    ## @param connectors.service.serverName defines the port name where the Connector web application will be available
    serverName: http

  ## @extra connectors.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @skip connectors.resources.requests.cpu
  ## @param connectors.resources.requests.memory
  ## @skip connectors.resources.limits.cpu
  ## @param connectors.resources.limits.memory
  ## TODO: remove the skip tag on the cpu keys and add [number, string] modifiers when this issue is resolved: https://github.com/bitnami/readme-generator-for-helm/issues/173
  resources:
    requests:
      cpu: 1000m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param connectors.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
  ## @param connectors.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param connectors.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param connectors.extraVolumes can be used to define extra volumes for the Connectors pods, useful for TLS and self-signed certificates
  extraVolumes: []
  ## @param connectors.extraVolumeMounts can be used to mount extra volumes for the Connectors pods, useful for TLS and self-signed certificates
  extraVolumeMounts: []

  ## @extra connectors.startupProbe configuration
  startupProbe:
    ## @param connectors.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param connectors.startupProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param connectors.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health/readiness
    ## @param connectors.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param connectors.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param connectors.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param connectors.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param connectors.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra connectors.readinessProbe configuration
  readinessProbe:
    # TODO: Enalbe the readiness again once the Zeebe client in Connectors is updated (it should be done before 8.8 release).
    ## @param connectors.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param connectors.readinessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param connectors.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health/readiness
    ## @param connectors.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param connectors.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param connectors.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param connectors.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param connectors.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra connectors.livenessProbe configuration
  livenessProbe:
    ## @param connectors.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param connectors.livenessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param connectors.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /actuator/health/liveness
    ## @param connectors.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    ## @param connectors.livenessProbe.initialDelaySeconds the probe is initiated.
    initialDelaySeconds: 30
    ## @param connectors.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param connectors.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param connectors.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param connectors.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param connectors.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @extra connectors.serviceAccount configuration for the service account where the Connectors pods are assigned to
  serviceAccount:
    ## @param connectors.serviceAccount.enabled if true, enables the Connectors service account
    enabled: true
    ## @param connectors.serviceAccount.name can be used to set the name of the Connectors service account
    name: ""
    ## @param connectors.serviceAccount.annotations can be used to set the annotations of the service account
    annotations: {}
    ## @param connectors.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra connectors.podSecurityContext defines the security options the Connectors pod should be run with
  podSecurityContext:
    ## @param connectors.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param connectors.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra connectors.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param connectors.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra connectors.containerSecurityContext defines the security options the Connectors container should be run with
  ## @param connectors.containerSecurityContext.privileged
  ## @param connectors.containerSecurityContext.readOnlyRootFilesystem
  ## @param connectors.containerSecurityContext.allowPrivilegeEscalation
  ## @param connectors.containerSecurityContext.runAsNonRoot
  ## @param connectors.containerSecurityContext.runAsUser
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    ## @extra connectors.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param connectors.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @param connectors.nodeSelector can be used to define on which nodes the Connectors pods should run
  nodeSelector: {}
  ## @param connectors.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param connectors.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  ## @param connectors.configuration if specified, contents will be used as the application.yaml
  configuration: ""
  ## @param connectors.extraConfiguration if specified, contents will be used for any extra configuration files such as the log4j2.xml
  extraConfiguration: {}
  ## @param connectors.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param connectors.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

  ## @extra connectors.persistence configuration for optional PVC creation
  persistence:
    ## @param connectors.persistence.enabled can be used to create a PVC for persistent storage instead of using emptyDir
    enabled: false
    ## @param connectors.persistence.size can be used to define the size of the persistent volume claim
    size: "5Gi"
    ## @param connectors.persistence.accessModes can be used to define the access modes for the persistent volume claim
    accessModes: ["ReadWriteOnce"]
    ## @param connectors.persistence.storageClassName can be used to define the storage class to use for the persistent volume claim
    # Set to "-" to disable use of default storage class
    storageClassName: ""
    ## @param connectors.persistence.existingClaim can be used to specify an existing PVC instead of creating a new one
    existingClaim: ""
    ## @param connectors.persistence.annotations can be used to define annotations to add to the persistent volume claim
    annotations: {}
    ## @param connectors.persistence.selector can be used to define a label selector for the persistent volume claim
    selector: {}

####################################################################################
#######
#     # #####   ####  #    # ######  ####  ##### #####    ##   ##### #  ####  #    #
#     # #    # #    # #    # #      #        #   #    #  #  #    #   # #    # ##   #
#     # #    # #      ###### #####   ####    #   #    # #    #   #   # #    # # #  #
#     # #####  #      #    # #           #   #   #####  ######   #   # #    # #  # #
#     # #   #  #    # #    # #      #    #   #   #   #  #    #   #   # #    # #   ##
####### #    #  ####  #    # ######  ####    #   #    # #    #   #   #  ####  #    #
####################################################################################

## @section Orchestration Cluster Parameters
## @extra orchestration configuration for the Orchestration Cluster.
orchestration:
  ## @param orchestration.enabled if true, the orchestration cluster deployment and its related resources are deployed via a helm release
  enabled: true

  ## @param orchestration.debug if true, extra info is printed.
  debug: false

  ## @param orchestration.profiles [object] defines which components of the orchestration orchestration are enabled (e.g., broker, identity, operate).
  profiles:
    broker: true
    identity: true
    operate: true
    tasklist: true

  ## @param orchestration.profilesOverride [string] defines the override for the profiles as comma-separated string.
  profilesOverride: ""

  security:
    ## Authentication configuration
    ## @extra orchestration.security.authentication
    authentication:
      ## @param orchestration.security.authentication.method defines the authentication method which should be used. Possible values: `basic`, `oidc`, or `none`. It could be used to override `global.security.authentication.method`.
      method: ""
      ## @param orchestration.security.authentication.unprotectedApi if true, then allow unauthenticated API access.
      unprotectedApi: false
      ## @param orchestration.security.authentication.authenticationRefreshInterval defines the session's authentication refresh time, defaulted to PT30S.
      authenticationRefreshInterval: "PT30S"

      # @extra orchestration.security.authentication.oidc
      oidc:
        ## @param orchestration.security.authentication.oidc.type can be used to override `global.identity.auth.type`.
        type: ""
        ## @param orchestration.security.authentication.oidc.issuer can be used to override `global.identity.auth.issuer`.
        issuer: ""
        ## @param orchestration.security.authentication.oidc.authUrl can be used to override `global.identity.auth.authUrl`.
        authUrl: ""
        ## @param orchestration.security.authentication.oidc.tokenUrl can be used to override `global.identity.auth.tokenUrl`.
        tokenUrl: ""
        ## @param orchestration.security.authentication.oidc.jwksUrl can be used to override `global.identity.auth.jwksUrl`.
        jwksUrl: ""
        ## @param orchestration.security.authentication.oidc.usernameClaim can be used to set username claim.
        usernameClaim: preferred_username
        ## @param orchestration.security.authentication.oidc.preferUsernameClaim can be used to set OIDC prefer-username-claim.
        preferUsernameClaim: false
        ## @param orchestration.security.authentication.oidc.clientIdClaim can be used to set client ID claim.
        clientIdClaim: client_id
        ## @param orchestration.security.authentication.oidc.groupsClaim can be used to set group claim.
        groupsClaim: "groups"
        ## @param orchestration.security.authentication.oidc.audience defines the audience, which is used by Orchestration Cluster.
        audience: orchestration-api
        ## @param orchestration.security.authentication.oidc.scope defines a list of scopes to request in the OIDC token. If not set, it will use the application defaults.
        scope: []
        ## @param orchestration.security.authentication.oidc.backwardsCompatibleAudiences defines audiences, which need to be set for backwards compatibility to allow the access the Orchestration Cluster. This is only important and set if you're coming from an earlier version
        backwardsCompatibleAudiences: []
        ## @param orchestration.security.authentication.oidc.clientId defines the client id, which is used by Orchestration Cluster in authentication flows.
        clientId: orchestration
        ## @param orchestration.security.authentication.oidc.redirectUrl defines the root (or redirect) URL, which is used by Keycloak to access Tasklist.
        # Should be publicly accessible, the default value works if a port-forward to Orchestration Cluster is created to 8080.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8080"
        ## @param orchestration.security.authentication.oidc.existingSecret [string,object] (DEPRECATED - use orchestration.security.authentication.oidc.secret instead) A string literal password can be provided. If not set, a random secret is generated. Recommended: reference an existing Kubernetes Secret using orchestration.security.authentication.oidc.existingSecret.name.
        existingSecret: ""
        ## @param orchestration.security.authentication.oidc.existingSecretKey (DEPRECATED - use orchestration.security.authentication.oidc.secret instead) defines the key within the existing secret object.
        existingSecretKey: identity-orchestration-client-token
        ## @extra orchestration.security.authentication.oidc.secret configuration to provide the orchestration client secret.
        secret:
          ## @param orchestration.security.authentication.oidc.secret.inlineSecret can be used to provide the client secret as a plain-text value for non-production usage.
          inlineSecret: ""
          ## @param orchestration.security.authentication.oidc.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the client secret.
          existingSecret: ""
          ## @param orchestration.security.authentication.oidc.secret.existingSecretKey defines the key within the existing secret object.
          existingSecretKey: ""

    ## Authorizations configuration.
    ## @extra orchestration.security.authorizations
    authorizations:
      ## @param orchestration.security.authorizations.enabled if true, then enable authorizations checks in all applicable components.
      enabled: true

    ## Initialization configuration
    ## @extra orchestration.security.initialization
    initialization:
      ## Initial admin users configurations
      ## @extra orchestration.security.initialization.users
      ## @param orchestration.security.initialization.users[0].username
      ## @param orchestration.security.initialization.users[0].password
      ## @param orchestration.security.initialization.users[0].name
      ## @param orchestration.security.initialization.users[0].email
      ## @param orchestration.security.initialization.users[1].username
      ## @param orchestration.security.initialization.users[1].password
      ## @param orchestration.security.initialization.users[1].name
      ## @param orchestration.security.initialization.users[1].email
      users:
        ## @extra orchestration.security.initialization.users.username, the username of an initial user, used for the connectors component.
        - username: connectors
          ## @extra orchestration.security.initialization.users.password, the password of an initial user, used for the connectors component.
          password: connector
          ## @extra orchestration.security.initialization.users.name, the name of an initial user, used for the connectors component.
          name: Connector User
          ## @extra orchestration.security.initialization.users.email, the email of an initial user, used for the connectors component.
          email: connector@demo.com
        ## @extra orchestration.security.initialization.users.username, the username of an initial user, used for the connectors component.
        - username: demo
          ## @extra orchestration.security.initialization.users.password, the password of an initial user.
          password: demo
          ## @extra orchestration.security.initialization.users.name, the name of an initial user.
          name: Demo User
          ## @extra orchestration.security.initialization.users.email, the email of an initial user.
          email: demo@demo.com
      ## @extra orchestration.security.initialization.defaultRoles assigning initial users to default roles. More roles can be added to the dictionary: https://docs.camunda.io/docs/next/components/concepts/access-control/authorizations/#default-roles
      ## @param orchestration.security.initialization.defaultRoles.admin.users defines the initial users that will get the admin permission
      ## @param orchestration.security.initialization.defaultRoles.admin.mappingRules defines the mapping rule IDs for role assignment
      ## @param orchestration.security.initialization.defaultRoles.connectors.users defines the initial users that will get the connectors permission
      ## @param orchestration.security.initialization.defaultRoles.connectors.clients define clients for the orchestration cluster.
      ## @param orchestration.security.initialization.defaultRoles.connectors.mappingRules defines the mapping rule IDs for role assignment
      defaultRoles:
        admin:
          mappingRules: []
          users:
            - demo
        connectors:
          mappingRules: []
          users:
            ## @extra orchestration.security.initialization.defaultRoles.connectors.users[0].connectors Needed for basic auth setup. Can be removed for OIDC. Define the connectors user with the connectors role.
            - connectors
          clients:
            ## @extra orchestration.security.initialization.defaultRoles.connectors.clients[0].connectors Needed for OIDC setup. Can be removed for basic auth. Define the connectors client with the connrectors role.
            - connectors
      ## @param orchestration.security.initialization.mappingRules defines the mapping rules when connected to an OIDC provider.
      # Example:
      # mappingRules:
      #   - mappingRuleID: demo-user-mapping-rule
      #     claimName: preferred_username
      #     claimValue: demo
      mappingRules: []
  ## @extra orchestration.image configuration to configure the image specifics
  image:
    ## @param orchestration.image.registry can be used to set container image registry.
    registry: ""
    ## @param orchestration.image.repository defines which image repository to use
    repository: camunda/camunda
    ## @param orchestration.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.8
    ## @param orchestration.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""
    ## @param orchestration.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @extra orchestration.migration configuration for migration purposes for the orchestration cluster
  migration:
    data:
      ## @param orchestration.migration.data.enabled if true, the data migration occurs.
      enabled: false
      ## @param orchestration.migration.data.backoffLimit if true, can be used to specify the backoffLimit for the job https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
      backoffLimit: 6
      process:
        ## @param orchestration.migration.data.process.batchSize can be used to define the batch size.
        batchSize: 5
        ## @param orchestration.migration.data.process.importerFinishedTimeout can be used to define the timeout when the import is finished.
        importerFinishedTimeout: PT1M
        retry:
          ## @param orchestration.migration.data.process.retry.maxRetries can be used to define the maximum amount of retries.
          maxRetries: 5
          ## @param orchestration.migration.data.process.retry.maxRetryDelay can be used to define the delay time between retries.
          maxRetryDelay: PT1M
          ## @param orchestration.migration.data.process.retry.minRetryDelay can be used to define the delay time between retries.
          minRetryDelay: PT10s
          ## @param orchestration.migration.data.process.retry.retryDelayMultiplier can be used to define the delay multiplier.
          retryDelayMultiplier: 2.0
      metrics:
        ## @param orchestration.migration.data.metrics.batchSize can be used to define the batch size.
        batchSize: 5
        ## @param orchestration.migration.data.metrics.importerFinishedTimeout can be used to define the timeout when the import is finished.
        importerFinishedTimeout: PT1M
        retry:
          ## @param orchestration.migration.data.metrics.retry.maxRetries can be used to define the maximum amount of retries.
          maxRetries: 5
          ## @param orchestration.migration.data.metrics.retry.maxRetryDelay can be used to define the delay time between retries.
          maxRetryDelay: PT1M
          ## @param orchestration.migration.data.metrics.retry.minRetryDelay can be used to define the delay time between retries.
          minRetryDelay: PT10s
          ## @param orchestration.migration.data.metrics.retry.retryDelayMultiplier can be used to define the delay multiplier.
          retryDelayMultiplier: 2.0
      tumetrics:
        ## @param orchestration.migration.data.tumetrics.batchSize can be used to define the batch size.
        batchSize: 5
        ## @param orchestration.migration.data.tumetrics.importerFinishedTimeout can be used to define the timeout when the import is finished.
        importerFinishedTimeout: PT1M
        retry:
          ## @param orchestration.migration.data.tumetrics.retry.maxRetries can be used to define the maximum amount of retries.
          maxRetries: 5
          ## @param orchestration.migration.data.tumetrics.retry.maxRetryDelay can be used to define the delay time between retries.
          maxRetryDelay: PT1M
          ## @param orchestration.migration.data.tumetrics.retry.minRetryDelay can be used to define the delay time between retries.
          minRetryDelay: PT10s
          ## @param orchestration.migration.data.tumetrics.retry.retryDelayMultiplier can be used to define the delay multiplier.
          retryDelayMultiplier: 2.0
      tasks:
        ## @param orchestration.migration.data.tasks.batchSize can be used to define the batch size.
        batchSize: 5
        ## @param orchestration.migration.data.tasks.importerFinishedTimeout can be used to define the timeout when the import is finished.
        importerFinishedTimeout: PT1M
        ## @param orchestration.migration.data.tasks.legacyIndexRetentionAge defines when the legacy task index will be removed, defaults to orchestration.history.retention.minimumAge
        legacyIndexRetentionAge: 30d
        retry:
          ## @param orchestration.migration.data.tasks.retry.maxRetries can be used to define the maximum amount of retries.
          maxRetries: 5
          ## @param orchestration.migration.data.tasks.retry.maxRetryDelay can be used to define the delay time between retries.
          maxRetryDelay: PT1M
          ## @param orchestration.migration.data.tasks.retry.minRetryDelay can be used to define the delay time between retries.
          minRetryDelay: PT10s
          ## @param orchestration.migration.data.tasks.retry.retryDelayMultiplier can be used to define the delay multiplier.
          retryDelayMultiplier: 2.0
    identity:
      ## @param orchestration.migration.identity.enabled if true, the migration of Management Identity data to the orchestration clusters Identity occurs
      enabled: false

      waitContainer:
        ## @extra orchestration.migration.identity.waitContainer.image configuration to configure the image specifics
        image:
          ## @param orchestration.migration.identity.waitContainer.image.registry can be used to set container image registry.
          registry: ""
          ## @param orchestration.migration.identity.waitContainer.image.repository defines which image repository to use
          repository: curlimages/curl
          ## @param orchestration.migration.identity.waitContainer.image.tag can be set to overwrite the global tag, which should be used in that chart
          tag: 8.17.0
          ## @param orchestration.migration.identity.waitContainer.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
          digest: ""
      ## @param orchestration.migration.identity.backoffLimit can be used to specify the backoffLimit for the job https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
      backoffLimit: 6
      ## @param orchestration.migration.identity.resourceAuthorizationsEnabled if true, the migration of Management Identity data to the orchestration cluster will not create wildcard resource access for roles, this is required to be true if Resource Based Access was used with 8.7
      resourceAuthorizationsEnabled: false
      ## @param orchestration.migration.identity.claimName (OIDC setups only) defines the claim name in the Access Token to authorize the client by. This is required to grant the migration client the identity read permissions.
      claimName: "sub"
      ## @param orchestration.migration.identity.claimValue (OIDC setups only) defines the claim value in the set claimName that identifies the migration client. This is required to grant the migration client the identity read permissions.
      claimValue: ""
      ## @param orchestration.migration.identity.clientId must be the clientId used by the migration to access Management Identity. Only needed if external IdP is used (requires read permission).
      clientId: ""
      ## @extra orchestration.migration.identity.secret configuration to provide the identity migration client secret.
      secret:
        ## @param orchestration.migration.identity.secret.inlineSecret can be used to provide the client secret as a plain-text value for non-production usage.
        inlineSecret: ""
        ## @param orchestration.migration.identity.secret.existingSecret can be used to reference an existing Kubernetes Secret containing the client secret.
        existingSecret: ""
        ## @param orchestration.migration.identity.secret.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: ""
      ## @param orchestration.migration.identity.env can be used to set extra environment variables in the identity migration job container
      env: []
    ## @extra orchestration.migration.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    # The default defined PodAntiAffinity allows constraining on which nodes the pods are scheduled on https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    # It uses a hard requirement for scheduling and works based on the pod labels
    ## @skip orchestration.migration.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].weight
    ## @skip orchestration.migration.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].podAffinityTerm.labelSelector.matchExpressions[0].key
    ## @skip orchestration.migration.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].podAffinityTerm.labelSelector.matchExpressions[0].operator
    ## @skip orchestration.migration.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].podAffinityTerm.labelSelector.matchExpressions[0].values
    ## @skip orchestration.migration.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].podAffinityTerm.topologyKey
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                  - key: "app.kubernetes.io/component"
                    operator: In
                    # NOTE: The value is set to "zeebe-broker" for backward compatibility between 8.7 and 8.8.
                    values:
                      - zeebe-broker
              topologyKey: "kubernetes.io/hostname"

  ## @extra orchestration.importer configuration for the external tasklist and operate importer deployment for the orchestration cluster
  importer:
    ## @param orchestration.importer.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param orchestration.importer.extraVolumes can be used to define extra volumes for the importer pod
    extraVolumes: []
    ## @param orchestration.importer.extraVolumeMounts can be used to mount extra volumes for the importer pod
    extraVolumeMounts: []

  ## @param orchestration.sidecars can be used to attach extra containers to the deployment
  sidecars: []

  ## Multitenancy configuration
  ## @extra orchestration.multitenancy
  multitenancy:
    checks:
      ## @param orchestration.multitenancy.checks.enabled if true, then enable multitenancy checks in all applicable components.
      enabled: false
    api:
      ## @param orchestration.multitenancy.api.enabled if true, then enable multitenancy API used for tenant management.
      enabled: true

  ## @param orchestration.clusterSize defines the amount of brokers (=replicas), which are deployed via helm
  clusterSize: "3"
  ## @param orchestration.partitionCount defines how many partitions are set up in the cluster
  partitionCount: "3"
  ## @param orchestration.replicationFactor defines how each partition is replicated, the value defines the number of nodes
  replicationFactor: "3"
  ## @param orchestration.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
    # - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK
    #   value: TRACE
    # - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_SECURITY
    #   value: TRACE
  ## @param orchestration.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @extra orchestration.configMap configuration which will be applied to the mounted config map.
  configMap:
    ## @param orchestration.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. see https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0754
  ## @param orchestration.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []

  ## @param orchestration.logLevel defines the log level which is used
  logLevel: info
  ## @param orchestration.log4j2 can be used to overwrite the log4j2 configuration
  log4j2: ""
  ## @param orchestration.javaOpts can be used to set java options
  javaOpts: >-
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=/usr/local/camunda/data
    -XX:ErrorFile=/usr/local/camunda/data/camunda_error%p.log
    -XX:+ExitOnOutOfMemoryError

  ## @extra orchestration.service configuration for the Orchestration Cluster service
  service:
    ## @param orchestration.service.annotations can be used to define annotations, which will be applied to the service
    annotations: {}
    ## @extra orchestration.service configuration for the Orchestration Cluster headless service
    headless:
      ## @param orchestration.service.headless.annotations can be used to define annotations, which will be applied to the headless service
      annotations: {}
    ## @param orchestration.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param orchestration.service.loadBalancerIP defines public IP of the load balancer if the type is LoadBalancer
    loadBalancerIP: ""
    ## @param orchestration.service.loadBalancerSourceRanges defines list of allowed source IP address ranges if the type is LoadBalancer
    loadBalancerSourceRanges: []
    ## @param orchestration.service.httpName defines the name of the http endpoint, where for example metrics are provided
    httpName: "http"
    ## @param orchestration.service.httpPort defines the port of the http endpoint, where for example metrics are provided
    httpPort: 8080
    ## @param orchestration.service.managementName defines the name of the management endpoint, where the management API is exposed
    managementName: "server"
    ## @param orchestration.service.managementPort defines the port of the management endpoint, where the management API is exposed
    managementPort: 9600
    ## @param orchestration.service.grpcName defines the name of the gateway gRPC endpoint, where client commands (grpc) are sent to
    grpcName: "grpc"
    ## @param orchestration.service.grpcPort defines the port of the gateway gRPC endpoint, where client commands (grpc) are sent to
    grpcPort: 26500
    ## @param orchestration.service.commandName defines the name of the command API endpoint, where the broker commands are sent to
    commandName: "command"
    ## @param orchestration.service.commandPort defines the port of the command API endpoint, where the broker commands are sent to
    commandPort: 26501
    ## @param orchestration.service.internalName defines the name of the internal API endpoint, which is used for internal communication
    internalName: "internal"
    ## @param orchestration.service.internalPort defines the port of the internal API endpoint, which is used for internal communication
    internalPort: 26502

    ## @param orchestration.service.extraPorts can be used to expose any other ports which are required. Can be useful for exporters
    extraPorts: []
      # - name: hazelcast
      #   protocol: TCP
      #   port: 5701
      #   targetPort: 5701

  ## @extra orchestration.serviceAccount configuration for the service account where the broker pods are assigned to
  serviceAccount:
    ## @param orchestration.serviceAccount.enabled if true, enables the broker service account
    enabled: true
    ## @param orchestration.serviceAccount.name can be used to set the name of the broker service account
    name: ""
    ## @param orchestration.serviceAccount.annotations can be used to set the annotations of the broker service account
    annotations: {}
    ## @param orchestration.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ingress:
    grpc:
      ## @param orchestration.ingress.grpc.enabled if true, an ingress resource is deployed with the Zeebe gateway deployment. Only useful if an ingress controller is available, like nginx.
      enabled: false
      ## @param orchestration.ingress.grpc.external if true, the Ingress object will not be rendered. This setting is used when a non-Ingress resource, like a service mesh, is used to access the cluster.
      external: false
      ## @param orchestration.ingress.grpc.className defines the class or configuration of ingress which should be used by the controller
      className: nginx
      ## @param orchestration.ingress.grpc.labels [object] can be used to define labels which will be applied to the orchestration gRPC ingress resource
      labels: {}
      ## @param orchestration.ingress.grpc.annotations [object] defines the ingress related annotations, consumed mostly by the ingress controller
      ## @skip orchestration.ingress.grpc.annotations.ingress.kubernetes.io/rewrite-target
      ## @skip orchestration.ingress.grpc.annotations.nginx.ingress.kubernetes.io/ssl-redirect
      ## @skip orchestration.ingress.grpc.annotations.nginx.ingress.kubernetes.io/backend-protocol
      ## @skip orchestration.ingress.grpc.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
      annotations:
        ingress.kubernetes.io/rewrite-target: "/"
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
        nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
        nginx.ingress.kubernetes.io/proxy-buffer-size: "128k"
      ## @param orchestration.ingress.grpc.path defines the path which is associated with the Zeebe gateway's gRPC service and port https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      path: /
      ## @param orchestration.ingress.grpc.pathType can be used to define the Ingress path type. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
      pathType: Prefix
      ## @param orchestration.ingress.grpc.host can be used to define the host of the ingress rule. https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      # If not specified the rules applies to all inbound gRPC traffic, if specified the rule applies to that host.
      host: ""
      ## @extra orchestration.ingress.grpc.tls configuration for tls on the ingress resource https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
      tls:
        ## @param orchestration.ingress.grpc.tls.enabled if true, then tls is configured on the ingress resource. If enabled the Ingress.host need to be defined.
        enabled: false
        ## @param orchestration.ingress.grpc.tls.secretName defines the secret name which contains the TLS private key and certificate
        secretName: camunda-platform-orchestration-grpc

  # contextPath: "/orchestration"
  ## @param orchestration.contextPath can be used to make Orchestration Cluster web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param orchestration.cpuThreadCount defines how many threads can be used for the processing on each broker pod
  cpuThreadCount: "3"
  ## @param orchestration.ioThreadCount defines how many threads can be used for the exporting on each broker pod
  ioThreadCount: "3"
  ## @extra orchestration.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @extra orchestration.resources.requests
  ## @param orchestration.resources.requests.cpu
  ## @param orchestration.resources.requests.memory
  ## @param orchestration.resources.limits.cpu
  ## @param orchestration.resources.limits.memory
  resources:
    requests:
      cpu: 1000m
      memory: 1500Mi
    limits:
      cpu: 2000m
      memory: 3000Mi

  ## @param orchestration.persistenceType defines the type of persistence which is used by orchestration. Possible values are: disk, local and memory.
  #   disk  - means a persistence volume claim is configured and used
  #   local - means the data is stored into the container, no volumeMount nor volume nor claim is configured
  #   memory   - means it uses a tmpfs for the data persistence, be aware that this takes the limits into account
  persistenceType: disk
  ## @param orchestration.pvcSize defines the persistent volume claim size, which is used by each broker pod https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims
  pvcSize: "32Gi"
  ## @param orchestration.pvcAccessModes can be used to configure the persistent volume claim access mode https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  pvcAccessModes: ["ReadWriteOnce"]
  ## @param orchestration.pvcStorageClassName can be used to set the storage class name which should be used by the persistent volume claim.
  # It is recommended to use a storage class, which is backed with a SSD. Set to "-" to disable use of default storage class.
  pvcStorageClassName: ""
  ## @param orchestration.pvcAnnotations can be used to specify custom annotations for persistent volume claims, enhancing storage configuration flexibility.
  pvcAnnotations: {}
  ## @param orchestration.pvcSelector can be used to specify a label selector for persistent volume claims for further filtering of the set of persistent volumes to select.
  # https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector
  pvcSelector: {}
  ## @extra orchestration.data configuration to configure the data handling of the Zeebe broker pods
  data:
    ## @param orchestration.data.snapshotPeriod defines the period, after which a snapshot is created https://docs.camunda.io/docs/self-managed/zeebe-deployment/configuration/broker-config/#zeebebrokerdata
    snapshotPeriod: "5m"
    ## @extra orchestration.data.disk configuration to configure the disk storage of the Zeebe broker pods
    disk:
      ## @extra orchestration.data.disk.freeSpace configuration to configure the free space handling of the Zeebe broker pods
      freeSpace:
        ## @param orchestration.data.disk.freeSpace.processing the minimum free space which should be available on the disk, before the broker stops processing commands https://docs.camunda.io/docs/self-managed/zeebe-deployment/configuration/broker-config/#zeebebrokerdatadiskfreespace
        processing: "2GB"
        ## @param orchestration.data.disk.freeSpace.replication the minimum free space which should be available on the disk, before the broker stops receicing replicated events https://docs.camunda.io/docs/self-managed/zeebe-deployment/configuration/broker-config/#zeebebrokerdatadiskfreespace
        replication: "1GB"
  ## @param orchestration.extraVolumes can be used to define extra volumes for the broker pods, useful for additional exporters
  extraVolumes: []
  ## @param orchestration.extraVolumeMounts can be used to mount extra volumes for the broker pods, useful for additional exporters
  extraVolumeMounts: []
  ## @param orchestration.extraInitContainers (DEPRECATED - use `initContainers` instead) can be used to set up extra init containers for the broker pods, useful for additional exporters
  extraInitContainers: []
  ## @param orchestration.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []

  ## @param orchestration.podAnnotations can be used to define extra broker pod annotations
  podAnnotations: {}
  ## @param orchestration.podLabels can be used to define extra broker pod labels
  podLabels: {}
  ## @extra orchestration.podDisruptionBudget configuration to configure a pod disruption budget for the broker pods https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    ## @param orchestration.podDisruptionBudget.enabled if true a pod disruption budget is defined for the brokers
    enabled: false
    ## @param orchestration.podDisruptionBudget.minAvailable can be used to set how many pods should be available. Be aware that if minAvailable is set, maxUnavailable will not be set (they are mutually exclusive).
    minAvailable: 0
    ## @param orchestration.podDisruptionBudget.maxUnavailable can be used to set how many pods should be at max. unavailable
    maxUnavailable: 1

  ## @extra orchestration.podSecurityContext defines the security options the pod should be run with
  podSecurityContext:
    ## @param orchestration.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param orchestration.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra orchestration.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param orchestration.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra orchestration.containerSecurityContext defines the security options the container should be run with
  containerSecurityContext:
    ## @param orchestration.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param orchestration.containerSecurityContext.privileged
    privileged: false
    ## @param orchestration.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param orchestration.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param orchestration.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra orchestration.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param orchestration.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra orchestration.startupProbe configuration
  startupProbe:
    ## @param orchestration.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param orchestration.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param orchestration.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health/startup
    ## @param orchestration.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param orchestration.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param orchestration.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param orchestration.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param orchestration.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra orchestration.readinessProbe configuration
  readinessProbe:
    ## @param orchestration.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param orchestration.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param orchestration.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health/readiness
    ## @param orchestration.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param orchestration.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param orchestration.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param orchestration.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param orchestration.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra orchestration.livenessProbe configuration
  livenessProbe:
    ## @param orchestration.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param orchestration.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param orchestration.livenessProbe.probePath defines the liveness probe route used on the app. The path is intended to be the same as the readinessProbe. Refer to this issue for more details: https://github.com/camunda/camunda-platform-helm/issues/1849
    probePath: /actuator/health/readiness
    ## @param orchestration.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param orchestration.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param orchestration.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param orchestration.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param orchestration.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param orchestration.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @param orchestration.nodeSelector can be used to define on which nodes the broker pods should run
  nodeSelector: {}
  ## @param orchestration.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @extra orchestration.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  # The default defined PodAntiAffinity allows constraining on which nodes the pods are scheduled on https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  # It uses a hard requirement for scheduling and works based on the pod labels
  ## @skip orchestration.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].key
  ## @skip orchestration.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].operator
  ## @skip orchestration.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].values
  ## @skip orchestration.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].topologyKey
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: "app.kubernetes.io/component"
                operator: In
                # NOTE: The value is set to "zeebe-broker" for backward compatibility between 8.7 and 8.8.
                values:
                  - zeebe-broker
          topologyKey: "kubernetes.io/hostname"

  ## @param orchestration.priorityClassName can be used to define the broker pods priority https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  ## @extra orchestration.exporters allows disabling inbuilt exporters.
  exporters:
    ## @param orchestration.exporters.camunda.enabled if true, enables the new Camunda exporter.
    camunda:
      enabled: true
    ## @param orchestration.exporters.zeebe.enabled if true, enables the legacy Zeebe Elasticsearch and OpenSearch exporters.
    zeebe:
      enabled: false

  index:
    ## @param orchestration.index.prefix if specified, defines an index prefix in Elasticsearch/OpenSearch for the new exporter and Orchestration Cluster. For old exporter or Optimize use the "global.elasticsearch.prefix" or OpenSearch equivalent.
    prefix: ""
    ## @param orchestration.index.replicas can be used to specify the number of replicas for indices in Elasticsearch/OpenSearch
    replicas: 1

  ## @extra orchestration.retention configuration to enable ILM Policy creation and application for Zeebe record (legacy Elasticsearch/Opensearch exporter) indices; controls their retention.
  retention:
    ## @param orchestration.retention.enabled if true, the ILM Policy is created and applied to the index templates.
    enabled: false
    ## @param orchestration.retention.minimumAge defines how old the data must be, before the data is deleted as a duration.
    minimumAge: 30d
    ## @param orchestration.retention.policyName defines the name of the created and applied ILM policy.
    policyName: zeebe-record-retention-policy

  ## @extra orchestration.history configuration for Camunda harmonized historical indices.
  history:
    ## @param orchestration.history.elsRolloverDateFormat defines the date format of historical indices in a Java DateTimeFormatter compliant syntax.
    elsRolloverDateFormat: date
    ## @param orchestration.history.rolloverInterval defines the time range of the historical indices to be created.
    rolloverInterval: 1d
    ## @param orchestration.history.rolloverBatchSize defines the maximum number of process instances per batch during archiving.
    rolloverBatchSize: 100
    ## @param orchestration.history.waitPeriodBeforeArchiving defines the grace period for processes to be excluded from archiving for a value of 1h, any processes completed in
    ## the last hour will not be collected into historical indices.
    waitPeriodBeforeArchiving: 1h
    ## @param orchestration.history.delayBetweenRuns the millisecond interval between archiver runs
    delayBetweenRuns: 2000
    ## @param orchestration.history.maxDelayBetweenRuns the maximum millisecond interval between archiver runs due to failure backoffs
    maxDelayBetweenRuns: 60000
    ## @extra orchestration.history.retention configuration for retention of the Camunda harmonized historical indices.
    retention:
      ## @param orchestration.history.retention.enabled if true, applies ILM Policy to the archived orchestration indices (operate, tasklist, camunda).
      enabled: false
      ## @param orchestration.history.retention.minimumAge defines how old the data must be, before the data is deleted as a duration.
      minimumAge: 30d
      ## @param orchestration.history.retention.policyName defines the name of the created and applied ILM policy.
      # NOTE: The value is set to "zeebe-record-retention-policy" for backward compatibility between 8.7 and 8.8.
      policyName: camunda-history-retention-policy
      ## @param orchestration.history.retention.usageMetricsMinimumAge defines how old the usage metric indices must be before deletion (camunda-usage-metric, camunda-usage-metric-tu).
      usageMetricsMinimumAge: 730d
      ## @param orchestration.history.retention.usageMetricsPolicyName defines the name of the created and applied ILM policy to usage metric indices.
      usageMetricsPolicyName: camunda-usage-metrics-retention-policy

  ## @param orchestration.configuration if specified, contents will be used as the application.yaml
  configuration: ""
  ## @param orchestration.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
  extraConfiguration: {}
  ## @param orchestration.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param orchestration.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

  ## @param orchestration.extraVolumeClaimTemplates can be used to specify an array of extra PersistentVolumeClaim templates to be appended to the StatefulSet's volumeClaimTemplates. WARNING: volumeClaimTemplates is immutable after creation; changing this requires manual intervention (such as deleting the StatefulSet and its PVCs). Use with caution!
  extraVolumeClaimTemplates: []

  ## @exra orchestration.upgrade is a structure that holds upgrade specific configurations
  upgrade:
    ## @param orchestration.upgrade.allowPreReleaseImages if true, allows the use of pre-release images for the orchestration cluster. Prerelease images are, by their nature, unstable and should be used with caution. This flag should only be used for testing purposes.
    allowPreReleaseImages: false

#############################################
 #####
#     # #####  ##### # #    # # ###### ######
#     # #    #   #   # ##  ## #     #  #
#     # #    #   #   # # ## # #    #   #####
#     # #####    #   # #    # #   #    #
#     # #        #   # #    # #  #     #
 #####  #        #   # #    # # ###### ######
#############################################
## @section Optimize Parameters
# Optimize configuration for the Optimize sub chart.
optimize:
  ## @param optimize.enabled if true, the Optimize deployment and its related resources are deployed via a helm release
  enabled: false

  ## @extra optimize.image configuration to configure the Optimize image specifics
  # https://hub.docker.com/r/camunda/optimize/tags
  image:
    ## @param optimize.image.registry can be used to set container image registry
    registry: ""
    ## @param optimize.image.repository defines which image repository to use
    repository: camunda/optimize
    ## @param optimize.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.3
    ## @param optimize.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""
    ## @param optimize.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @extra optimize.migration configuration for Optimize migration
  migration:
    ## @param optimize.migration.enabled if true, run Optimize migration script as an init container
    enabled: true
    ## @param optimize.migration.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details. (Note: there is no need to define this if optimize.env is defined)
    env: []

    ## @extra optimize.migration.resources configuration to set request and limit configuration for the migration container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param optimize.migration.resources.requests.cpu
    ## @param optimize.migration.resources.requests.memory
    ## @param optimize.migration.resources.limits.cpu
    ## @param optimize.migration.resources.limits.memory
    resources:
      requests:
        cpu: 600m
        memory: 1Gi
      limits:
        cpu: 2000m
        memory: 2Gi

  ## @param optimize.sidecars can be used to attach extra containers to the optimize deployment
  sidecars: []

  # contextPath: "/optimize"
  ## @param optimize.contextPath can be used to make Optimize web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @extra optimize.configMap configuration which will be applied to the mounted config map.
  configMap:
    ## @param optimize.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    # See https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0754

  ## @param optimize.podAnnotations can be used to define extra Optimize pod annotations
  podAnnotations: {}
  ## @param optimize.podLabels can be used to define extra Optimize pod labels
  podLabels: {}

  ## @param optimize.logLevel configuration for the optimize runtime environment. https://docs.camunda.io/optimize/next/self-managed/optimize-deployment/configuration/logging/
  logLevel: info
  ## @param optimize.upgradeLogLevel sets the logging level for the Optimize update log. https://docs.camunda.io/optimize/next/self-managed/optimize-deployment/configuration/logging/
  upgradeLogLevel: info
  ## @param optimize.esLogLevel sets the logging level for Elasticsearch. https://docs.camunda.io/optimize/next/self-managed/optimize-deployment/configuration/logging/
  esLogLevel: warn

  ## @param optimize.partitionCount defines how many Zeebe partitions are set up in the cluster and which should be imported by Optimize
  partitionCount: "3"
  ## @param optimize.env can be used to set extra environment variables in the app container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
  ## @param optimize.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param optimize.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param optimize.extraVolumes can be used to define extra volumes for the Optimize pods, useful for tls and self-signed certificates
  extraVolumes: []
  ## @param optimize.extraVolumeMounts can be used to mount extra volumes for the Optimize pods, useful for tls and self-signed certificates
  extraVolumeMounts: []
  ## @param optimize.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []
  ## @extra optimize.serviceAccount configuration for the service account where the Optimize pods are assigned to
  serviceAccount:
    ## @param optimize.serviceAccount.enabled if true, enables the Optimize service account
    enabled: true
    ## @param optimize.serviceAccount.name can be used to set the name of the Optimize service account
    name: ""
    ## @param optimize.serviceAccount.annotations can be used to set the annotations of the Optimize service account
    annotations: {}
    ## @param optimize.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra optimize.service configuration to configure the Optimize service.
  service:
    ## @param optimize.service.annotations can be used to define annotations, which will be applied to the Optimize service
    annotations: {}
    ## @param optimize.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param optimize.service.port defines the port of the service, where the Optimize web application will be available
    port: 80
    ## @param optimize.service.managementPort defines the port where actuator will be available. Also required to reach backup API
    managementPort: 8092

  ## @extra optimize.podSecurityContext defines the security options the Optimize pod should be run with
  podSecurityContext:
    ## @param optimize.podSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param optimize.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra optimize.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param optimize.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra optimize.containerSecurityContext defines the security options the Optimize container should be run with
  containerSecurityContext:
    ## @param optimize.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param optimize.containerSecurityContext.privileged
    privileged: false
    ## @param optimize.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param optimize.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param optimize.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra optimize.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param optimize.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra optimize.startupProbe configuration
  startupProbe:
    ## @param optimize.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param optimize.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param optimize.startupProbe.probePath defines the startup probe route used on the app
    probePath: /api/readyz
    ## @param optimize.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param optimize.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param optimize.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param optimize.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param optimize.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra optimize.readinessProbe configuration
  readinessProbe:
    ## @param optimize.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param optimize.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param optimize.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /api/readyz
    ## @param optimize.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param optimize.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param optimize.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param optimize.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param optimize.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra optimize.livenessProbe configuration
  livenessProbe:
    ## @param optimize.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param optimize.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param optimize.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /api/readyz
    ## @param optimize.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param optimize.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param optimize.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param optimize.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param optimize.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param optimize.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @param optimize.nodeSelector can be used to define on which nodes the Optimize pods should run
  nodeSelector: {}
  ## @param optimize.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param optimize.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## @extra optimize.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param optimize.resources.requests.cpu
  ## @param optimize.resources.requests.memory
  ## @param optimize.resources.limits.cpu
  ## @param optimize.resources.limits.memory
  resources:
    requests:
      cpu: 600m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param optimize.configuration if specified, contents will be used as the environment-config.yaml
  configuration: ""
  ## @param optimize.extraConfiguration if specified, contents will be used for any extra configuration files such as environment-logback.xml
  extraConfiguration: {}
  ## @param optimize.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param optimize.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

  ## @extra optimize.persistence configuration for optional PVC creation
  persistence:
    ## @param optimize.persistence.enabled can be used to create a PVC for persistent storage instead of using emptyDir
    enabled: false
    ## @param optimize.persistence.size can be used to define the size of the persistent volume claim
    size: "10Gi"
    ## @param optimize.persistence.accessModes can be used to define the access modes for the persistent volume claim
    accessModes: ["ReadWriteOnce"]
    ## @param optimize.persistence.storageClassName can be used to define the storage class to use for the persistent volume claim
    # Set to "-" to disable use of default storage class
    storageClassName: ""
    ## @param optimize.persistence.existingClaim can be used to specify an existing PVC instead of creating a new one
    existingClaim: ""
    ## @param optimize.persistence.annotations can be used to define annotations to add to the persistent volume claim
    annotations: {}
    ## @param optimize.persistence.selector can be used to define a label selector for the persistent volume claim
    selector: {}

#####################################################################################
#######
#       #        ##    ####  ##### #  ####   ####  ######   ##   #####   ####  #    #
#       #       #  #  #        #   # #    # #      #       #  #  #    # #    # #    #
#####   #      #    #  ####    #   # #       ####  #####  #    # #    # #      ######
#       #      ######      #   #   # #           # #      ###### #####  #      #    #
#       #      #    # #    #   #   # #    # #    # #      #    # #   #  #    # #    #
####### ###### #    #  ####    #   #  ####   ####  ###### #    # #    #  ####  #    #
#####################################################################################

## @section Elasticsearch Parameters

## @extra elasticsearch
elasticsearch:
  ## @param elasticsearch.enabled
  enabled: true
  ## @extra elasticsearch.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param elasticsearch.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: '{{ .Values.global.compatibility.openshift.adaptSecurityContext | default "disabled" }}'
  # https://hub.docker.com/r/bitnami/elasticsearch/tags
  image:
    ## @param elasticsearch.image.repository
    repository: bitnamilegacy/elasticsearch
    ## @param elasticsearch.image.tag
    tag: 8.18.0
    ## @param elasticsearch.image.digest can be used to set image digest (overrides tag if set, e.g. "sha256:abcd...")
    digest: ""
  ## @skip elasticsearch.extraConfig Append extra configuration to the elasticsearch node configuration
  extraConfig:
    # Disable deprecation warnings - https://github.com/camunda/camunda/issues/26285
    logger.org.elasticsearch.deprecation: "OFF"
  master:
    ## @param elasticsearch.master.replicaCount defines number of master-elegible replicas to deploy
    replicaCount: 3
    ## @param elasticsearch.master.podAntiAffinityPreset defines Pod anti-affinity preset. Ignored if master.affinity is set
    podAntiAffinityPreset: hard
    containerSecurityContext:
      ## @param elasticsearch.master.containerSecurityContext.readOnlyRootFilesystem
      readOnlyRootFilesystem: true
    ## @param elasticsearch.master.masterOnly
    masterOnly: false
    ## @param elasticsearch.master.heapSize
    heapSize: 1024m
    persistence:
      ## @param elasticsearch.master.persistence.size
      size: 64Gi
    ## @skip elasticsearch.master.resources.requests.cpu cpu request
    ## @param elasticsearch.master.resources.requests.memory request
    ## @skip elasticsearch.master.resources.limits.cpu cpu limit
    ## @param elasticsearch.master.resources.limits.memory memory limit
    ## TODO: remove the skip tag on the cpu keys and add [number, string] modifiers when this issue is resolved: https://github.com/bitnami/readme-generator-for-helm/issues/173
    resources:
      requests:
        cpu: 1000m
        memory: 2Gi
      limits:
        cpu: 2000m
        memory: 2Gi
    extraEnvVars:
      ## @param elasticsearch.master.extraEnvVars[0].name env
      - name: ELASTICSEARCH_ENABLE_REST_TLS
        ## @param elasticsearch.master.extraEnvVars[0].value env value
        value: "false"
  sysctlImage:
    ## @param elasticsearch.sysctlImage.enabled
    enabled: true
    ## @param elasticsearch.sysctlImage.repository
    repository: bitnamilegacy/os-shell
  data:
    ## @param elasticsearch.data.replicaCount
    replicaCount: 0
  coordinating:
    ## @param elasticsearch.coordinating.replicaCount
    replicaCount: 0
  ingest:
    ## @param elasticsearch.ingest.enabled
    enabled: false
  metrics:
    image:
      ## @param elasticsearch.metrics.image.repository
      repository: bitnamilegacy/elasticsearch-exporter
  volumePermissions:
    image:
      ## @param elasticsearch.volumePermissions.image.repository
      repository: bitnamilegacy/os-shell
  copyTlsCerts:
    image:
      ## @param elasticsearch.copyTlsCerts.image.repository
      repository: bitnamilegacy/os-shell

#####################################################################
######
#     # #####   ####  #    # ###### ##### #    # ###### #    #  ####
#     # #    # #    # ##  ## #        #   #    # #      #    # #
######  #    # #    # # ## # #####    #   ###### #####  #    #  ####
#       #####  #    # #    # #        #   #    # #      #    #      #
#       #   #  #    # #    # #        #   #    # #      #    # #    #
#       #    #  ####  #    # ######   #   #    # ######  ####   ####
#####################################################################

## @section Prometheus Parameters

## @extra PrometheusServiceMonitor configuration to configure a prometheus service monitor
prometheusServiceMonitor:
  ## @param prometheusServiceMonitor.enabled if true then a service monitor will be deployed, which allows an installed prometheus controller to scrape metrics from the deployed pods
  enabled: false
  ## @extra promotheuServiceMonitor.labels can be set to configure extra labels, which will be added to the servicemonitor and can be used on the prometheus controller for selecting the servicemonitors
  labels:
    ## @param prometheusServiceMonitor.labels.release
    release: metrics
  ## @param prometheusServiceMonitor.scrapeInterval can be set to configure the interval at which metrics should be scraped
  # Should be *less* than 60s if the provided grafana dashboard is used, which can be found here https://github.com/camunda/camunda/tree/main/monitor/grafana,
  # otherwise it isn't able to show any metrics which is aggregated over 1 min.
  scrapeInterval: 10s
