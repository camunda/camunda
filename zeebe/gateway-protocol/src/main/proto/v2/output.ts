/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/authentication/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current user
         * @description Retrieves the current authenticated user.
         */
        get: operations["getAuthentication"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/authorizations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create authorization
         * @description Create the authorization.
         */
        post: operations["createAuthorization"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/authorizations/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search authorizations
         * @description Search for authorizations based on given criteria.
         */
        post: operations["searchAuthorizations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/authorizations/{authorizationKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get authorization
         * @description Get authorization by the given key.
         */
        get: operations["getAuthorization"];
        /**
         * Update authorization
         * @description Update the authorization with the given key.
         */
        put: operations["updateAuthorization"];
        post?: never;
        /**
         * Delete authorization
         * @description Deletes the authorization with the given key.
         */
        delete: operations["deleteAuthorization"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch-operation-items/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search batch operation items
         * @description Search for batch operation items based on given criteria.
         */
        post: operations["searchBatchOperationItems"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch-operations/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search batch operations
         * @description Search for batch operations based on given criteria.
         */
        post: operations["searchBatchOperations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch-operations/{batchOperationKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get batch operation
         * @description Get batch operation by key.
         */
        get: operations["getBatchOperation"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch-operations/{batchOperationKey}/cancellation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel Batch operation
         * @description Cancels a running batch operation.
         *     This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["cancelBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch-operations/{batchOperationKey}/resumption": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resume Batch operation
         * @description Resumes a suspended batch operation.
         *     This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["resumeBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch-operations/{batchOperationKey}/suspension": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Suspend Batch operation
         * @description Suspends a running batch operation.
         *     This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["suspendBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/clock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Pin internal clock (alpha)
         * @description Set a precise, static time for the Zeebe engine's internal clock.
         *     When the clock is pinned, it remains at the specified time and does not advance.
         *     To change the time, the clock must be pinned again with a new timestamp.
         *
         *     This endpoint is an alpha feature and may be subject to change
         *     in future releases.
         */
        put: operations["pinClock"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/clock/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset internal clock (alpha)
         * @description Resets the Zeebe engine's internal clock to the current system time, enabling it to tick in real-time.
         *     This operation is useful for returning the clock to
         *     normal behavior after it has been pinned to a specific time.
         *
         *     This endpoint is an alpha feature and may be subject to change
         *     in future releases.
         */
        post: operations["resetClock"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/correlated-message-subscriptions/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search correlated message subscriptions
         * @description Search correlated message subscriptions based on given criteria.
         */
        post: operations["searchCorrelatedMessageSubscriptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-definitions/evaluation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Evaluate decision
         * @description Evaluates a decision.
         *     You specify the decision to evaluate either by using its unique key (as returned by
         *     DeployResource), or using the decision ID. When using the decision ID, the latest deployed
         *     version of the decision is used.
         */
        post: operations["evaluateDecision"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-definitions/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search decision definitions
         * @description Search for decision definitions based on given criteria.
         */
        post: operations["searchDecisionDefinitions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-definitions/{decisionDefinitionKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get decision definition
         * @description Returns a decision definition by key.
         */
        get: operations["getDecisionDefinition"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-definitions/{decisionDefinitionKey}/xml": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get decision definition XML
         * @description Returns decision definition as XML.
         */
        get: operations["getDecisionDefinitionXML"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-instances/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search decision instances
         * @description Search for decision instances based on given criteria.
         */
        post: operations["searchDecisionInstances"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-instances/{decisionEvaluationInstanceKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get decision instance
         * @description Returns a decision instance.
         */
        get: operations["getDecisionInstance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-requirements/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search decision requirements
         * @description Search for decision requirements based on given criteria.
         */
        post: operations["searchDecisionRequirements"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-requirements/{decisionRequirementsKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get decision requirements
         * @description Returns Decision Requirements as JSON.
         */
        get: operations["getDecisionRequirements"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decision-requirements/{decisionRequirementsKey}/xml": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get decision requirements XML
         * @description Returns decision requirements as XML.
         */
        get: operations["getDecisionRequirementsXML"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/deployments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy resources
         * @description Deploys one or more resources (e.g. processes, decision models, or forms).
         *     This is an atomic call, i.e. either all resources are deployed or none of them are.
         */
        post: operations["createDeployment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload document
         * @description Upload a document to the Camunda 8 cluster.
         *
         *     Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
         */
        post: operations["createDocument"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload multiple documents
         * @description Upload multiple documents to the Camunda 8 cluster.
         *
         *     The caller must provide a file name for each document, which will be used in case of a multi-status response
         *     to identify which documents failed to upload. The file name can be provided in the `Content-Disposition` header
         *     of the file part or in the `fileName` field of the metadata. You can add a parallel array of metadata objects. These
         *     are matched with the files based on index, and must have the same length as the files array.
         *     To pass homogenous metadata for all files, spread the metadata over the metadata array.
         *     A filename value provided explicitly via the metadata array in the request overrides the `Content-Disposition` header
         *     of the file part.
         *
         *     In case of a multi-status response, the response body will contain a list of `DocumentBatchProblemDetail` objects,
         *     each of which contains the file name of the document that failed to upload and the reason for the failure.
         *     The client can choose to retry the whole batch or individual documents based on the response.
         *
         *     Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
         */
        post: operations["createDocuments"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/{documentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download document
         * @description Download a document from the Camunda 8 cluster.
         *
         *     Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
         */
        get: operations["getDocument"];
        put?: never;
        post?: never;
        /**
         * Delete document
         * @description Delete a document from the Camunda 8 cluster.
         *
         *     Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
         */
        delete: operations["deleteDocument"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/{documentId}/links": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create document link
         * @description Create a link to a document in the Camunda 8 cluster.
         *
         *     Note that this is currently supported for document stores of type: AWS, GCP
         */
        post: operations["createDocumentLink"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/element-instances/ad-hoc-activities/{adHocSubProcessInstanceKey}/activation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Activate activities within an ad-hoc sub-process
         * @description Activates selected activities within an ad-hoc sub-process identified by element ID.
         *     The provided element IDs must exist within the ad-hoc sub-process instance identified by the
         *     provided adHocSubProcessInstanceKey.
         */
        post: operations["activateAdHocSubProcessActivities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/element-instances/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search element instances
         * @description Search for element instances based on given criteria.
         */
        post: operations["searchElementInstances"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/element-instances/{elementInstanceKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get element instance
         * @description Returns element instance as JSON.
         */
        get: operations["getElementInstance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/element-instances/{elementInstanceKey}/incidents/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search for incidents of a specific element instance
         * @description Search for incidents caused by the specified element instance, including incidents of any child instances created from this element instance.
         *
         *     Although the `elementInstanceKey` is provided as a path parameter to indicate the root element instance,
         *     you may also include an `elementInstanceKey` within the filter object to narrow results to specific
         *     child element instances. This is useful, for example, if you want to isolate incidents associated with
         *     nested or subordinate elements within the given element instance while excluding incidents directly tied
         *     to the root element itself.
         */
        post: operations["searchElementInstanceIncidents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/element-instances/{elementInstanceKey}/variables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update element instance variables
         * @description Updates all the variables of a particular scope (for example, process instance, element instance) with the given variable data.
         *     Specify the element instance in the `elementInstanceKey` parameter.
         */
        put: operations["createElementInstanceVariables"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create group
         * @description Create a new group.
         */
        post: operations["createGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search groups
         * @description Search for groups based on given criteria.
         */
        post: operations["searchGroups"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get group
         * @description Get a group by its ID.
         */
        get: operations["getGroup"];
        /**
         * Update group
         * @description Update a group with the given ID.
         */
        put: operations["updateGroup"];
        post?: never;
        /**
         * Delete group
         * @description Deletes the group with the given ID.
         */
        delete: operations["deleteGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/clients/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search group clients
         * @description Search clients assigned to a group.
         */
        post: operations["searchClientsForGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/clients/{clientId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a client to a group
         * @description Assigns a client to a group, making it a member of the group.
         *     Members of the group inherit the group authorizations, roles, and tenant assignments.
         */
        put: operations["assignClientToGroup"];
        post?: never;
        /**
         * Unassign a client from a group
         * @description Unassigns a client from a group.
         *     The client is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
         */
        delete: operations["unassignClientFromGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/mapping-rules/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search group mapping rules
         * @description Search mapping rules assigned to a group.
         */
        post: operations["searchMappingRulesForGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/mapping-rules/{mappingRuleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a mapping rule to a group
         * @description Assigns a mapping rule to a group.
         */
        put: operations["assignMappingRuleToGroup"];
        post?: never;
        /**
         * Unassign a mapping rule from a group
         * @description Unassigns a mapping rule from a group.
         */
        delete: operations["unassignMappingRuleFromGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/roles/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search group roles
         * @description Search roles assigned to a group.
         */
        post: operations["searchRolesForGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/users/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search group users
         * @description Search users assigned to a group.
         */
        post: operations["searchUsersForGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a user to a group
         * @description Assigns a user to a group, making the user a member of the group.
         *     Group members inherit the group authorizations, roles, and tenant assignments.
         */
        put: operations["assignUserToGroup"];
        post?: never;
        /**
         * Unassign a user from a group
         * @description Unassigns a user from a group.
         *     The user is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
         */
        delete: operations["unassignUserFromGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search incidents
         * @description Search for incidents based on given criteria.
         */
        post: operations["searchIncidents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{incidentKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get incident
         * @description Returns incident as JSON.
         */
        get: operations["getIncident"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{incidentKey}/resolution": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resolve incident
         * @description Marks the incident as resolved; most likely a call to Update job will be necessary
         *     to reset the job's retries, followed by this call.
         */
        post: operations["resolveIncident"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/activation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Activate jobs
         * @description Iterate through all known partitions and activate jobs up to the requested maximum.
         */
        post: operations["activateJobs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search jobs
         * @description Search for jobs based on given criteria.
         */
        post: operations["searchJobs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update job
         * @description Update a job with the given key.
         */
        patch: operations["updateJob"];
        trace?: never;
    };
    "/jobs/{jobKey}/completion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete job
         * @description Complete a job with the given payload, which allows completing the associated service task.
         */
        post: operations["completeJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobKey}/error": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Throw error for job
         * @description Reports a business error (i.e. non-technical) that occurs while processing a job.
         */
        post: operations["throwJobError"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{jobKey}/failure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Fail job
         * @description Mark the job as failed.
         */
        post: operations["failJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/license": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get license status
         * @description Obtains the status of the current Camunda license.
         */
        get: operations["getLicense"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/mapping-rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create mapping rule
         * @description Create a new mapping rule
         */
        post: operations["createMappingRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/mapping-rules/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search mapping rules
         * @description Search for mapping rules based on given criteria.
         */
        post: operations["searchMappingRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/mapping-rules/{mappingRuleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a mapping rule
         * @description Gets the mapping rule with the given ID.
         */
        get: operations["getMappingRule"];
        /**
         * Update mapping rule
         * @description Update a mapping rule.
         */
        put: operations["updateMappingRule"];
        post?: never;
        /**
         * Delete a mapping rule
         * @description Deletes the mapping rule with the given ID.
         */
        delete: operations["deleteMappingRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/message-subscriptions/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search message subscriptions
         * @description Search for message subscriptions based on given criteria.
         */
        post: operations["searchMessageSubscriptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/correlation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Correlate message
         * @description Publishes a message and correlates it to a subscription.
         *     If correlation is successful it will return the first process instance key the message correlated with.
         *     The message is not buffered.
         *     Use the publish message endpoint to send messages that can be buffered.
         */
        post: operations["correlateMessage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/publication": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Publish message
         * @description Publishes a single message.
         *     Messages are published to specific partitions computed from their correlation keys.
         *     Messages can be buffered.
         *     The endpoint does not wait for a correlation result.
         *     Use the message correlation endpoint for such use cases.
         */
        post: operations["publishMessage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search process definitions
         * @description Search for process definitions based on given criteria.
         */
        post: operations["searchProcessDefinitions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/statistics/process-instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get process instance statistics
         * @description Get statistics about process instances, grouped by process definition.
         */
        post: operations["getProcessDefinitionInstanceStatistics"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/{processDefinitionKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get process definition
         * @description Returns process definition as JSON.
         */
        get: operations["getProcessDefinition"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/{processDefinitionKey}/form": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get process start form
         * @description Get the start form of a process.
         *     Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
         */
        get: operations["getStartProcessForm"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/{processDefinitionKey}/statistics/element-instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get process definition statistics
         * @description Get statistics about elements in currently running process instances by process definition key and search filter.
         */
        post: operations["getProcessDefinitionStatistics"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/{processDefinitionKey}/xml": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get process definition XML
         * @description Returns process definition as XML.
         */
        get: operations["getProcessDefinitionXML"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-definitions/{processDefinitionId}/statistics/process-instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get process instance statistics by version
         * @description Get statistics about process instances, grouped by version for a given process definition.
         */
        post: operations["getProcessDefinitionInstanceVersionStatistics"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create process instance
         * @description Creates and starts an instance of the specified process.
         *     The process definition to use to create the instance can be specified either using its unique key
         *     (as returned by Deploy resources), or using the BPMN process ID and a version.
         *
         *     Waits for the completion of the process instance before returning a result
         *     when awaitCompletion is enabled.
         */
        post: operations["createProcessInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/cancellation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a batch operation to cancel process instances
         * @description Cancels multiple running process instances.
         *     Since only ACTIVE root instances can be cancelled, any given filters for state and
         *     parentProcessInstanceKey are ignored and overridden during this batch operation.
         *     This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["cancelProcessInstancesBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/incident-resolution": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a batch operation to resolve incidents of process instances
         * @description Resolves multiple instances of process instances.
         *     Since only process instances with ACTIVE state can have unresolved incidents, any given
         *     filters for state are ignored and overridden during this batch operation.
         *     This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["resolveIncidentsBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/migration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a batch operation to migrate process instances
         * @description Migrate multiple instances of process instances.
         *     Since only process instances with ACTIVE state can be migrated, any given
         *     filters for state are ignored and overridden during this batch operation.
         *     This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["migrateProcessInstancesBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/modification": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a batch operation to modify process instances
         * @description Modify multiple process instances.
         *     Since only process instances with ACTIVE state can be modified, any given
         *     filters for state are ignored and overridden during this batch operation.
         *     In contrast to single modification operation, it is not possible to add variable instructions or modify by element key.
         *     It is only possible to use the element id of the source and target.
         *     This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
         */
        post: operations["modifyProcessInstancesBatchOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search process instances
         * @description Search for process instances based on given criteria.
         */
        post: operations["searchProcessInstances"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get process instance
         * @description Get the process instance by the process instance key.
         */
        get: operations["getProcessInstance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/call-hierarchy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get call hierarchy for process instance
         * @description Returns the call hierarchy for a given process instance, showing its ancestry up to the root instance.
         */
        get: operations["getProcessInstanceCallHierarchy"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/cancellation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel process instance
         * @description Cancels a running process instance. As a cancellation includes more than just the removal of the process instance resource, the cancellation resource must be posted.
         */
        post: operations["cancelProcessInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/incident-resolution": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resolve process instance incidents
         * @description Creates a batch operation to resolve multiple incidents of a process instance.
         */
        post: operations["resolveProcessInstanceIncidents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/incidents/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search for incidents associated with a process instance
         * @description Search for incidents caused by the process instance or any of its called process or decision instances.
         *
         *     Although the `processInstanceKey` is provided as a path parameter to indicate the root process instance,
         *     you may also include a `processInstanceKey` within the filter object to narrow results to specific
         *     child process instances. This is useful, for example, if you want to isolate incidents associated with
         *     subprocesses or called processes under the root instance while excluding incidents directly tied to the root.
         */
        post: operations["searchProcessInstanceIncidents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/migration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Migrate process instance
         * @description Migrates a process instance to a new process definition.
         *     This request can contain multiple mapping instructions to define mapping between the active
         *     process instance's elements and target process definition elements.
         *
         *     Use this to upgrade a process instance to a new version of a process or to
         *     a different process definition, e.g. to keep your running instances up-to-date with the
         *     latest process improvements.
         */
        post: operations["migrateProcessInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/modification": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Modify process instance
         * @description Modifies a running process instance.
         *     This request can contain multiple instructions to activate an element of the process or
         *     to terminate an active instance of an element.
         *
         *     Use this to repair a process instance that is stuck on an element or took an unintended path.
         *     For example, because an external system is not available or doesn't respond as expected.
         */
        post: operations["modifyProcessInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/sequence-flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get process instance sequence flows
         * @description Get sequence flows taken by the process instance.
         */
        get: operations["getProcessInstanceSequenceFlows"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/process-instances/{processInstanceKey}/statistics/element-instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get process instance statistics
         * @description Get statistics about elements by the process instance key.
         */
        get: operations["getProcessInstanceStatistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resourceKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get resource
         * @description Returns a deployed resource.
         *     :::info
         *     Currently, this endpoint only supports RPA resources.
         *     :::
         */
        get: operations["getResource"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resourceKey}/content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get resource content
         * @description Returns the content of a deployed resource.
         *     :::info
         *     Currently, this endpoint only supports RPA resources.
         *     :::
         */
        get: operations["getResourceContent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/resources/{resourceKey}/deletion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Delete resource
         * @description Deletes a deployed resource.
         *     This can be a process definition, decision requirements definition, or form definition
         *     deployed using the deploy resources endpoint. Specify the resource you want to delete in the `resourceKey` parameter.
         */
        post: operations["deleteResource"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create role
         * @description Create a new role.
         */
        post: operations["createRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search roles
         * @description Search for roles based on given criteria.
         */
        post: operations["searchRoles"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get role
         * @description Get a role by its ID.
         */
        get: operations["getRole"];
        /**
         * Update role
         * @description Update a role with the given ID.
         */
        put: operations["updateRole"];
        post?: never;
        /**
         * Delete role
         * @description Deletes the role with the given ID.
         */
        delete: operations["deleteRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/clients/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search role clients
         * @description Search clients with assigned role.
         */
        post: operations["searchClientsForRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/clients/{clientId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a role to a client
         * @description Assigns the specified role to the client. The client will inherit the authorizations associated with this role.
         */
        put: operations["assignRoleToClient"];
        post?: never;
        /**
         * Unassign a role from a client
         * @description Unassigns the specified role from the client. The client will no longer inherit the authorizations associated with this role.
         */
        delete: operations["unassignRoleFromClient"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/groups/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search role groups
         * @description Search groups with assigned role.
         */
        post: operations["searchGroupsForRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/groups/{groupId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a role to a group
         * @description Assigns the specified role to the group. Every member of the group (user or client) will inherit the authorizations associated with this role.
         */
        put: operations["assignRoleToGroup"];
        post?: never;
        /**
         * Unassign a role from a group
         * @description Unassigns the specified role from the group. All group members (user or client) no longer inherit the authorizations associated with this role.
         */
        delete: operations["unassignRoleFromGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/mapping-rules/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search role mapping rules
         * @description Search mapping rules with assigned role.
         */
        post: operations["searchMappingRulesForRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/mapping-rules/{mappingRuleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a role to a mapping rule
         * @description Assigns a role to a mapping rule.
         */
        put: operations["assignRoleToMappingRule"];
        post?: never;
        /**
         * Unassign a role from a mapping rule
         * @description Unassigns a role from a mapping rule.
         */
        delete: operations["unassignRoleFromMappingRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/users/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search role users
         * @description Search users with assigned role.
         */
        post: operations["searchUsersForRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{roleId}/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a role to a user
         * @description Assigns the specified role to the user. The user will inherit the authorizations associated with this role.
         */
        put: operations["assignRoleToUser"];
        post?: never;
        /**
         * Unassign a role from a user
         * @description Unassigns a role from a user. The user will no longer inherit the authorizations associated with this role.
         */
        delete: operations["unassignRoleFromUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/setup/user": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create admin user
         * @description Creates a new user and assigns the admin role to it. This endpoint is only usable when users are managed in the Orchestration Cluster and while no user is assigned to the admin role.
         */
        post: operations["createAdminUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signals/broadcast": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Broadcast signal
         * @description Broadcasts a signal.
         */
        post: operations["broadcastSignal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get cluster status
         * @description Checks the health status of the cluster by verifying if there's at least one partition with a healthy leader.
         */
        get: operations["getStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/usage-metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get usage metrics
         * @description Retrieve the usage metrics based on given criteria.
         */
        get: operations["getUsageMetrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create tenant
         * @description Creates a new tenant.
         */
        post: operations["createTenant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search tenants
         * @description Retrieves a filtered and sorted list of tenants.
         */
        post: operations["searchTenants"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get tenant
         * @description Retrieves a single tenant by tenant ID.
         */
        get: operations["getTenant"];
        /**
         * Update tenant
         * @description Updates an existing tenant.
         */
        put: operations["updateTenant"];
        post?: never;
        /**
         * Delete tenant
         * @description Deletes an existing tenant.
         */
        delete: operations["deleteTenant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/clients/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search clients for tenant
         * @description Retrieves a filtered and sorted list of clients for a specified tenant.
         */
        post: operations["searchClientsForTenant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/clients/{clientId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a client to a tenant
         * @description Assign the client to the specified tenant.
         *     The client can then access tenant data and perform authorized actions.
         */
        put: operations["assignClientToTenant"];
        post?: never;
        /**
         * Unassign a client from a tenant
         * @description Unassigns the client from the specified tenant.
         *     The client can no longer access tenant data.
         */
        delete: operations["unassignClientFromTenant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/groups/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search groups for tenant
         * @description Retrieves a filtered and sorted list of groups for a specified tenant.
         */
        post: operations["searchGroupIdsForTenant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/groups/{groupId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a group to a tenant
         * @description Assigns a group to a specified tenant.
         *     Group members (users, clients) can then access tenant data and perform authorized actions.
         */
        put: operations["assignGroupToTenant"];
        post?: never;
        /**
         * Unassign a group from a tenant
         * @description Unassigns a group from a specified tenant.
         *     Members of the group (users, clients) will no longer have access to the tenant's data - except they are assigned directly to the tenant.
         */
        delete: operations["unassignGroupFromTenant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/mapping-rules/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search mapping rules for tenant
         * @description Retrieves a filtered and sorted list of MappingRules for a specified tenant.
         */
        post: operations["searchMappingRulesForTenant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/mapping-rules/{mappingRuleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a mapping rule to a tenant
         * @description Assign a single mapping rule to a specified tenant.
         */
        put: operations["assignMappingRuleToTenant"];
        post?: never;
        /**
         * Unassign a mapping rule from a tenant
         * @description Unassigns a single mapping rule from a specified tenant without deleting the rule.
         */
        delete: operations["unassignMappingRuleFromTenant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/roles/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search roles for tenant
         * @description Retrieves a filtered and sorted list of roles for a specified tenant.
         */
        post: operations["searchRolesForTenant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/roles/{roleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a role to a tenant
         * @description Assigns a role to a specified tenant.
         *     Users, Clients or Groups, that have the role assigned, will get access to the tenant's data and can perform actions according to their authorizations.
         */
        put: operations["assignRoleToTenant"];
        post?: never;
        /**
         * Unassign a role from a tenant
         * @description Unassigns a role from a specified tenant.
         *     Users, Clients or Groups, that have the role assigned, will no longer have access to the
         *     tenant's data - unless they are assigned directly to the tenant.
         */
        delete: operations["unassignRoleFromTenant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/users/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search users for tenant
         * @description Retrieves a filtered and sorted list of users for a specified tenant.
         */
        post: operations["searchUsersForTenant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tenants/{tenantId}/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Assign a user to a tenant
         * @description Assign a single user to a specified tenant. The user can then access tenant data and perform authorized actions.
         */
        put: operations["assignUserToTenant"];
        post?: never;
        /**
         * Unassign a user from a tenant
         * @description Unassigns the user from the specified tenant.
         *     The user can no longer access tenant data.
         */
        delete: operations["unassignUserFromTenant"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/topology": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get cluster topology
         * @description Obtains the current topology of the cluster the gateway is part of.
         */
        get: operations["getTopology"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create user
         * @description Create a new user.
         */
        post: operations["createUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search users
         * @description Search for users based on given criteria.
         */
        post: operations["searchUsers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user
         * @description Get a user by its username.
         */
        get: operations["getUser"];
        /**
         * Update user
         * @description Updates a user.
         */
        put: operations["updateUser"];
        post?: never;
        /**
         * Delete user
         * @description Deletes a user.
         */
        delete: operations["deleteUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user-tasks/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search user tasks
         * @description Search for user tasks based on given criteria.
         */
        post: operations["searchUserTasks"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user-tasks/{userTaskKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user task
         * @description Get the user task by the user task key.
         */
        get: operations["getUserTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update user task
         * @description Update a user task with the given key.
         */
        patch: operations["updateUserTask"];
        trace?: never;
    };
    "/user-tasks/{userTaskKey}/assignee": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unassign user task
         * @description Removes the assignee of a task with the given key.
         */
        delete: operations["unassignUserTask"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user-tasks/{userTaskKey}/assignment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Assign user task
         * @description Assigns a user task with the given key to the given assignee.
         */
        post: operations["assignUserTask"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user-tasks/{userTaskKey}/completion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete user task
         * @description Completes a user task with the given key.
         */
        post: operations["completeUserTask"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user-tasks/{userTaskKey}/form": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get user task form
         * @description Get the form of a user task.
         *     Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
         */
        get: operations["getUserTaskForm"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user-tasks/{userTaskKey}/variables/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search user task variables
         * @description Search for user task variables based on given criteria.
         */
        post: operations["searchUserTaskVariables"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/variables/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search variables
         * @description Search for process and local variables based on given criteria.
         */
        post: operations["searchVariables"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/variables/{variableKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get variable
         * @description Get the variable by the variable key.
         */
        get: operations["getVariable"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * Format: Username
         * @description The unique name of a user.
         * @example swillis
         */
        Username: string;
        /**
         * Format: TenantId
         * @description The unique identifier of the tenant.
         * @example customer-service
         */
        TenantId: string;
        /** @description Tenant search response item. */
        TenantResult: {
            /**
             * @description The tenant name.
             * @example Customer Service department
             */
            name?: string;
            tenantId?: components["schemas"]["TenantId"];
            /**
             * @description The tenant description.
             * @example Customer Service department business processes
             */
            description?: string;
        };
        CamundaUserResult: {
            /** @description The username of the user. */
            username?: components["schemas"]["Username"] | null;
            /**
             * @description The display name of the user.
             * @example Samantha Willis
             */
            displayName?: string | null;
            /**
             * @description The email of the user.
             * @example swillis@acme.com
             */
            email?: string | null;
            /**
             * @description The web components the user is authorized to use.
             * @example [
             *       "*"
             *     ]
             */
            authorizedComponents?: string[];
            /** @description The tenants the user is a member of. */
            tenants: components["schemas"]["TenantResult"][];
            /**
             * @description The groups assigned to the user.
             * @example [
             *       "customer-service"
             *     ]
             */
            groups: string[];
            /**
             * @description The roles assigned to the user.
             * @example [
             *       "frontline-support"
             *     ]
             */
            roles: string[];
            /**
             * @description The plan of the user.
             * @example
             */
            salesPlanType: string;
            /**
             * @description The links to the components in the C8 stack.
             * @example {}
             */
            c8Links: {
                [key: string]: string;
            };
            /** @description Flag for understanding if the user is able to perform logout. */
            canLogout: boolean;
        };
        /** @description A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type. */
        ProblemDetail: {
            /**
             * Format: uri
             * @description A URI identifying the problem type.
             * @default about:blank
             * @example about:blank
             */
            type: string;
            /**
             * @description A summary of the problem type.
             * @example Bad Request
             */
            title?: string;
            /**
             * Format: int32
             * @description The HTTP status code for this problem.
             * @example 400
             */
            status?: number;
            /**
             * @description An explanation of the problem in more detail.
             * @example Request property [maxJobsToActivates] cannot be parsed
             */
            detail?: string;
            /**
             * Format: uri
             * @description A URI path identifying the origin of the problem.
             * @example /v2/jobs/activation
             */
            instance?: string;
        };
        /** @description Zeebe Engine resource key (Java long serialized as string) */
        LongKey: string;
        /**
         * Format: AuthorizationKey
         * @description System-generated key for an authorization.
         * @example 2251799813684332
         */
        AuthorizationKey: string & components["schemas"]["LongKey"];
        AuthorizationCreateResult: {
            /** @description The key of the created authorization. */
            authorizationKey?: components["schemas"]["AuthorizationKey"];
        };
        /**
         * @description The type of the owner of permissions.
         * @enum {string}
         */
        OwnerTypeEnum: "USER" | "CLIENT" | "ROLE" | "GROUP" | "MAPPING_RULE" | "UNSPECIFIED";
        /**
         * @description The type of resource to add/remove permissions to/from.
         * @enum {string}
         */
        ResourceTypeEnum: "AUTHORIZATION" | "BATCH" | "COMPONENT" | "DECISION_DEFINITION" | "DECISION_REQUIREMENTS_DEFINITION" | "DOCUMENT" | "GROUP" | "MAPPING_RULE" | "MESSAGE" | "PROCESS_DEFINITION" | "RESOURCE" | "ROLE" | "SYSTEM" | "TENANT" | "USER" | "USER_TASK";
        /**
         * @description Specifies the type of permissions.
         * @enum {string}
         */
        PermissionTypeEnum: "ACCESS" | "CANCEL_PROCESS_INSTANCE" | "CLAIM" | "COMPLETE" | "CREATE" | "CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE" | "CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION" | "CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE" | "CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION" | "CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE" | "CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE" | "CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE" | "CREATE_BATCH_OPERATION_RESOLVE_INCIDENT" | "CREATE_DECISION_INSTANCE" | "CREATE_PROCESS_INSTANCE" | "DELETE" | "DELETE_DECISION_INSTANCE" | "DELETE_DRD" | "DELETE_FORM" | "DELETE_PROCESS" | "DELETE_PROCESS_INSTANCE" | "DELETE_RESOURCE" | "MODIFY_PROCESS_INSTANCE" | "READ" | "READ_DECISION_DEFINITION" | "READ_DECISION_INSTANCE" | "READ_PROCESS_DEFINITION" | "READ_PROCESS_INSTANCE" | "READ_USAGE_METRIC" | "READ_USER_TASK" | "UPDATE" | "UPDATE_PROCESS_INSTANCE" | "UPDATE_USER_TASK";
        AuthorizationResult: {
            /** @description The ID of the owner of permissions. */
            ownerId?: string;
            ownerType?: components["schemas"]["OwnerTypeEnum"];
            /** @description The type of resource that the permissions relate to. */
            resourceType?: string & components["schemas"]["ResourceTypeEnum"];
            /** @description ID of the resource the permission relates to. */
            resourceId?: string;
            /** @description Specifies the types of the permissions. */
            permissionTypes?: components["schemas"]["PermissionTypeEnum"][];
            /** @description The key of the authorization. */
            authorizationKey?: components["schemas"]["AuthorizationKey"];
        };
        /** Limit-based pagination */
        LimitPagination: {
            /**
             * Format: int32
             * @description The maximum number of items to return in one request.
             * @default 100
             */
            limit: number;
        };
        /** Offset-based pagination */
        OffsetPagination: {
            /**
             * Format: int32
             * @description The index of items to start searching from.
             */
            from?: number;
            /**
             * Format: int32
             * @description The maximum number of items to return in one request.
             * @default 100
             */
            limit: number;
        };
        /**
         * Format: base64
         * @description The end cursor in a search query result set.
         * @example WzIyNTE3OTk4MTM2ODcxMDJd
         */
        EndCursor: string;
        /** Cursor-based forward pagination */
        CursorForwardPagination: {
            /** @description Use the `endCursor` value from the previous response to fetch the next page of results. */
            after: components["schemas"]["EndCursor"];
            /**
             * Format: int32
             * @description The maximum number of items to return in one request.
             * @default 100
             */
            limit: number;
        };
        /**
         * Format: base64
         * @description The start cursor in a search query result set.
         * @example WzIyNTE3OTk4MTM2ODcxMDJd
         */
        StartCursor: string;
        /** Cursor-based backward pagination */
        CursorBackwardPagination: {
            /** @description Use the `startCursor` value from the previous response to fetch the previous page of results. */
            before: components["schemas"]["StartCursor"];
            /**
             * Format: int32
             * @description The maximum number of items to return in one request.
             * @default 100
             */
            limit: number;
        };
        /** @description Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both. */
        SearchQueryPageRequest: components["schemas"]["LimitPagination"] | components["schemas"]["OffsetPagination"] | components["schemas"]["CursorForwardPagination"] | components["schemas"]["CursorBackwardPagination"];
        SearchQueryRequest: {
            /** @description Pagination criteria. */
            page?: components["schemas"]["SearchQueryPageRequest"];
        };
        /**
         * @description The order in which to sort the related field.
         * @default ASC
         * @enum {string}
         */
        SortOrderEnum: "ASC" | "DESC";
        AuthorizationSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "ownerId" | "ownerType" | "resourceId" | "resourceType";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Authorization search filter. */
        AuthorizationFilter: {
            /** @description The ID of the owner of permissions. */
            ownerId?: string;
            ownerType?: components["schemas"]["OwnerTypeEnum"];
            /** @description The IDs of the resource to search permissions for. */
            resourceIds?: string[];
            /** @description The type of resource to search permissions for. */
            resourceType?: string & components["schemas"]["ResourceTypeEnum"];
        };
        AuthorizationSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["AuthorizationSearchQuerySortRequest"][];
            /** @description The authorization search filters. */
            filter?: components["schemas"]["AuthorizationFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /**
         * @description Pagination information about the search results.
         * @example {
         *       "totalItems": 1,
         *       "hasMoreTotalItems": false
         *     }
         */
        SearchQueryPageResponse: {
            /**
             * Format: int64
             * @description Total items matching the criteria.
             */
            totalItems: number;
            /**
             * @description Indicates whether there are more items matching the criteria beyond the returned items.
             *     This is useful for determining if additional requests are needed to retrieve all results.
             */
            hasMoreTotalItems?: boolean;
            /** @description The cursor value for getting the previous page of results. Use this in the `before` field of an ensuing request. */
            startCursor?: components["schemas"]["StartCursor"];
            /** @description The cursor value for getting the next page of results. Use this in the `after` field of an ensuing request. */
            endCursor?: components["schemas"]["EndCursor"];
        };
        SearchQueryResponse: {
            page: components["schemas"]["SearchQueryPageResponse"];
        };
        AuthorizationSearchResult: {
            /** @description The matching authorizations. */
            items?: components["schemas"]["AuthorizationResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        AuthorizationRequest: {
            /** @description The ID of the owner of the permissions. */
            ownerId: string;
            ownerType: components["schemas"]["OwnerTypeEnum"];
            /** @description The ID of the resource to add permissions to. */
            resourceId: string;
            /** @description The type of resource to add permissions to. */
            resourceType: string & components["schemas"]["ResourceTypeEnum"];
            /** @description The permission types to add. */
            permissionTypes: components["schemas"]["PermissionTypeEnum"][];
        };
        BatchOperationItemSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "batchOperationKey" | "itemKey" | "processInstanceKey" | "state";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * Advanced filter
         * @description Basic advanced string filter.
         */
        BasicStringFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: string;
            /** @description Checks for inequality with the provided value. */
            $neq?: string;
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: string[];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: string[];
        };
        /** @description String property with basic advanced search capabilities. */
        BasicStringFilterProperty: string | components["schemas"]["BasicStringFilter"];
        /**
         * Format: ProcessInstanceKey
         * @description System-generated key for a process instance.
         * @example 2251799813690746
         */
        ProcessInstanceKey: string & components["schemas"]["LongKey"];
        /**
         * Advanced filter
         * @description Advanced ProcessInstanceKey filter.
         */
        AdvancedProcessInstanceKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["ProcessInstanceKey"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["ProcessInstanceKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["ProcessInstanceKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["ProcessInstanceKey"][];
        };
        /** @description ProcessInstanceKey property with full advanced search capabilities. */
        ProcessInstanceKeyFilterProperty: (string & components["schemas"]["ProcessInstanceKey"]) | components["schemas"]["AdvancedProcessInstanceKeyFilter"];
        /**
         * @description The batch operation item state.
         * @enum {string}
         */
        BatchOperationItemStateEnum: "ACTIVE" | "COMPLETED" | "CANCELED" | "FAILED";
        /**
         * @description Checks if the property matches the provided like value.
         *
         *     Supported wildcard characters are:
         *
         *     * `*`: matches zero, one, or multiple characters.
         *     * `?`: matches one, single character.
         *
         *     Wildcard characters can be escaped with backslash, for instance: `\*`.
         */
        LikeFilter: string;
        /**
         * Advanced filter
         * @description Advanced BatchOperationItemStateEnum filter.
         */
        AdvancedBatchOperationItemStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["BatchOperationItemStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["BatchOperationItemStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["BatchOperationItemStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description BatchOperationItemStateEnum property with full advanced search capabilities. */
        BatchOperationItemStateFilterProperty: (string & components["schemas"]["BatchOperationItemStateEnum"]) | components["schemas"]["AdvancedBatchOperationItemStateFilter"];
        /** @description Batch operation item filter request. */
        BatchOperationItemFilter: {
            /** @description The key (or operate legacy ID) of the batch operation. */
            batchOperationKey?: components["schemas"]["BasicStringFilterProperty"];
            /** @description The key of the item, e.g. a process instance key. */
            itemKey?: components["schemas"]["BasicStringFilterProperty"];
            /** @description The process instance key of the processed item. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The state of the batch operation. */
            state?: string & components["schemas"]["BatchOperationItemStateFilterProperty"];
        };
        /** @description Batch operation item search request. */
        BatchOperationItemSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["BatchOperationItemSearchQuerySortRequest"][];
            /** @description The batch operation item search filters. */
            filter?: components["schemas"]["BatchOperationItemFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /**
         * @description The type of the batch operation.
         * @enum {string}
         */
        BatchOperationTypeEnum: "CANCEL_PROCESS_INSTANCE" | "RESOLVE_INCIDENT" | "MIGRATE_PROCESS_INSTANCE" | "MODIFY_PROCESS_INSTANCE" | "DELETE_PROCESS_INSTANCE" | "ADD_VARIABLE" | "UPDATE_VARIABLE" | "DELETE_DECISION_DEFINITION" | "DELETE_PROCESS_DEFINITION";
        /**
         * Format: BatchOperationKey | uuid
         * @description System-generated key for an batch operation.
         * @example 2251799813684321
         */
        BatchOperationKey: string;
        BatchOperationItemResponse: {
            operationType?: components["schemas"]["BatchOperationTypeEnum"];
            /** @description The key (or operate legacy ID) of the batch operation. */
            batchOperationKey?: components["schemas"]["BatchOperationKey"];
            /** @description Key of the item, e.g. a process instance key. */
            itemKey?: string;
            /** @description the process instance key of the processed item. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /**
             * @description State of the item.
             * @enum {string}
             */
            state?: "ACTIVE" | "COMPLETED" | "SKIPPED" | "CANCELED" | "FAILED";
            /**
             * Format: date-time
             * @description the date this item was processed.
             */
            processedDate?: string;
            /** @description the error message from the engine in case of a failed operation. */
            errorMessage?: string;
        };
        BatchOperationItemSearchQueryResult: {
            /** @description The matching batch operation items. */
            items?: components["schemas"]["BatchOperationItemResponse"][];
        } & components["schemas"]["SearchQueryResponse"];
        BatchOperationSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "batchOperationKey" | "operationType" | "state" | "startDate" | "endDate";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * Advanced filter
         * @description Advanced BatchOperationTypeEnum filter.
         */
        AdvancedBatchOperationTypeFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["BatchOperationTypeEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["BatchOperationTypeEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["BatchOperationTypeEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description BatchOperationTypeEnum property with full advanced search capabilities. */
        BatchOperationTypeFilterProperty: (string & components["schemas"]["BatchOperationTypeEnum"]) | components["schemas"]["AdvancedBatchOperationTypeFilter"];
        /**
         * @description The batch operation state.
         * @enum {string}
         */
        BatchOperationStateEnum: "ACTIVE" | "CANCELED" | "COMPLETED" | "CREATED" | "FAILED" | "PARTIALLY_COMPLETED" | "SUSPENDED";
        /**
         * Advanced filter
         * @description Advanced BatchOperationStateEnum filter.
         */
        AdvancedBatchOperationStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["BatchOperationStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["BatchOperationStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["BatchOperationStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description BatchOperationStateEnum property with full advanced search capabilities. */
        BatchOperationStateFilterProperty: (string & components["schemas"]["BatchOperationStateEnum"]) | components["schemas"]["AdvancedBatchOperationStateFilter"];
        /** @description Batch operation filter request. */
        BatchOperationFilter: {
            /** @description The key (or operate legacy ID) of the batch operation. */
            batchOperationKey?: components["schemas"]["BasicStringFilterProperty"];
            /** @description The type of the batch operation. */
            operationType?: components["schemas"]["BatchOperationTypeFilterProperty"];
            /** @description The state of the batch operation. */
            state?: components["schemas"]["BatchOperationStateFilterProperty"];
        };
        /** @description Batch operation search request. */
        BatchOperationSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["BatchOperationSearchQuerySortRequest"][];
            /** @description The batch operation search filters. */
            filter?: components["schemas"]["BatchOperationFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        BatchOperationError: {
            /**
             * Format: int32
             * @description The partition ID where the error occurred.
             */
            partitionId?: number;
            /**
             * @description The type of the error that occurred during the batch operation.
             * @enum {string}
             */
            type?: "QUERY_FAILED" | "RESULT_BUFFER_SIZE_EXCEEDED";
            /** @description The error message that occurred during the batch operation. */
            message?: string;
        };
        BatchOperationResponse: {
            /** @description Key or (Operate Legacy ID = UUID) of the batch operation. */
            batchOperationKey?: components["schemas"]["BatchOperationKey"];
            state?: components["schemas"]["BatchOperationStateEnum"];
            batchOperationType?: components["schemas"]["BatchOperationTypeEnum"];
            /**
             * Format: date-time
             * @description The start date of the batch operation.
             */
            startDate?: string;
            /**
             * Format: date-time
             * @description The end date of the batch operation.
             */
            endDate?: string;
            /**
             * Format: int32
             * @description The total number of items contained in this batch operation.
             */
            operationsTotalCount?: number;
            /**
             * Format: int32
             * @description The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).
             */
            operationsFailedCount?: number;
            /**
             * Format: int32
             * @description The number of successfully completed tasks.
             */
            operationsCompletedCount?: number;
            /** @description The errors that occurred per partition during the batch operation. */
            errors?: components["schemas"]["BatchOperationError"][];
        };
        /** @description The batch operation search query result. */
        BatchOperationSearchQueryResult: {
            /** @description The matching batch operations. */
            items?: components["schemas"]["BatchOperationResponse"][];
        } & components["schemas"]["SearchQueryResponse"];
        ClockPinRequest: {
            /**
             * Format: int64
             * @description The exact time in epoch milliseconds to which the clock should be pinned.
             */
            timestamp: number;
        };
        CorrelatedMessageSubscriptionSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "correlationKey" | "correlationTime" | "elementId" | "elementInstanceKey" | "messageKey" | "messageName" | "partitionId" | "processDefinitionId" | "processDefinitionKey" | "processInstanceKey" | "subscriptionKey" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * Advanced filter
         * @description Advanced string filter.
         */
        AdvancedStringFilter: components["schemas"]["BasicStringFilter"] & {
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description String property with full advanced search capabilities. */
        StringFilterProperty: string | components["schemas"]["AdvancedStringFilter"];
        /**
         * Advanced filter
         * @description Advanced date-time filter.
         */
        AdvancedDateTimeFilter: {
            /**
             * Format: date-time
             * @description Checks for equality with the provided value.
             */
            $eq?: string;
            /**
             * Format: date-time
             * @description Checks for inequality with the provided value.
             */
            $neq?: string;
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /**
             * Format: date-time
             * @description Greater than comparison with the provided value.
             */
            $gt?: string;
            /**
             * Format: date-time
             * @description Greater than or equal comparison with the provided value.
             */
            $gte?: string;
            /**
             * Format: date-time
             * @description Lower than comparison with the provided value.
             */
            $lt?: string;
            /**
             * Format: date-time
             * @description Lower than or equal comparison with the provided value.
             */
            $lte?: string;
            /** @description Checks if the property matches any of the provided values. */
            $in?: string[];
        };
        /** @description Date-time property with full advanced search capabilities. */
        DateTimeFilterProperty: string | components["schemas"]["AdvancedDateTimeFilter"];
        /**
         * Format: ElementInstanceKey
         * @description System-generated key for a element instance.
         * @example 2251799813686789
         */
        ElementInstanceKey: string & components["schemas"]["LongKey"];
        /**
         * Advanced filter
         * @description Advanced ElementInstanceKey filter.
         */
        AdvancedElementInstanceKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["ElementInstanceKey"];
            /** @description Checks for equality with the provided value. */
            $neq?: components["schemas"]["ElementInstanceKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["ElementInstanceKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["ElementInstanceKey"][];
        };
        /** @description ElementInstanceKey property with full advanced search capabilities. */
        ElementInstanceKeyFilterProperty: (string & components["schemas"]["ElementInstanceKey"]) | components["schemas"]["AdvancedElementInstanceKeyFilter"];
        /**
         * Advanced filter
         * @description Advanced integer (int32) filter.
         */
        AdvancedIntegerFilter: {
            /**
             * Format: int32
             * @description Checks for equality with the provided value.
             */
            $eq?: number;
            /**
             * Format: int32
             * @description Checks for inequality with the provided value.
             */
            $neq?: number;
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /**
             * Format: int32
             * @description Greater than comparison with the provided value.
             */
            $gt?: number;
            /**
             * Format: int32
             * @description Greater than or equal comparison with the provided value.
             */
            $gte?: number;
            /**
             * Format: int32
             * @description Lower than comparison with the provided value.
             */
            $lt?: number;
            /**
             * Format: int32
             * @description Lower than or equal comparison with the provided value.
             */
            $lte?: number;
            /** @description Checks if the property matches any of the provided values. */
            $in?: number[];
        };
        /** @description Integer property with advanced search capabilities. */
        IntegerFilterProperty: number | components["schemas"]["AdvancedIntegerFilter"];
        /**
         * Format: ProcessDefinitionKey
         * @description System-generated key for a deployed process definition.
         * @example 2251799813686749
         */
        ProcessDefinitionKey: string & components["schemas"]["LongKey"];
        /**
         * Advanced filter
         * @description Advanced ProcessDefinitionKey filter.
         */
        AdvancedProcessDefinitionKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["ProcessDefinitionKey"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["ProcessDefinitionKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["ProcessDefinitionKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["ProcessDefinitionKey"][];
        };
        /** @description ProcessDefinitionKey property with full advanced search capabilities. */
        ProcessDefinitionKeyFilterProperty: (string & components["schemas"]["ProcessDefinitionKey"]) | components["schemas"]["AdvancedProcessDefinitionKeyFilter"];
        /**
         * Format: MessageSubscriptionKey
         * @description System-generated key for a message subscription.
         * @example 2251799813632456
         */
        MessageSubscriptionKey: string & components["schemas"]["LongKey"];
        /**
         * Advanced filter
         * @description Advanced MessageSubscriptionKey filter.
         */
        AdvancedMessageSubscriptionKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["MessageSubscriptionKey"];
            /** @description Checks for equality with the provided value. */
            $neq?: components["schemas"]["MessageSubscriptionKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["MessageSubscriptionKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["MessageSubscriptionKey"][];
        };
        /** @description MessageSubscriptionKey property with full advanced search capabilities. */
        MessageSubscriptionKeyFilterProperty: (string & components["schemas"]["MessageSubscriptionKey"]) | components["schemas"]["AdvancedMessageSubscriptionKeyFilter"];
        /** @description Correlated message subscriptions search filter. */
        CorrelatedMessageSubscriptionFilter: {
            /** @description The correlation key of the message. */
            correlationKey?: components["schemas"]["StringFilterProperty"];
            /** @description The time when the message was correlated. */
            correlationTime?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The element ID that received the message. */
            elementId?: components["schemas"]["StringFilterProperty"];
            /** @description The element instance key that received the message. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKeyFilterProperty"];
            /** @description The message key. */
            messageKey?: components["schemas"]["BasicStringFilterProperty"];
            /** @description The name of the message. */
            messageName?: components["schemas"]["StringFilterProperty"];
            /** @description The partition ID that correlated the message. */
            partitionId?: components["schemas"]["IntegerFilterProperty"];
            /** @description The process definition ID associated with this correlated message subscription. */
            processDefinitionId?: components["schemas"]["StringFilterProperty"];
            /** @description The process definition key associated with this correlated message subscription. For intermediate message events, this only works for data created with 8.9 and later. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKeyFilterProperty"];
            /** @description The process instance key associated with this correlated message subscription. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The subscription key that received the message. */
            subscriptionKey?: components["schemas"]["MessageSubscriptionKeyFilterProperty"];
            /** @description The tenant ID associated with this correlated message subscription. */
            tenantId?: components["schemas"]["StringFilterProperty"];
        };
        CorrelatedMessageSubscriptionSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["CorrelatedMessageSubscriptionSearchQuerySortRequest"][];
            /** @description The correlated message subscriptions search filters. */
            filter?: components["schemas"]["CorrelatedMessageSubscriptionFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /**
         * Format: MessageKey
         * @description System-generated key for an message.
         * @example 2251799813683467
         */
        MessageKey: string & components["schemas"]["LongKey"];
        /**
         * Format: ProcessDefinitionId
         * @description Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
         * @example new-account-onboarding-workflow
         */
        ProcessDefinitionId: string;
        CorrelatedMessageSubscriptionResult: {
            /** @description The correlation key of the message. */
            correlationKey: string;
            /**
             * Format: date-time
             * @description The time when the message was correlated.
             */
            correlationTime: string;
            /** @description The element ID that received the message. */
            elementId: string;
            /** @description The element instance key that received the message. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            /** @description The message key. */
            messageKey: components["schemas"]["MessageKey"];
            /** @description The name of the message. */
            messageName: string;
            /**
             * Format: int32
             * @description The partition ID that correlated the message.
             */
            partitionId: number;
            /** @description The process definition ID associated with this correlated message subscription. */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /** @description The process definition key associated with this correlated message subscription. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The process instance key associated with this correlated message subscription. */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            /** @description The subscription key that received the message. */
            subscriptionKey: components["schemas"]["MessageSubscriptionKey"];
            /** @description The tenant ID associated with this correlated message subscription. */
            tenantId: components["schemas"]["TenantId"];
        };
        CorrelatedMessageSubscriptionSearchQueryResult: {
            /** @description The matching correlated message subscriptions. */
            items?: components["schemas"]["CorrelatedMessageSubscriptionResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /**
         * Format: DecisionDefinitionId
         * @description Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
         * @example new-hire-onboarding-workflow
         */
        DecisionDefinitionId: string;
        /** Decision evaluation by ID */
        DecisionEvaluationById: {
            /**
             * @description The ID of the decision to be evaluated.
             *     When using the decision ID, the latest
             *     deployed version of the decision is used.
             */
            decisionDefinitionId: components["schemas"]["DecisionDefinitionId"];
            /** @description The message variables as JSON document. */
            variables?: {
                [key: string]: unknown;
            };
            /** @description The tenant ID of the decision. */
            tenantId?: components["schemas"]["TenantId"];
        };
        /**
         * Format: DecisionDefinitionKey
         * @description System-generated key for a decision definition.
         * @example 2251799813326547
         */
        DecisionDefinitionKey: string & components["schemas"]["LongKey"];
        /** Decision evaluation by key */
        DecisionEvaluationByKey: {
            decisionDefinitionKey: components["schemas"]["DecisionDefinitionKey"];
            /** @description The message variables as JSON document. */
            variables?: {
                [key: string]: unknown;
            };
            /** @description The tenant ID of the decision. */
            tenantId?: components["schemas"]["TenantId"];
        };
        DecisionEvaluationInstruction: components["schemas"]["DecisionEvaluationById"] | components["schemas"]["DecisionEvaluationByKey"];
        /**
         * Format: DecisionRequirementsKey
         * @description System-generated key for a deployed decision requirements definition.
         * @example 2251799813683346
         */
        DecisionRequirementsKey: string & components["schemas"]["LongKey"];
        /**
         * Format: DecisionInstanceKey
         * @description System-generated key for a deployed decision instance.
         * @example 22517998136843567
         */
        DecisionInstanceKey: string & components["schemas"]["LongKey"];
        /**
         * Format: DecisionEvaluationKey
         * @description System-generated key for a decision evaluation.
         * @example 2251792362345323
         */
        DecisionEvaluationKey: string & components["schemas"]["LongKey"];
        /** @description The evaluated decision outputs. */
        EvaluatedDecisionOutputItem: {
            outputId?: string;
            outputName?: string;
            outputValue?: string;
            ruleId?: string;
            /** Format: int32 */
            ruleIndex?: number;
        };
        /** @description A decision rule that matched within this decision evaluation. */
        MatchedDecisionRuleItem: {
            /** @description The ID of the matched rule. */
            ruleId?: string;
            /**
             * Format: int32
             * @description The index of the matched rule.
             */
            ruleIndex?: number;
            /** @description The evaluated decision outputs. */
            evaluatedOutputs?: components["schemas"]["EvaluatedDecisionOutputItem"][];
        };
        /** @description A decision input that was evaluated within this decision evaluation. */
        EvaluatedDecisionInputItem: {
            inputId?: string;
            inputName?: string;
            inputValue?: string;
        };
        /**
         * Format: DecisionEvaluationInstanceKey
         * @description System-generated key for a decision evaluation instance.
         * @example 2251799813684367
         */
        DecisionEvaluationInstanceKey: string & components["schemas"]["LongKey"];
        /** @description A decision that was evaluated. */
        EvaluatedDecisionResult: {
            /** @description The ID of the decision which was evaluated. */
            decisionDefinitionId?: components["schemas"]["DecisionDefinitionId"];
            /** @description The name of the decision which was evaluated. */
            decisionDefinitionName?: string;
            /**
             * Format: int32
             * @description The version of the decision which was evaluated.
             */
            decisionDefinitionVersion?: number;
            /** @description The type of the decision which was evaluated. */
            decisionDefinitionType?: string;
            /** @description JSON document that will instantiate the result of the decision which was evaluated. */
            output?: string;
            /** @description The tenant ID of the evaluated decision. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The decision rules that matched within this decision evaluation. */
            matchedRules?: components["schemas"]["MatchedDecisionRuleItem"][];
            /** @description The decision inputs that were evaluated within this decision evaluation. */
            evaluatedInputs?: components["schemas"]["EvaluatedDecisionInputItem"][];
            /** @description The unique key identifying the decision which was evaluate. */
            decisionDefinitionKey?: components["schemas"]["DecisionDefinitionKey"];
            /** @description The unique key identifying this decision evaluation instance. */
            decisionEvaluationInstanceKey?: components["schemas"]["DecisionEvaluationInstanceKey"];
        };
        EvaluateDecisionResult: {
            /** @description The ID of the decision which was evaluated. */
            decisionDefinitionId: components["schemas"]["DecisionDefinitionId"];
            /** @description The name of the decision which was evaluated. */
            decisionDefinitionName: string;
            /**
             * Format: int32
             * @description The version of the decision which was evaluated.
             */
            decisionDefinitionVersion: number;
            /** @description The ID of the decision requirements graph that the decision which was evaluated is part of. */
            decisionRequirementsId: string;
            /** @description JSON document that will instantiate the result of the decision which was evaluated. */
            output: string;
            /** @description The ID of the decision which failed during evaluation. */
            failedDecisionDefinitionId: components["schemas"]["DecisionDefinitionId"];
            /** @description Message describing why the decision which was evaluated failed. */
            failureMessage: string;
            /** @description The tenant ID of the evaluated decision. */
            tenantId: components["schemas"]["TenantId"];
            /** @description The unique key identifying the decision which was evaluated. */
            decisionDefinitionKey: components["schemas"]["DecisionDefinitionKey"];
            /** @description The unique key identifying the decision requirements graph that the decision which was evaluated is part of. */
            decisionRequirementsKey: components["schemas"]["DecisionRequirementsKey"];
            /**
             * @deprecated
             * @description Deprecated, please refer to `decisionEvaluationKey`.
             */
            decisionInstanceKey?: components["schemas"]["DecisionInstanceKey"];
            /** @description The unique key identifying this decision evaluation. */
            decisionEvaluationKey: components["schemas"]["DecisionEvaluationKey"];
            /** @description Decisions that were evaluated within the requested decision evaluation. */
            evaluatedDecisions: components["schemas"]["EvaluatedDecisionResult"][];
        };
        DecisionDefinitionSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "decisionDefinitionKey" | "decisionDefinitionId" | "name" | "version" | "decisionRequirementsId" | "decisionRequirementsKey" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Decision definition search filter. */
        DecisionDefinitionFilter: {
            /** @description The DMN ID of the decision definition. */
            decisionDefinitionId?: components["schemas"]["DecisionDefinitionId"];
            /** @description The DMN name of the decision definition. */
            name?: string;
            /** @description The assigned version of the decision definition. */
            version?: number;
            /** @description the DMN ID of the decision requirements graph that the decision definition is part of. */
            decisionRequirementsId?: string;
            /** @description The tenant ID of the decision definition. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this decision definition. */
            decisionDefinitionKey?: components["schemas"]["DecisionDefinitionKey"];
            /** @description The assigned key of the decision requirements graph that the decision definition is part of. */
            decisionRequirementsKey?: components["schemas"]["DecisionRequirementsKey"];
        };
        DecisionDefinitionSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["DecisionDefinitionSearchQuerySortRequest"][];
            /** @description The decision definition search filters. */
            filter?: components["schemas"]["DecisionDefinitionFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        DecisionDefinitionResult: {
            /** @description The DMN ID of the decision definition. */
            decisionDefinitionId?: components["schemas"]["DecisionDefinitionId"];
            /** @description The DMN name of the decision definition. */
            name?: string;
            /** @description The assigned version of the decision definition. */
            version?: number;
            /** @description the DMN ID of the decision requirements graph that the decision definition is part of. */
            decisionRequirementsId?: string;
            /** @description The tenant ID of the decision definition. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this decision definition. */
            decisionDefinitionKey?: components["schemas"]["DecisionDefinitionKey"];
            /** @description The assigned key of the decision requirements graph that the decision definition is part of. */
            decisionRequirementsKey?: components["schemas"]["DecisionRequirementsKey"];
        };
        DecisionDefinitionSearchQueryResult: {
            /** @description The matching decision definitions. */
            items?: components["schemas"]["DecisionDefinitionResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        DecisionInstanceSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "decisionDefinitionId" | "decisionDefinitionKey" | "decisionDefinitionName" | "decisionDefinitionType" | "decisionDefinitionVersion" | "decisionEvaluationInstanceKey" | "decisionEvaluationKey" | "elementInstanceKey" | "evaluationDate" | "evaluationFailure" | "processDefinitionKey" | "processInstanceKey" | "rootDecisionDefinitionKey" | "state" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * @description The state of the decision instance.
         * @enum {string}
         */
        DecisionInstanceStateEnum: "EVALUATED" | "FAILED" | "UNSPECIFIED";
        /**
         * @description The type of the decision.
         * @enum {string}
         */
        DecisionDefinitionTypeEnum: "DECISION_TABLE" | "LITERAL_EXPRESSION" | "UNKNOWN";
        /**
         * Advanced filter
         * @description Advanced DecisionDefinitionKey filter.
         */
        AdvancedDecisionDefinitionKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["DecisionDefinitionKey"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["DecisionDefinitionKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["DecisionDefinitionKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["DecisionDefinitionKey"][];
        };
        /** @description DecisionDefinitionKey property with full advanced search capabilities. */
        DecisionDefinitionKeyFilterProperty: (string & components["schemas"]["DecisionDefinitionKey"]) | components["schemas"]["AdvancedDecisionDefinitionKeyFilter"];
        /** @description Decision instance search filter. */
        DecisionInstanceFilter: {
            decisionEvaluationInstanceKey?: components["schemas"]["DecisionEvaluationInstanceKey"];
            state?: components["schemas"]["DecisionInstanceStateEnum"];
            /** @description The evaluation failure of the decision instance. */
            evaluationFailure?: string;
            /** @description The evaluation date of the decision instance. */
            evaluationDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The ID of the DMN decision. */
            decisionDefinitionId?: components["schemas"]["DecisionDefinitionId"];
            /** @description The name of the DMN decision. */
            decisionDefinitionName?: string;
            /**
             * Format: int32
             * @description The version of the decision.
             */
            decisionDefinitionVersion?: number;
            decisionDefinitionType?: components["schemas"]["DecisionDefinitionTypeEnum"];
            /** @description The tenant ID of the decision instance. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance. */
            decisionEvaluationKey?: components["schemas"]["DecisionEvaluationKey"];
            /** @description The key of the process definition. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The key of the process instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The key of the decision. */
            decisionDefinitionKey?: components["schemas"]["DecisionDefinitionKeyFilterProperty"];
            /** @description The key of the element instance this decision instance is linked to. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKeyFilterProperty"];
            /** @description The key of the root decision definition. */
            rootDecisionDefinitionKey?: components["schemas"]["DecisionDefinitionKeyFilterProperty"];
        };
        DecisionInstanceSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["DecisionInstanceSearchQuerySortRequest"][];
            /** @description The decision instance search filters. */
            filter?: components["schemas"]["DecisionInstanceFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        DecisionInstanceResult: {
            decisionEvaluationInstanceKey?: components["schemas"]["DecisionEvaluationInstanceKey"];
            state?: components["schemas"]["DecisionInstanceStateEnum"];
            /**
             * Format: date-time
             * @description The evaluation date of the decision instance.
             */
            evaluationDate?: string;
            /** @description The evaluation failure of the decision instance. */
            evaluationFailure?: string;
            /** @description The ID of the DMN decision. */
            decisionDefinitionId?: components["schemas"]["DecisionDefinitionId"];
            /** @description The name of the DMN decision. */
            decisionDefinitionName?: string;
            /**
             * Format: int32
             * @description The version of the decision.
             */
            decisionDefinitionVersion?: number;
            decisionDefinitionType?: components["schemas"]["DecisionDefinitionTypeEnum"];
            /** @description The result of the decision instance. */
            result?: string;
            /** @description The tenant ID of the decision instance. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key of the decision evaluation where this instance was created. */
            decisionEvaluationKey?: components["schemas"]["DecisionEvaluationKey"];
            /** @description The key of the process definition. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The key of the process instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The key of the decision. */
            decisionDefinitionKey?: components["schemas"]["DecisionDefinitionKey"];
            /** @description The key of the element instance this decision instance is linked to. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            /** @description The key of the root decision definition. */
            rootDecisionDefinitionKey?: components["schemas"]["DecisionDefinitionKey"];
        };
        DecisionInstanceSearchQueryResult: {
            /** @description The matching decision instances. */
            items?: components["schemas"]["DecisionInstanceResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        DecisionInstanceGetQueryResult: components["schemas"]["DecisionInstanceResult"] & {
            /** @description The evaluated inputs of the decision instance. */
            evaluatedInputs?: components["schemas"]["EvaluatedDecisionInputItem"][];
            /** @description The matched rules of the decision instance. */
            matchedRules?: components["schemas"]["MatchedDecisionRuleItem"][];
        };
        DecisionRequirementsSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "decisionRequirementsKey" | "decisionRequirementsName" | "version" | "decisionRequirementsId" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Decision requirements search filter. */
        DecisionRequirementsFilter: {
            /** @description The DMN name of the decision requirements. */
            decisionRequirementsName?: string;
            /** @description the DMN ID of the decision requirements. */
            decisionRequirementsId?: string;
            decisionRequirementsKey?: components["schemas"]["DecisionRequirementsKey"];
            /**
             * Format: int32
             * @description The assigned version of the decision requirements.
             */
            version?: number;
            /** @description The tenant ID of the decision requirements. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The name of the resource from which the decision requirements were parsed */
            resourceName?: string;
        };
        DecisionRequirementsSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["DecisionRequirementsSearchQuerySortRequest"][];
            /** @description The decision definition search filters. */
            filter?: components["schemas"]["DecisionRequirementsFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        DecisionRequirementsResult: {
            /** @description The DMN name of the decision requirements. */
            decisionRequirementsName?: string;
            /**
             * Format: int32
             * @description The assigned version of the decision requirements.
             */
            version?: number;
            /** @description The DMN ID of the decision requirements. */
            decisionRequirementsId?: string;
            /** @description The name of the resource from which this decision requirements was parsed. */
            resourceName?: string;
            /** @description The tenant ID of the decision requirements. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this decision requirements. */
            decisionRequirementsKey?: components["schemas"]["DecisionRequirementsKey"];
        };
        DecisionRequirementsSearchQueryResult: {
            /** @description The matching decision requirements. */
            items?: components["schemas"]["DecisionRequirementsResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /**
         * Format: DeploymentKey
         * @description Key for a deployment.
         */
        DeploymentKey: string & components["schemas"]["LongKey"];
        /** @description A deployed process. */
        DeploymentProcessResult: {
            /**
             * @description The bpmn process ID, as parsed during deployment, together with the version forms a
             *     unique identifier for a specific process definition.
             */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /**
             * Format: int32
             * @description The assigned process version.
             */
            processDefinitionVersion: number;
            /** @description The resource name from which this process was parsed. */
            resourceName: string;
            /** @description The tenant ID of the deployed process. */
            tenantId: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this process. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
        };
        /** @description A deployed decision. */
        DeploymentDecisionResult: {
            /**
             * @description The dmn decision ID, as parsed during deployment, together with the version forms a
             *     unique identifier for a specific decision.
             */
            decisionDefinitionId?: components["schemas"]["DecisionDefinitionId"];
            /**
             * Format: int32
             * @description The assigned decision version.
             */
            version?: number;
            /** @description The DMN name of the decision, as parsed during deployment. */
            name?: string;
            /** @description The tenant ID of the deployed decision. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment. */
            decisionRequirementsId?: string;
            /** @description The assigned decision key, which acts as a unique identifier for this decision. */
            decisionDefinitionKey?: components["schemas"]["DecisionDefinitionKey"];
            /** @description The assigned key of the decision requirements graph that this decision is part of. */
            decisionRequirementsKey?: components["schemas"]["DecisionRequirementsKey"];
        };
        /** @description Deployed decision requirements. */
        DeploymentDecisionRequirementsResult: {
            decisionRequirementsId?: string;
            decisionRequirementsName?: string;
            /** Format: int32 */
            version?: number;
            resourceName?: string;
            /** @description The tenant ID of the deployed decision requirements. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned decision requirements key, which acts as a unique identifier for this decision requirements. */
            decisionRequirementsKey?: components["schemas"]["DecisionRequirementsKey"];
        };
        /**
         * Format: FormId
         * @description The user-defined id for the form
         * @example Form_1nx5hav
         */
        FormId: string;
        /**
         * Format: FormKey
         * @description System-generated key for a deployed form.
         * @example 2251799813684365
         */
        FormKey: string & components["schemas"]["LongKey"];
        /** @description A deployed form. */
        DeploymentFormResult: {
            /**
             * @description The form ID, as parsed during deployment, together with the version forms a
             *     unique identifier for a specific form.
             */
            formId?: components["schemas"]["FormId"];
            /** Format: int32 */
            version?: number;
            resourceName?: string;
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this form. */
            formKey?: components["schemas"]["FormKey"];
        };
        /**
         * Format: ResourceKey
         * @description The system-assigned key for this resource.
         */
        ResourceKey: string & (components["schemas"]["ProcessDefinitionKey"] | components["schemas"]["DecisionRequirementsKey"] | components["schemas"]["FormKey"] | components["schemas"]["DecisionDefinitionKey"]);
        /** @description A deployed Resource. */
        DeploymentResourceResult: {
            resourceId?: string;
            resourceName?: string;
            /** Format: int32 */
            version?: number;
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this Resource. */
            resourceKey?: components["schemas"]["ResourceKey"];
        };
        DeploymentMetadataResult: {
            processDefinition?: components["schemas"]["DeploymentProcessResult"];
            decisionDefinition?: components["schemas"]["DeploymentDecisionResult"];
            decisionRequirements?: components["schemas"]["DeploymentDecisionRequirementsResult"];
            form?: components["schemas"]["DeploymentFormResult"];
            resource?: components["schemas"]["DeploymentResourceResult"];
        };
        DeploymentResult: {
            /** @description The unique key identifying the deployment. */
            deploymentKey: components["schemas"]["DeploymentKey"];
            /** @description The tenant ID associated with the deployment. */
            tenantId: components["schemas"]["TenantId"];
            /** @description Items deployed by the request. */
            deployments: components["schemas"]["DeploymentMetadataResult"][];
        };
        /**
         * Format: DocumentId
         * @description Document Id that uniquely identifies a document.
         */
        DocumentId: string;
        /** @description Information about the document. */
        DocumentMetadata: {
            /** @description The content type of the document. */
            contentType?: string;
            /** @description The name of the file. */
            fileName?: string;
            /**
             * Format: date-time
             * @description The date and time when the document expires.
             */
            expiresAt?: string;
            /**
             * Format: int64
             * @description The size of the document in bytes.
             */
            size?: number;
            /** @description The ID of the process definition that created the document. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description The key of the process instance that created the document. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description Custom properties of the document. */
            customProperties?: {
                [key: string]: unknown;
            };
        };
        DocumentReference: {
            /**
             * @description Document discriminator. Always set to "camunda".
             * @enum {string}
             */
            "camunda.document.type"?: "camunda";
            /** @description The ID of the document store. */
            storeId?: string;
            /** @description The ID of the document. */
            documentId?: components["schemas"]["DocumentId"];
            /** @description The hash of the document. */
            contentHash?: string;
            metadata?: components["schemas"]["DocumentMetadata"];
        };
        DocumentCreationFailureDetail: {
            /** @description The name of the file that failed to upload. */
            fileName?: string;
            /**
             * Format: int32
             * @description The HTTP status code of the failure.
             */
            status?: number;
            /** @description A short, human-readable summary of the problem type. */
            title?: string;
            /** @description A human-readable explanation specific to this occurrence of the problem. */
            detail?: string;
        };
        DocumentCreationBatchResponse: {
            /** @description Documents that were successfully created. */
            failedDocuments?: components["schemas"]["DocumentCreationFailureDetail"][];
            /** @description Documents that failed creation. */
            createdDocuments?: components["schemas"]["DocumentReference"][];
        };
        DocumentLinkRequest: {
            /**
             * Format: int64
             * @description The time-to-live of the document link in ms.
             * @default 3600000
             */
            timeToLive: number;
        };
        DocumentLink: {
            /** @description The link to the document. */
            url?: string;
            /**
             * Format: date-time
             * @description The date and time when the link expires.
             */
            expiresAt?: string;
        };
        /**
         * Format: ElementId
         * @description The model-defined id of an element.
         * @example Activity_106kosb
         */
        ElementId: string;
        AdHocSubProcessActivateActivityReference: {
            /** @description The ID of the element that should be activated. */
            elementId: components["schemas"]["ElementId"];
            /** @description Variables to be set when activating the element. */
            variables?: {
                [key: string]: unknown;
            };
        };
        AdHocSubProcessActivateActivitiesInstruction: {
            /** @description Activities to activate. */
            elements: components["schemas"]["AdHocSubProcessActivateActivityReference"][];
            /**
             * @description Whether to cancel remaining instances of the ad-hoc sub-process.
             * @default false
             */
            cancelRemainingInstances: boolean;
        };
        ElementInstanceSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "elementInstanceKey" | "processInstanceKey" | "processDefinitionKey" | "processDefinitionId" | "startDate" | "endDate" | "elementId" | "elementName" | "type" | "state" | "incidentKey" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * @description Element states
         * @enum {string}
         */
        ElementInstanceStateEnum: "ACTIVE" | "COMPLETED" | "TERMINATED";
        /**
         * Advanced filter
         * @description Advanced ElementInstanceStateEnum filter.
         */
        AdvancedElementInstanceStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["ElementInstanceStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["ElementInstanceStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["ElementInstanceStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description ElementInstanceStateEnum property with full advanced search capabilities. */
        ElementInstanceStateFilterProperty: (string & components["schemas"]["ElementInstanceStateEnum"]) | components["schemas"]["AdvancedElementInstanceStateFilter"];
        /**
         * Format: IncidentKey
         * @description System-generated key for a incident.
         * @example 2251799813689432
         */
        IncidentKey: string & components["schemas"]["LongKey"];
        /** @description Element instance filter. */
        ElementInstanceFilter: {
            /** @description The process definition ID associated to this element instance. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description State of element instance as defined set of values. */
            state?: components["schemas"]["ElementInstanceStateFilterProperty"];
            /**
             * @description Type of element as defined set of values.
             * @enum {string}
             */
            type?: "UNSPECIFIED" | "PROCESS" | "SUB_PROCESS" | "EVENT_SUB_PROCESS" | "AD_HOC_SUB_PROCESS" | "AD_HOC_SUB_PROCESS_INNER_INSTANCE" | "START_EVENT" | "INTERMEDIATE_CATCH_EVENT" | "INTERMEDIATE_THROW_EVENT" | "BOUNDARY_EVENT" | "END_EVENT" | "SERVICE_TASK" | "RECEIVE_TASK" | "USER_TASK" | "MANUAL_TASK" | "TASK" | "EXCLUSIVE_GATEWAY" | "INCLUSIVE_GATEWAY" | "PARALLEL_GATEWAY" | "EVENT_BASED_GATEWAY" | "SEQUENCE_FLOW" | "MULTI_INSTANCE_BODY" | "CALL_ACTIVITY" | "BUSINESS_RULE_TASK" | "SCRIPT_TASK" | "SEND_TASK" | "UNKNOWN";
            /** @description The element ID for this element instance. */
            elementId?: components["schemas"]["ElementId"];
            /** @description The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found. */
            elementName?: string;
            /** @description Shows whether this element instance has an incident related to. */
            hasIncident?: boolean;
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this element instance. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            /** @description The process instance key associated to this element instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The process definition key associated to this element instance. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The key of incident if field incident is true. */
            incidentKey?: components["schemas"]["IncidentKey"];
            /** @description The start date of this element instance. */
            startDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The end date of this element instance. */
            endDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance. */
            elementInstanceScopeKey?: string & (components["schemas"]["ElementInstanceKey"] | components["schemas"]["ProcessInstanceKey"]);
        };
        /** @description Element instance search request. */
        ElementInstanceSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["ElementInstanceSearchQuerySortRequest"][];
            /** @description The element instance search filters. */
            filter?: components["schemas"]["ElementInstanceFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        ElementInstanceResult: {
            /** @description The process definition ID associated to this element instance. */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /**
             * Format: date-time
             * @description Date when element instance started.
             */
            startDate: string;
            /**
             * Format: date-time
             * @description Date when element instance finished.
             */
            endDate?: string;
            /** @description The element ID for this element instance. */
            elementId: components["schemas"]["ElementId"];
            /** @description The element name for this element instance. */
            elementName: string;
            /**
             * @description Type of element as defined set of values.
             * @enum {string}
             */
            type: "UNSPECIFIED" | "PROCESS" | "SUB_PROCESS" | "EVENT_SUB_PROCESS" | "AD_HOC_SUB_PROCESS" | "AD_HOC_SUB_PROCESS_INNER_INSTANCE" | "START_EVENT" | "INTERMEDIATE_CATCH_EVENT" | "INTERMEDIATE_THROW_EVENT" | "BOUNDARY_EVENT" | "END_EVENT" | "SERVICE_TASK" | "RECEIVE_TASK" | "USER_TASK" | "MANUAL_TASK" | "TASK" | "EXCLUSIVE_GATEWAY" | "INCLUSIVE_GATEWAY" | "PARALLEL_GATEWAY" | "EVENT_BASED_GATEWAY" | "SEQUENCE_FLOW" | "MULTI_INSTANCE_BODY" | "CALL_ACTIVITY" | "BUSINESS_RULE_TASK" | "SCRIPT_TASK" | "SEND_TASK" | "UNKNOWN";
            /** @description State of element instance as defined set of values. */
            state: components["schemas"]["ElementInstanceStateEnum"];
            /** @description Shows whether this element instance has an incident. If true also an incidentKey is provided. */
            hasIncident: boolean;
            /** @description The tenant ID of the incident. */
            tenantId: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this element instance. */
            elementInstanceKey: components["schemas"]["ElementInstanceKey"];
            /** @description The process instance key associated to this element instance. */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            /** @description The process definition key associated to this element instance. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description Incident key associated with this element instance. */
            incidentKey?: components["schemas"]["IncidentKey"];
        };
        ElementInstanceSearchQueryResult: {
            /** @description The matching element instances. */
            items?: components["schemas"]["ElementInstanceResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        IncidentSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "incidentKey" | "processDefinitionKey" | "processDefinitionId" | "processInstanceKey" | "errorType" | "errorMessage" | "elementId" | "elementInstanceKey" | "creationTime" | "state" | "jobKey" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        ElementInstanceIncidentSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["IncidentSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        /**
         * @description Incident error type with a defined set of values.
         * @enum {unknown}
         */
        IncidentErrorTypeEnum: "AD_HOC_SUB_PROCESS_NO_RETRIES" | "CALLED_DECISION_ERROR" | "CALLED_ELEMENT_ERROR" | "CONDITION_ERROR" | "DECISION_EVALUATION_ERROR" | "EXECUTION_LISTENER_NO_RETRIES" | "EXTRACT_VALUE_ERROR" | "FORM_NOT_FOUND" | "IO_MAPPING_ERROR" | "JOB_NO_RETRIES" | "MESSAGE_SIZE_EXCEEDED" | "RESOURCE_NOT_FOUND" | "TASK_LISTENER_NO_RETRIES" | "UNHANDLED_ERROR_EVENT" | "UNKNOWN" | "UNSPECIFIED";
        /**
         * @description Incident states with a defined set of values.
         * @enum {unknown}
         */
        IncidentStateEnum: "ACTIVE" | "MIGRATED" | "PENDING" | "RESOLVED";
        /**
         * Format: JobKey
         * @description System-generated key for a job.
         * @example 2251799813653498
         */
        JobKey: string & components["schemas"]["LongKey"];
        IncidentResult: {
            /** @description The process definition ID associated to this incident. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            errorType?: components["schemas"]["IncidentErrorTypeEnum"];
            /** @description Error message which describes the error in more detail. */
            errorMessage?: string;
            /** @description The element ID associated to this incident. */
            elementId?: components["schemas"]["ElementId"];
            /** Format: date-time */
            creationTime?: string;
            state?: components["schemas"]["IncidentStateEnum"];
            /** @description The tenant ID of the incident. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The assigned key, which acts as a unique identifier for this incident. */
            incidentKey?: components["schemas"]["IncidentKey"];
            /** @description The process definition key associated to this incident. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The process instance key associated to this incident. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The element instance key associated to this incident. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            /** @description The job key, if exists, associated with this incident. */
            jobKey?: components["schemas"]["JobKey"];
        };
        IncidentSearchQueryResult: {
            /** @description The matching incidents. */
            items?: components["schemas"]["IncidentResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /**
         * Format: int64
         * @description A reference key chosen by the user that will be part of all records resulting from this operation.
         *     Must be > 0 if provided.
         */
        OperationReference: number;
        SetVariableRequest: {
            /** @description JSON object representing the variables to set in the elements scope. */
            variables: {
                [key: string]: unknown;
            };
            /**
             * @description If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
             *     Otherwise, the variables are propagated to upper scopes and set at the outermost one.
             *     Lets consider the following example:
             *     There are two scopes '1' and '2'.
             *     Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
             *     1 => { "foo" : 2 }
             *     2 => { "bar" : 1 }
             *     An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
             *     to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
             *     By default, with local set to false, scope '1' will be { "foo": 5 }
             *     and scope '2' will be { "bar" : 1 }.
             * @default false
             */
            local: boolean;
            operationReference?: components["schemas"]["OperationReference"];
        };
        GroupCreateRequest: {
            /** @description The ID of the new group. */
            groupId: string;
            /** @description The display name of the new group. */
            name: string;
            /** @description The description of the new group. */
            description?: string;
        };
        GroupCreateResult: {
            /** @description The ID of the created group. */
            groupId?: string;
            /** @description The display name of the created group. */
            name?: string;
            /** @description The description of the created group. */
            description?: string;
        };
        GroupSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "name" | "groupId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Group filter request */
        GroupFilter: {
            /** @description The group ID search filters. */
            groupId?: components["schemas"]["StringFilterProperty"];
            /** @description The group name search filters. */
            name?: string;
        };
        /** @description Group search request. */
        GroupSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["GroupSearchQuerySortRequest"][];
            /** @description The group search filters. */
            filter?: components["schemas"]["GroupFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /** @description Group search response item. */
        GroupResult: {
            /** @description The group name. */
            name?: string;
            /** @description The group ID. */
            groupId?: string;
            /** @description The group description. */
            description?: string;
        };
        /** @description Group search response. */
        GroupSearchQueryResult: {
            /** @description The matching groups. */
            items?: components["schemas"]["GroupResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        GroupUpdateRequest: {
            /** @description The new name of the group. */
            name: string;
            /** @description The new description of the group. */
            description: string;
        };
        GroupUpdateResult: {
            /** @description The unique external group ID. */
            groupId?: string;
            /** @description The name of the group. */
            name?: string;
            /** @description The description of the group. */
            description?: string;
        };
        GroupClientSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "clientId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        GroupClientSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["GroupClientSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        GroupClientResult: {
            /** @description The ID of the client. */
            clientId?: string;
        };
        GroupClientSearchResult: {
            /** @description The matching client IDs. */
            items?: components["schemas"]["GroupClientResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        GroupUserSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "username";
            order?: components["schemas"]["SortOrderEnum"];
        };
        GroupUserSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["GroupUserSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        GroupUserResult: {
            username?: components["schemas"]["Username"];
        };
        GroupUserSearchResult: {
            /** @description The matching members. */
            items?: components["schemas"]["GroupUserResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /**
         * Advanced filter
         * @description Advanced IncidentErrorTypeEnum filter
         */
        AdvancedIncidentErrorTypeFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["IncidentErrorTypeEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["IncidentErrorTypeEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["IncidentErrorTypeEnum"][];
            /** @description Checks if the property does not match any of the provided values. */
            $notIn?: components["schemas"]["IncidentErrorTypeEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description IncidentErrorTypeEnum with full advanced search capabilities. */
        IncidentErrorTypeFilterProperty: (string & components["schemas"]["IncidentErrorTypeEnum"]) | components["schemas"]["AdvancedIncidentErrorTypeFilter"];
        /**
         * Advanced filter
         * @description Advanced IncidentStateEnum filter
         */
        AdvancedIncidentStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["IncidentStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["IncidentStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["IncidentStateEnum"][];
            /** @description Checks if the property does not match any of the provided values. */
            $notIn?: components["schemas"]["IncidentStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description IncidentStateEnum with full advanced search capabilities. */
        IncidentStateFilterProperty: (string & components["schemas"]["IncidentStateEnum"]) | components["schemas"]["AdvancedIncidentStateFilter"];
        /**
         * Advanced filter
         * @description Advanced JobKey filter.
         */
        AdvancedJobKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["JobKey"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["JobKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["JobKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["JobKey"][];
        };
        /** @description JobKey property with full advanced search capabilities. */
        JobKeyFilterProperty: string | components["schemas"]["AdvancedJobKeyFilter"];
        /** @description Incident search filter. */
        IncidentFilter: {
            /** @description The process definition ID associated to this incident. */
            processDefinitionId?: components["schemas"]["StringFilterProperty"];
            /** @description Incident error type with a defined set of values. */
            errorType?: components["schemas"]["IncidentErrorTypeFilterProperty"];
            errorMessage?: components["schemas"]["StringFilterProperty"];
            /** @description The element ID associated to this incident. */
            elementId?: components["schemas"]["StringFilterProperty"];
            /** @description Date of incident creation. */
            creationTime?: components["schemas"]["DateTimeFilterProperty"];
            /** @description State of this incident with a defined set of values. */
            state?: components["schemas"]["IncidentStateFilterProperty"];
            /** @description The tenant ID of the incident. */
            tenantId?: components["schemas"]["StringFilterProperty"];
            /** @description The assigned key, which acts as a unique identifier for this incident. */
            incidentKey?: components["schemas"]["BasicStringFilterProperty"];
            /** @description The process definition key associated to this incident. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKeyFilterProperty"];
            /** @description The process instance key associated to this incident. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The element instance key associated to this incident. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKeyFilterProperty"];
            /** @description The job key, if exists, associated with this incident. */
            jobKey?: components["schemas"]["JobKeyFilterProperty"];
        };
        IncidentSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["IncidentSearchQuerySortRequest"][];
            /** @description The incident search filters. */
            filter?: components["schemas"]["IncidentFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        IncidentResolutionRequest: {
            operationReference?: components["schemas"]["OperationReference"];
        };
        JobActivationRequest: {
            /**
             * @description The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />)
             * @example create-new-user-record
             */
            type: string;
            /**
             * @description The name of the worker activating the jobs, mostly used for logging purposes.
             * @example worker-324
             */
            worker?: string;
            /**
             * Format: int64
             * @description A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.
             * @example 20000
             */
            timeout: number;
            /**
             * Format: int32
             * @description The maximum jobs to activate by this request.
             * @example 5
             */
            maxJobsToActivate: number;
            /**
             * @description A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.
             * @example [
             *       "firstName",
             *       "lastName",
             *       "email"
             *     ]
             */
            fetchVariable?: string[];
            /**
             * Format: int64
             * @description The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
             * @example 60000
             */
            requestTimeout?: number;
            /** @description A list of IDs of tenants for which to activate jobs. */
            tenantIds?: components["schemas"]["TenantId"][];
        };
        /**
         * @description The job kind.
         * @example BPMN_ELEMENT
         * @enum {string}
         */
        JobKindEnum: "BPMN_ELEMENT" | "EXECUTION_LISTENER" | "TASK_LISTENER" | "AD_HOC_SUB_PROCESS";
        /**
         * @description The listener event type of the job.
         * @example UNSPECIFIED
         * @enum {string}
         */
        JobListenerEventTypeEnum: "ASSIGNING" | "CANCELING" | "COMPLETING" | "CREATING" | "END" | "START" | "UNSPECIFIED" | "UPDATING";
        /**
         * Format: UserTaskKey
         * @description System-generated key for a user task.
         */
        UserTaskKey: string & components["schemas"]["LongKey"];
        /** @description Contains properties of a user task. */
        UserTaskProperties: {
            /** @description The action performed on the user task. */
            action?: string;
            /** @description The user assigned to the task. */
            assignee?: string | null;
            /** @description The groups eligible to claim the task. */
            candidateGroups?: string[];
            /** @description The users eligible to claim the task. */
            candidateUsers?: string[];
            /** @description The attributes that were changed in the task. */
            changedAttributes?: string[];
            /** @description The due date of the user task in ISO 8601 format. */
            dueDate?: string | null;
            /** @description The follow-up date of the user task in ISO 8601 format. */
            followUpDate?: string | null;
            /** @description The key of the form associated with the user task. */
            formKey?: components["schemas"]["FormKey"];
            /**
             * Format: int32
             * @description The priority of the user task.
             */
            priority?: number | null;
            /** @description The unique key identifying the user task. */
            userTaskKey?: components["schemas"]["UserTaskKey"] | null;
        };
        /**
         * Format: Tag
         * @description A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
         * @example business_key:1234
         */
        Tag: string;
        /**
         * Format: string<Tag>[]
         * @description List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
         * @example [
         *       "high-touch",
         *       "remediation"
         *     ]
         */
        TagSet: components["schemas"]["Tag"][];
        ActivatedJobResult: {
            /**
             * @description The type of the job (should match what was requested).
             * @example create-new-user-record
             */
            type: string;
            /** @description The bpmn process ID of the job's process definition. */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /**
             * Format: int32
             * @description The version of the job's process definition.
             * @example 1
             */
            processDefinitionVersion: number;
            /** @description The associated task element ID. */
            elementId: components["schemas"]["ElementId"];
            /**
             * @description A set of custom headers defined during modelling; returned as a serialized JSON document.
             * @example {}
             */
            customHeaders: {
                [key: string]: unknown;
            };
            /**
             * @description The name of the worker which activated this job.
             * @example worker-324
             */
            worker: string;
            /**
             * Format: int32
             * @description The amount of retries left to this job (should always be positive).
             * @example 3
             */
            retries: number;
            /**
             * Format: int64
             * @description When the job can be activated again, sent as a UNIX epoch timestamp.
             * @example 1757280974277
             */
            deadline: number;
            /** @description All variables visible to the task scope, computed at activation time. */
            variables: {
                [key: string]: unknown;
            };
            /** @description The ID of the tenant that owns the job. */
            tenantId: components["schemas"]["TenantId"];
            /** @description The key, a unique identifier for the job. */
            jobKey: components["schemas"]["JobKey"];
            /** @description The job's process instance key. */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            /** @description The key of the job's process definition. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            elementInstanceKey: components["schemas"]["ElementInstanceKey"];
            kind: components["schemas"]["JobKindEnum"];
            listenerEventType: components["schemas"]["JobListenerEventTypeEnum"];
            userTask?: components["schemas"]["UserTaskProperties"];
            tags?: components["schemas"]["TagSet"];
        };
        /** @description The list of activated jobs */
        JobActivationResult: {
            /** @description The activated jobs. */
            jobs: components["schemas"]["ActivatedJobResult"][];
        };
        JobSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "deadline" | "deniedReason" | "elementId" | "elementInstanceKey" | "endTime" | "errorCode" | "errorMessage" | "hasFailedWithRetriesLeft" | "isDenied" | "jobKey" | "kind" | "listenerEventType" | "processDefinitionId" | "processDefinitionKey" | "processInstanceKey" | "retries" | "state" | "tenantId" | "type" | "worker";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * Advanced filter
         * @description Advanced JobKindEnum filter.
         */
        AdvancedJobKindFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["JobKindEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["JobKindEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["JobKindEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description JobKindEnum property with full advanced search capabilities. */
        JobKindFilterProperty: (string & components["schemas"]["JobKindEnum"]) | components["schemas"]["AdvancedJobKindFilter"];
        /**
         * Advanced filter
         * @description Advanced JobListenerEventTypeEnum filter.
         */
        AdvancedJobListenerEventTypeFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["JobListenerEventTypeEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["JobListenerEventTypeEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["JobListenerEventTypeEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description JobListenerEventTypeEnum property with full advanced search capabilities. */
        JobListenerEventTypeFilterProperty: (string & components["schemas"]["JobListenerEventTypeEnum"]) | components["schemas"]["AdvancedJobListenerEventTypeFilter"];
        /**
         * @description The state of the job.
         * @enum {string}
         */
        JobStateEnum: "CANCELED" | "COMPLETED" | "CREATED" | "ERROR_THROWN" | "FAILED" | "MIGRATED" | "RETRIES_UPDATED" | "TIMED_OUT";
        /**
         * Advanced filter
         * @description Advanced JobStateEnum filter.
         */
        AdvancedJobStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["JobStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["JobStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["JobStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description JobStateEnum property with full advanced search capabilities. */
        JobStateFilterProperty: (string & components["schemas"]["JobStateEnum"]) | components["schemas"]["AdvancedJobStateFilter"];
        /** @description Job search filter. */
        JobFilter: {
            /** @description When the job can next be activated. */
            deadline?: components["schemas"]["DateTimeFilterProperty"] | null;
            /** @description The reason provided by the user task listener for denying the work. */
            deniedReason?: components["schemas"]["StringFilterProperty"];
            /** @description The element ID associated with the job. */
            elementId?: components["schemas"]["StringFilterProperty"];
            /** @description The element instance key associated with the job. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKeyFilterProperty"];
            /** @description When the job ended. */
            endTime?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The error code provided for the failed job. */
            errorCode?: components["schemas"]["StringFilterProperty"];
            /** @description The error message that provides additional context for a failed job. */
            errorMessage?: components["schemas"]["StringFilterProperty"];
            /** @description Indicates whether the job has failed with retries left. */
            hasFailedWithRetriesLeft?: boolean;
            /** @description Indicates whether the user task listener denies the work. */
            isDenied?: boolean | null;
            /** @description The key, a unique identifier for the job. */
            jobKey?: components["schemas"]["JobKeyFilterProperty"];
            /** @description The kind of the job. */
            kind?: components["schemas"]["JobKindFilterProperty"];
            /** @description The listener event type of the job. */
            listenerEventType?: components["schemas"]["JobListenerEventTypeFilterProperty"];
            /** @description The process definition ID associated with the job. */
            processDefinitionId?: components["schemas"]["StringFilterProperty"];
            /** @description The process definition key associated with the job. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKeyFilterProperty"];
            /** @description The process instance key associated with the job. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The number of retries left. */
            retries?: components["schemas"]["IntegerFilterProperty"];
            /** @description The state of the job. */
            state?: components["schemas"]["JobStateFilterProperty"];
            /** @description The tenant ID. */
            tenantId?: components["schemas"]["StringFilterProperty"];
            /** @description The type of the job. */
            type?: components["schemas"]["StringFilterProperty"];
            /** @description The name of the worker for this job. */
            worker?: components["schemas"]["StringFilterProperty"];
        };
        /** @description Job search request. */
        JobSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["JobSearchQuerySortRequest"][];
            /** @description The job search filters. */
            filter?: components["schemas"]["JobFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        JobSearchResult: {
            /** @description A set of custom headers defined during modelling. */
            customHeaders: {
                [key: string]: string;
            };
            /**
             * Format: date-time
             * @description If the job has been activated, when it will next be available to be activated.
             */
            deadline?: string | null;
            /** @description The reason provided by the user task listener for denying the work. */
            deniedReason?: string | null;
            /** @description The element ID associated with the job. */
            elementId: components["schemas"]["ElementId"];
            /** @description The element instance key associated with the job. */
            elementInstanceKey: components["schemas"]["ElementInstanceKey"];
            /**
             * Format: date-time
             * @description When the job ended.
             */
            endTime?: string;
            /** @description The error code provided for a failed job. */
            errorCode?: string | null;
            /** @description The error message that provides additional context for a failed job. */
            errorMessage?: string | null;
            /** @description Indicates whether the job has failed with retries left. */
            hasFailedWithRetriesLeft: boolean;
            /** @description Indicates whether the user task listener denies the work. */
            isDenied?: boolean | null;
            /** @description The key, a unique identifier for the job. */
            jobKey: components["schemas"]["JobKey"];
            kind: components["schemas"]["JobKindEnum"];
            listenerEventType: components["schemas"]["JobListenerEventTypeEnum"];
            /** @description The process definition ID associated with the job. */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /** @description The process definition key associated with the job. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description The process instance key associated with the job. */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            /**
             * Format: int32
             * @description The amount of retries left to this job.
             */
            retries: number;
            state: components["schemas"]["JobStateEnum"];
            tenantId: components["schemas"]["TenantId"];
            /** @description The type of the job. */
            type: string;
            /** @description The name of the worker of this job. */
            worker: string;
        };
        /** @description Job search response. */
        JobSearchQueryResult: {
            /** @description The matching jobs. */
            items?: components["schemas"]["JobSearchResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /** @description JSON object with changed job attribute values. The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead. */
        JobChangeset: {
            /**
             * Format: int32
             * @description The new number of retries for the job.
             */
            retries?: number | null;
            /**
             * Format: int64
             * @description The new timeout for the job in milliseconds.
             */
            timeout?: number | null;
        };
        JobUpdateRequest: {
            changeset: components["schemas"]["JobChangeset"];
            operationReference?: components["schemas"]["OperationReference"];
        };
        /**
         * @description JSON object with attributes that were corrected by the worker.
         *
         *     The following attributes can be corrected, additional attributes will be ignored:
         *
         *     * `assignee` - clear by providing an empty String
         *     * `dueDate` - clear by providing an empty String
         *     * `followUpDate` - clear by providing an empty String
         *     * `candidateGroups` - clear by providing an empty list
         *     * `candidateUsers` - clear by providing an empty list
         *     * `priority` - minimum 0, maximum 100, default 50
         *
         *     Providing any of those attributes with a `null` value or omitting it preserves
         *     the persisted attribute's value.
         */
        JobResultCorrections: {
            /** @description Assignee of the task. */
            assignee?: string | null;
            /**
             * Format: date-time
             * @description The due date of the task.
             */
            dueDate?: string | null;
            /**
             * Format: date-time
             * @description The follow-up date of the task.
             */
            followUpDate?: string | null;
            /** @description The list of candidate users of the task. */
            candidateUsers?: string[] | null;
            /** @description The list of candidate groups of the task. */
            candidateGroups?: string[] | null;
            /**
             * Format: int32
             * @description The priority of the task.
             */
            priority?: number | null;
        } | null;
        /** @description Job result details for a user task completion, optionally including a denial reason and corrected task properties. */
        JobResultUserTask: {
            /** @description Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false. */
            denied?: boolean | null;
            /** @description The reason provided by the user task listener for denying the work. */
            deniedReason?: string | null;
            corrections?: components["schemas"]["JobResultCorrections"];
            /**
             * @description Used to distinguish between different types of job results. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "userTask";
        } | null;
        /** @description Instruction to activate a single BPMN element within an adhoc subprocess, optionally providing variables scoped to that element. */
        JobResultActivateElement: {
            /** @description The element ID to activate. */
            elementId?: components["schemas"]["ElementId"];
            /** @description Variables for the element. */
            variables?: {
                [key: string]: unknown;
            };
        };
        /** @description Job result details for an adhoc subprocess, including elements to activate and flags indicating completion or cancellation behavior. */
        JobResultAdHocSubProcess: {
            /** @description Indicates which elements need to be activated in the ad-hoc subprocess. */
            activateElements?: components["schemas"]["JobResultActivateElement"][];
            /**
             * @description Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.
             * @default false
             */
            isCompletionConditionFulfilled: boolean;
            /**
             * @description Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.
             * @default false
             */
            isCancelRemainingInstances: boolean;
            /**
             * @description Used to distinguish between different types of job results. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "adHocSubProcess";
        } | null;
        /** @description The result of the completed job as determined by the worker. */
        JobResult: components["schemas"]["JobResultUserTask"] | components["schemas"]["JobResultAdHocSubProcess"];
        JobCompletionRequest: {
            /** @description The variables to complete the job with. */
            variables?: {
                [key: string]: unknown;
            } | null;
            result?: components["schemas"]["JobResult"];
        };
        JobErrorRequest: {
            /** @description The error code that will be matched with an error catch event. */
            errorCode: string;
            /** @description An error message that provides additional context. */
            errorMessage?: string | null;
            /** @description JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error. */
            variables?: {
                [key: string]: unknown;
            } | null;
        };
        JobFailRequest: {
            /**
             * Format: int32
             * @description The amount of retries the job should have left
             * @default 0
             */
            retries: number;
            /** @description An optional error message describing why the job failed; if not provided, an empty string is used. */
            errorMessage?: string;
            /**
             * Format: int64
             * @description An optional retry back off for the failed job. The job will not be retryable before the current time plus the back off time. The default is 0 which means the job is retryable immediately.
             * @default 0
             */
            retryBackOff: number;
            /** @description JSON object that will instantiate the variables at the local scope of the job's associated task. */
            variables?: {
                [key: string]: unknown;
            };
        };
        /** @description The response of a license request. */
        LicenseResponse: {
            /**
             * @description True if the Camunda license is valid, false if otherwise
             * @example true
             */
            validLicense: boolean;
            /**
             * @description Will return the license type property of the Camunda license
             * @example saas
             */
            licenseType: string;
            /** @description Will be false when a license contains a non-commerical=true property */
            isCommercial: boolean;
            /**
             * Format: date-time
             * @description The date when the Camunda license expires
             */
            expiresAt?: string | null;
        };
        MappingRuleCreateUpdateRequest: {
            /** @description The name of the claim to map. */
            claimName: string;
            /** @description The value of the claim to map. */
            claimValue: string;
            /** @description The name of the mapping rule. */
            name: string;
        };
        MappingRuleCreateRequest: {
            /** @description The unique ID of the mapping rule. */
            mappingRuleId: string;
        } & components["schemas"]["MappingRuleCreateUpdateRequest"];
        MappingRuleCreateUpdateResult: {
            /** @description The name of the claim to map. */
            claimName?: string;
            /** @description The value of the claim to map. */
            claimValue?: string;
            /** @description The name of the mapping rule. */
            name?: string;
            /** @description The unique ID of the mapping rule. */
            mappingRuleId?: string;
        };
        MappingRuleCreateResult: components["schemas"]["MappingRuleCreateUpdateResult"];
        MappingRuleSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "mappingRuleId" | "claimName" | "claimValue" | "name";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Mapping rule search filter. */
        MappingRuleFilter: {
            /** @description The claim name to match against a token. */
            claimName?: string;
            /** @description The value of the claim to match. */
            claimValue?: string;
            /** @description The name of the mapping rule. */
            name?: string;
            /** @description The ID of the mapping rule. */
            mappingRuleId?: string;
        };
        MappingRuleSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["MappingRuleSearchQuerySortRequest"][];
            /** @description The mapping rule search filters. */
            filter?: components["schemas"]["MappingRuleFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        MappingRuleResult: {
            /** @description The name of the claim to map. */
            claimName?: string;
            /** @description The value of the claim to map. */
            claimValue?: string;
            /** @description The name of the mapping rule. */
            name?: string;
            /** @description The ID of the mapping rule. */
            mappingRuleId?: string;
        };
        MappingRuleSearchQueryResult: {
            /** @description The matching mapping rules. */
            items?: components["schemas"]["MappingRuleResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        MappingRuleUpdateRequest: components["schemas"]["MappingRuleCreateUpdateRequest"];
        MappingRuleUpdateResult: components["schemas"]["MappingRuleCreateUpdateResult"];
        MessageSubscriptionSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "messageSubscriptionKey" | "processDefinitionId" | "processInstanceKey" | "elementId" | "elementInstanceKey" | "messageSubscriptionState" | "lastUpdatedDate" | "messageName" | "correlationKey" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * @description The state of message subscription.
         * @enum {string}
         */
        MessageSubscriptionStateEnum: "CORRELATED" | "CREATED" | "DELETED" | "MIGRATED";
        /**
         * Advanced filter
         * @description Advanced MessageSubscriptionStateEnum filter
         */
        AdvancedMessageSubscriptionStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["MessageSubscriptionStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["MessageSubscriptionStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["MessageSubscriptionStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description MessageSubscriptionStateEnum with full advanced search capabilities. */
        MessageSubscriptionStateFilterProperty: (string & components["schemas"]["MessageSubscriptionStateEnum"]) | components["schemas"]["AdvancedMessageSubscriptionStateFilter"];
        /** @description Message subscription search filter. */
        MessageSubscriptionFilter: {
            /** @description The message subscription key associated with this message subscription. */
            messageSubscriptionKey?: components["schemas"]["MessageSubscriptionKeyFilterProperty"];
            /** @description The process definition key associated with this correlated message subscription. This only works for data created with 8.9 and later. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKeyFilterProperty"];
            /** @description The process definition ID associated with this message subscription. */
            processDefinitionId?: components["schemas"]["StringFilterProperty"];
            /** @description The process instance key associated with this message subscription. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The element ID associated with this message subscription. */
            elementId?: components["schemas"]["StringFilterProperty"];
            /** @description The element instance key associated with this message subscription. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKeyFilterProperty"];
            /** @description The message subscription state. */
            messageSubscriptionState?: components["schemas"]["MessageSubscriptionStateFilterProperty"];
            /** @description The last updated date of the message subscription. */
            lastUpdatedDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The name of the message associated with the message subscription. */
            messageName?: components["schemas"]["StringFilterProperty"];
            /** @description The correlation key of the message subscription. */
            correlationKey?: components["schemas"]["StringFilterProperty"];
            /** @description The unique external tenant ID. */
            tenantId?: components["schemas"]["StringFilterProperty"];
        };
        MessageSubscriptionSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["MessageSubscriptionSearchQuerySortRequest"][];
            /** @description The incident search filters. */
            filter?: components["schemas"]["MessageSubscriptionFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /**
         * Format: MessageCorrelationKey
         * @description System-generated key for a message correlation.
         * @example 2251799813634265
         */
        MessageCorrelationKey: string & components["schemas"]["LongKey"];
        MessageSubscriptionResult: {
            /** @description The message subscription key associated with this message subscription. */
            messageSubscriptionKey?: components["schemas"]["MessageSubscriptionKey"];
            /** @description The process definition ID associated with this message subscription. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description The process definition key associated with this message subscription. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The process instance key associated with this message subscription. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The element ID associated with this message subscription. */
            elementId?: components["schemas"]["ElementId"];
            /** @description The element instance key associated with this message subscription. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            messageSubscriptionState?: components["schemas"]["MessageSubscriptionStateEnum"];
            /**
             * Format: date-time
             * @description The last updated date of the message subscription.
             */
            lastUpdatedDate?: string;
            /** @description The name of the message associated with the message subscription. */
            messageName?: string;
            /** @description The correlation key of the message subscription. */
            correlationKey?: components["schemas"]["MessageCorrelationKey"];
            tenantId?: components["schemas"]["TenantId"];
        };
        MessageSubscriptionSearchQueryResult: {
            /** @description The matching message subscriptions. */
            items?: components["schemas"]["MessageSubscriptionResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        MessageCorrelationRequest: {
            /** @description The message name as defined in the BPMN process */
            name: string;
            /**
             * @description The correlation key of the message.
             * @default
             * @example customer-43421
             */
            correlationKey: string;
            /** @description The message variables as JSON document */
            variables?: {
                [key: string]: unknown;
            };
            /** @description the tenant for which the message is published */
            tenantId?: components["schemas"]["TenantId"];
        };
        /**
         * @description The message key of the correlated message, as well as the first process instance key it
         *     correlated with.
         */
        MessageCorrelationResult: {
            /** @description The tenant ID of the correlated message */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key of the correlated message. */
            messageKey?: components["schemas"]["MessageKey"];
            /** @description The key of the first process instance the message correlated with */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
        };
        MessagePublicationRequest: {
            /** @description The name of the message. */
            name: string;
            /**
             * @description The correlation key of the message.
             * @default
             * @example customer-43421
             */
            correlationKey: string;
            /**
             * Format: int64
             * @description Timespan (in ms) to buffer the message on the broker.
             * @default 0
             */
            timeToLive: number;
            /**
             * @description The unique ID of the message. This is used to ensure only one message with the given ID
             *     will be published during the lifetime of the message (if `timeToLive` is set).
             */
            messageId?: string;
            /** @description The message variables as JSON document. */
            variables?: {
                [key: string]: unknown;
            };
            /** @description The tenant of the message sender. */
            tenantId?: components["schemas"]["TenantId"];
        };
        /** @description The message key of the published message. */
        MessagePublicationResult: {
            /** @description The tenant ID of the message. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key of the published message. */
            messageKey?: components["schemas"]["MessageKey"];
        };
        ProcessDefinitionSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "processDefinitionKey" | "name" | "resourceName" | "version" | "versionTag" | "processDefinitionId" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Process definition search filter. */
        ProcessDefinitionFilter: {
            /** @description Name of this process definition. */
            name?: components["schemas"]["StringFilterProperty"];
            /**
             * @description Whether to only return the latest version of each process definition.
             *     When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
             *     The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
             */
            isLatestVersion?: boolean;
            /** @description Resource name of this process definition. */
            resourceName?: string;
            /**
             * Format: int32
             * @description Version of this process definition.
             */
            version?: number;
            /** @description Version tag of this process definition. */
            versionTag?: string;
            /** @description Process definition ID of this process definition. */
            processDefinitionId?: components["schemas"]["StringFilterProperty"];
            /** @description Tenant ID of this process definition. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key for this process definition. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description Indicates whether the start event of the process has an associated Form Key. */
            hasStartForm?: boolean;
        };
        ProcessDefinitionSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["ProcessDefinitionSearchQuerySortRequest"][];
            /** @description The process definition search filters. */
            filter?: components["schemas"]["ProcessDefinitionFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        ProcessDefinitionResult: {
            /** @description Name of this process definition. */
            name?: string;
            /** @description Resource name for this process definition. */
            resourceName?: string;
            /**
             * Format: int32
             * @description Version of this process definition.
             */
            version?: number;
            /** @description Version tag of this process definition. */
            versionTag?: string;
            /** @description Process definition ID of this process definition. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description Tenant ID of this process definition. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key for this process definition. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description Indicates whether the start event of the process has an associated Form Key. */
            hasStartForm?: boolean;
        };
        ProcessDefinitionSearchQueryResult: {
            /** @description The matching process definitions. */
            items?: components["schemas"]["ProcessDefinitionResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        ProcessDefinitionInstanceStatisticsPageRequest: {
            /**
             * Format: int32
             * @description The index of items to start searching from.
             */
            from?: number;
            /**
             * @description The maximum number of items to return in one request.
             * @default 100
             */
            limit: number;
        };
        ProcessDefinitionInstanceStatisticsQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "processDefinitionId" | "activeInstancesWithIncidentCount" | "activeInstancesWithoutIncidentCount";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * @description Process instance states
         * @enum {string}
         */
        ProcessInstanceStateEnum: "ACTIVE" | "COMPLETED" | "TERMINATED";
        /**
         * Advanced filter
         * @description Advanced ProcessInstanceStateEnum filter.
         */
        AdvancedProcessInstanceStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["ProcessInstanceStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["ProcessInstanceStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["ProcessInstanceStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description ProcessInstanceStateEnum property with full advanced search capabilities. */
        ProcessInstanceStateFilterProperty: (string & components["schemas"]["ProcessInstanceStateEnum"]) | components["schemas"]["AdvancedProcessInstanceStateFilter"];
        VariableValueFilterProperty: {
            /** @description Name of the variable. */
            name: string;
            /** @description The value of the variable. */
            value: components["schemas"]["StringFilterProperty"];
        };
        /** @description Base process instance search filter. */
        BaseProcessInstanceFilterFields: {
            /** @description The start date. */
            startDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The end date. */
            endDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The process instance state. */
            state?: components["schemas"]["ProcessInstanceStateFilterProperty"];
            /** @description Whether this process instance has a related incident or not. */
            hasIncident?: boolean;
            /** @description The tenant ID. */
            tenantId?: components["schemas"]["StringFilterProperty"];
            /** @description The process instance variables. */
            variables?: components["schemas"]["VariableValueFilterProperty"][];
            /** @description The key of this process instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The parent process instance key. */
            parentProcessInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
            /** @description The parent element instance key. */
            parentElementInstanceKey?: components["schemas"]["ElementInstanceKeyFilterProperty"];
            /** @description The batch operation ID. */
            batchOperationId?: components["schemas"]["StringFilterProperty"];
            /** @description The error message related to the process. */
            errorMessage?: components["schemas"]["StringFilterProperty"];
            /** @description Whether the process has failed jobs with retries left. */
            hasRetriesLeft?: boolean;
            /** @description The state of the element instances associated with the process instance. */
            elementInstanceState?: components["schemas"]["ElementInstanceStateFilterProperty"];
            /** @description The element ID associated with the process instance. */
            elementId?: components["schemas"]["StringFilterProperty"];
            /** @description Whether the element instance has an incident or not. */
            hasElementInstanceIncident?: boolean;
            /** @description The incident error hash code, associated with this process. */
            incidentErrorHashCode?: components["schemas"]["IntegerFilterProperty"];
            tags?: components["schemas"]["TagSet"];
        };
        /** @description Process instance search filter. */
        ProcessInstanceFilterFields: {
            /** @description The process definition ID. */
            processDefinitionId?: components["schemas"]["StringFilterProperty"];
            /** @description The process definition name. */
            processDefinitionName?: components["schemas"]["StringFilterProperty"];
            /** @description The process definition version. */
            processDefinitionVersion?: components["schemas"]["IntegerFilterProperty"];
            /** @description The process definition version tag. */
            processDefinitionVersionTag?: components["schemas"]["StringFilterProperty"];
            /** @description The process definition key. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKeyFilterProperty"];
        } & components["schemas"]["BaseProcessInstanceFilterFields"];
        /** @description Process instance search filter. */
        ProcessInstanceFilter: components["schemas"]["ProcessInstanceFilterFields"] & {
            /**
             * @description Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
             *
             *     Top-level fields and the `$or` clause are combined using AND logic  meaning: (top-level filters) AND (any of the `$or` filters) must match.
             *     <br>
             *     <em>Example:</em>
             *
             *     ```json
             *     {
             *       "state": "ACTIVE",
             *       "tenantId": 123,
             *       "$or": [
             *         { "processDefinitionId": "process_v1" },
             *         { "processDefinitionId": "process_v2", "hasIncident": true }
             *       ]
             *     }
             *     ```
             *     This matches process instances that:
             *
             *     <ul style="padding-left: 20px; margin-left: 20px;">
             *       <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
             *       <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
             *       <li style="list-style-type: disc;">and match either:
             *         <ul style="padding-left: 20px; margin-left: 20px;">
             *           <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
             *           <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
             *         </ul>
             *       </li>
             *     </ul>
             *     <br>
             *     <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
             */
            $or?: components["schemas"]["ProcessInstanceFilterFields"][];
        };
        ProcessDefinitionInstanceStatisticsQuery: {
            /** @description Pagination criteria. */
            page?: components["schemas"]["ProcessDefinitionInstanceStatisticsPageRequest"];
            /** @description Sort field criteria. */
            sort?: components["schemas"]["ProcessDefinitionInstanceStatisticsQuerySortRequest"][];
            /** @description The process definition instance statistics filters. */
            filter?: components["schemas"]["ProcessInstanceFilter"];
        };
        /** @description Process definition instance statistics response. */
        ProcessDefinitionInstanceStatisticsResult: {
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description Name of the latest deployed process definition instance version. */
            latestProcessDefinitionName?: string;
            /** @description Indicates whether multiple versions of this process definition instance are deployed. */
            hasMultipleVersions?: boolean;
            /**
             * Format: int64
             * @description Total number of currently active process instances of this definition that do not have incidents.
             */
            activeInstancesWithoutIncidentCount?: number;
            /**
             * Format: int64
             * @description Total number of currently active process instances of this definition that have at least one incident.
             */
            activeInstancesWithIncidentCount?: number;
        };
        /** @description Pagination information about the search results. */
        ProcessDefinitionInstanceStatisticsPageResponse: {
            /**
             * Format: int64
             * @description Total items matching the criteria.
             */
            totalItems?: number;
            /** @description Indicates whether there are more items matching the criteria. */
            hasMoreTotalItems?: boolean;
        };
        /** @description Process definition instance statistics query response. */
        ProcessDefinitionInstanceStatisticsQueryResult: {
            /** @description The process definition instance statistics result. */
            items?: components["schemas"]["ProcessDefinitionInstanceStatisticsResult"][];
            /** @description Pagination information about the search results. */
            page?: components["schemas"]["ProcessDefinitionInstanceStatisticsPageResponse"];
        };
        FormResult: {
            /** @description The tenant ID of the form. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The user-provided identifier of the form. */
            formId?: components["schemas"]["FormId"];
            /** @description The form content. */
            schema?: Record<string, never>;
            /**
             * Format: int64
             * @description The version of the the deployed form.
             */
            version?: number;
            /** @description The assigned key, which acts as a unique identifier for this form. */
            formKey?: components["schemas"]["FormKey"];
        };
        /** @description Process definition statistics search filter. */
        ProcessDefinitionStatisticsFilter: components["schemas"]["BaseProcessInstanceFilterFields"] & {
            /**
             * @description Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
             *
             *     Top-level fields and the `$or` clause are combined using AND logic  meaning: (top-level filters) AND (any of the `$or` filters) must match.
             *     <br>
             *     <em>Example:</em>
             *
             *     ```json
             *     {
             *       "state": "ACTIVE",
             *       "tenantId": 123,
             *       "$or": [
             *         { "processDefinitionId": "process_v1" },
             *         { "processDefinitionId": "process_v2", "hasIncident": true }
             *       ]
             *     }
             *     ```
             *     This matches process instances that:
             *
             *     <ul style="padding-left: 20px; margin-left: 20px;">
             *       <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
             *       <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
             *       <li style="list-style-type: disc;">and match either:
             *         <ul style="padding-left: 20px; margin-left: 20px;">
             *           <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
             *           <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
             *         </ul>
             *       </li>
             *     </ul>
             *     <br>
             *     <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
             */
            $or?: components["schemas"]["BaseProcessInstanceFilterFields"][];
        };
        /** @description Process definition element statistics request. */
        ProcessDefinitionElementStatisticsQuery: {
            /** @description The process definition statistics search filters. */
            filter?: components["schemas"]["ProcessDefinitionStatisticsFilter"];
        };
        /** @description Process element statistics response. */
        ProcessElementStatisticsResult: {
            /** @description The element ID for which the results are aggregated. */
            elementId?: components["schemas"]["ElementId"];
            /**
             * Format: int64
             * @description The total number of active instances of the element.
             */
            active?: number;
            /**
             * Format: int64
             * @description The total number of canceled instances of the element.
             */
            canceled?: number;
            /**
             * Format: int64
             * @description The total number of incidents for the element.
             */
            incidents?: number;
            /**
             * Format: int64
             * @description The total number of completed instances of the element.
             */
            completed?: number;
        };
        /** @description Process definition element statistics query response. */
        ProcessDefinitionElementStatisticsQueryResult: {
            /** @description The element statistics. */
            items?: components["schemas"]["ProcessElementStatisticsResult"][];
        };
        ProcessDefinitionInstanceVersionStatisticsQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "processDefinitionId" | "processDefinitionKey" | "processDefinitionName" | "processDefinitionVersion" | "activeInstancesWithIncidentCount" | "activeInstancesWithoutIncidentCount";
            order?: components["schemas"]["SortOrderEnum"];
        };
        ProcessDefinitionInstanceVersionStatisticsQuery: {
            /** @description Pagination criteria. */
            page?: components["schemas"]["ProcessDefinitionInstanceStatisticsPageRequest"];
            /** @description Sort field criteria. */
            sort?: components["schemas"]["ProcessDefinitionInstanceVersionStatisticsQuerySortRequest"][];
        };
        /** @description Process definition instance version statistics response. */
        ProcessDefinitionInstanceVersionStatisticsResult: {
            /** @description The ID associated with the process definition. */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /** @description The unique key of the process definition. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description The name of the process definition. */
            processDefinitionName: string;
            /**
             * Format: int32
             * @description The version number of the process definition.
             */
            processDefinitionVersion: number;
            /**
             * Format: int64
             * @description The number of active process instances for this version that currently have incidents.
             */
            activeInstancesWithIncidentCount: number;
            /**
             * Format: int64
             * @description The number of active process instances for this version that do not have any incidents.
             */
            activeInstancesWithoutIncidentCount: number;
        };
        /** @description Process definition instance version statistics query response. */
        ProcessDefinitionInstanceVersionStatisticsQueryResult: {
            /** @description The process definition instance version statistics result. */
            items?: components["schemas"]["ProcessDefinitionInstanceVersionStatisticsResult"][];
            /** @description Pagination information about the search results. */
            page?: components["schemas"]["ProcessDefinitionInstanceStatisticsPageResponse"];
        };
        ProcessInstanceCreationStartInstruction: {
            /**
             * @description Future extensions might include:
             *       - different types of start instructions
             *       - ability to set local variables for different flow scopes
             *
             *     For now, however, the start instruction is implicitly a "startBeforeElement" instruction
             */
            elementId: components["schemas"]["ElementId"];
        };
        /** @description Terminates the process instance after a specific BPMN element is completed or terminated. */
        ProcessInstanceCreationTerminateInstruction: {
            /**
             * @description The type of the runtime instruction (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "ProcessInstanceCreationTerminateInstruction";
            /**
             * @description The ID of the element that, once completed or terminated, will cause the process to be terminated.
             * @example Activity_106kb
             */
            afterElementId: components["schemas"]["ElementId"];
        };
        ProcessInstanceCreationRuntimeInstruction: components["schemas"]["ProcessInstanceCreationTerminateInstruction"];
        /** Process creation by ID */
        ProcessInstanceCreationInstructionById: {
            /** @description The BPMN process ID of the process definition to start an instance of. */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /**
             * Format: int32
             * @description The version of the process. By default, the latest version of the process is used.
             * @default -1
             */
            processDefinitionVersion: number;
            /**
             * @description JSON object that will instantiate the variables for the root variable scope
             *     of the process instance.
             */
            variables?: {
                [key: string]: unknown;
            };
            /** @description The tenant ID of the process definition. */
            tenantId?: components["schemas"]["TenantId"];
            operationReference?: components["schemas"]["OperationReference"];
            /**
             * @description List of start instructions. By default, the process instance will start at
             *     the start event. If provided, the process instance will apply start instructions
             *     after it has been created.
             */
            startInstructions?: components["schemas"]["ProcessInstanceCreationStartInstruction"][];
            /**
             * @description Runtime instructions (alpha). List of instructions that affect the runtime behavior of
             *     the process instance. Refer to specific instruction types for more details.
             *
             *     This parameter is an alpha feature and may be subject to change
             *     in future releases.
             */
            runtimeInstructions?: components["schemas"]["ProcessInstanceCreationRuntimeInstruction"][];
            /**
             * @description Wait for the process instance to complete. If the process instance completion does
             *     not occur within the requestTimeout, the request will be closed. This can lead to a 504
             *     response status. Disabled by default.
             * @default false
             */
            awaitCompletion: boolean;
            /**
             * @description List of variables by name to be included in the response when awaitCompletion is set to true.
             *     If empty, all visible variables in the root scope will be returned.
             * @example []
             */
            fetchVariables?: string[];
            /**
             * Format: int64
             * @description Timeout (in ms) the request waits for the process to complete. By default or
             *     when set to 0, the generic request timeout configured in the cluster is applied.
             * @default 0
             */
            requestTimeout: number;
            tags?: components["schemas"]["TagSet"];
        };
        /** Process creation by key */
        ProcessInstanceCreationInstructionByKey: {
            /**
             * @description The unique key identifying the process definition, for example, returned for a process in the
             *     deploy resources endpoint.
             */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /**
             * @description JSON object that will instantiate the variables for the root variable scope
             *     of the process instance.
             */
            variables?: {
                [key: string]: unknown;
            };
            /**
             * @description List of start instructions. By default, the process instance will start at
             *     the start event. If provided, the process instance will apply start instructions
             *     after it has been created.
             */
            startInstructions?: components["schemas"]["ProcessInstanceCreationStartInstruction"][];
            /**
             * @description Runtime instructions (alpha). List of instructions that affect the runtime behavior of
             *     the process instance. Refer to specific instruction types for more details.
             *
             *     This parameter is an alpha feature and may be subject to change
             *     in future releases.
             */
            runtimeInstructions?: components["schemas"]["ProcessInstanceCreationRuntimeInstruction"][];
            /** @description The tenant ID of the process definition. */
            tenantId?: components["schemas"]["TenantId"];
            operationReference?: components["schemas"]["OperationReference"];
            /**
             * @description Wait for the process instance to complete. If the process instance completion does
             *     not occur within the requestTimeout, the request will be closed. This can lead to a 504
             *     response status. Disabled by default.
             * @default false
             */
            awaitCompletion: boolean;
            /**
             * Format: int64
             * @description Timeout (in ms) the request waits for the process to complete. By default or
             *     when set to 0, the generic request timeout configured in the cluster is applied.
             * @default 0
             */
            requestTimeout: number;
            /**
             * @description List of variables by name to be included in the response when awaitCompletion is set to true.
             *     If empty, all visible variables in the root scope will be returned.
             * @example []
             */
            fetchVariables?: string[];
            tags?: components["schemas"]["TagSet"];
        };
        /**
         * @description Instructions for creating a process instance. The process definition can be specified
         *     either by ID or by key.
         */
        ProcessInstanceCreationInstruction: components["schemas"]["ProcessInstanceCreationInstructionById"] | components["schemas"]["ProcessInstanceCreationInstructionByKey"];
        CreateProcessInstanceResult: {
            /**
             * @description The BPMN process ID of the process definition which was used to create the process.
             *     instance
             * @example my-process-model-1
             */
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /**
             * Format: int32
             * @description The version of the process definition which was used to create the process instance.
             * @example 3
             */
            processDefinitionVersion: number;
            /**
             * @description The tenant ID of the created process instance.
             * @example <default>
             */
            tenantId: components["schemas"]["TenantId"];
            /** @description All the variables visible in the root scope. */
            variables: {
                [key: string]: unknown;
            };
            /** @description The key of the process definition which was used to create the process instance. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /**
             * @description The unique identifier of the created process instance; to be used wherever a request
             *     needs a process instance key (e.g. CancelProcessInstanceRequest).
             */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            tags?: components["schemas"]["TagSet"];
        };
        /** @description The process instance filter that defines which process instances should be canceled. */
        ProcessInstanceCancellationBatchOperationRequest: {
            /** @description The process instance filter. */
            filter: components["schemas"]["ProcessInstanceFilter"];
            operationReference?: components["schemas"]["OperationReference"];
        };
        /** @description The created batch operation. */
        BatchOperationCreatedResult: {
            /** @description Key of the batch operation. */
            batchOperationKey?: components["schemas"]["BatchOperationKey"];
            batchOperationType?: components["schemas"]["BatchOperationTypeEnum"];
        };
        /** @description The process instance filter that defines which process instances should have their incidents resolved. */
        ProcessInstanceIncidentResolutionBatchOperationRequest: {
            /** @description The process instance filter. */
            filter: components["schemas"]["ProcessInstanceFilter"];
            operationReference?: components["schemas"]["OperationReference"];
        };
        /** @description The mapping instructions describe how to map elements from the source process definition to the target process definition. */
        MigrateProcessInstanceMappingInstruction: {
            /** @description The element ID to migrate from. */
            sourceElementId: components["schemas"]["ElementId"];
            /** @description The element ID to migrate into. */
            targetElementId: components["schemas"]["ElementId"];
        };
        /** @description The migration instructions describe how to migrate a process instance from one process definition to another. */
        ProcessInstanceMigrationBatchOperationPlan: {
            /** @description The target process definition key. */
            targetProcessDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description The mapping instructions. */
            mappingInstructions: components["schemas"]["MigrateProcessInstanceMappingInstruction"][];
        };
        ProcessInstanceMigrationBatchOperationRequest: {
            /** @description The process instance filter. */
            filter: components["schemas"]["ProcessInstanceFilter"];
            /** @description The migration plan. */
            migrationPlan: components["schemas"]["ProcessInstanceMigrationBatchOperationPlan"];
            operationReference?: components["schemas"]["OperationReference"];
        };
        /**
         * @description Instructions describing a move operation. This instruction will terminate all active elementInstance
         *     at sourceElementId and activate a new element instance for each terminated one at targetElementId.
         */
        ProcessInstanceModificationMoveBatchOperationInstruction: {
            /** @description The source element ID. */
            sourceElementId: components["schemas"]["ElementId"];
            /** @description The target element ID. */
            targetElementId: components["schemas"]["ElementId"];
        };
        /**
         * @description The process instance filter to define on which process instances tokens should be moved,
         *     and new element instances should be activated or terminated.
         */
        ProcessInstanceModificationBatchOperationRequest: {
            /** @description The process instance filter. */
            filter: components["schemas"]["ProcessInstanceFilter"];
            /** @description Instructions for moving tokens between elements. */
            moveInstructions: components["schemas"]["ProcessInstanceModificationMoveBatchOperationInstruction"][];
            operationReference?: components["schemas"]["OperationReference"];
        };
        ProcessInstanceSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "processInstanceKey" | "processDefinitionId" | "processDefinitionName" | "processDefinitionVersion" | "processDefinitionVersionTag" | "processDefinitionKey" | "parentProcessInstanceKey" | "parentElementInstanceKey" | "startDate" | "endDate" | "state" | "hasIncident" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Process instance search request. */
        ProcessInstanceSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["ProcessInstanceSearchQuerySortRequest"][];
            /** @description The process instance search filters. */
            filter?: components["schemas"]["ProcessInstanceFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /** @description Process instance search response item. */
        ProcessInstanceResult: {
            processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            /** @description The process definition name. */
            processDefinitionName: string;
            /** Format: int32 */
            processDefinitionVersion: number;
            /** @description The process definition version tag. */
            processDefinitionVersionTag?: string;
            /** Format: date-time */
            startDate: string;
            /** Format: date-time */
            endDate?: string;
            state: components["schemas"]["ProcessInstanceStateEnum"];
            /** @description Whether this process instance has a related incident or not. */
            hasIncident: boolean;
            tenantId: components["schemas"]["TenantId"];
            /** @description The key of this process instance. */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            /** @description The process definition key. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description The parent process instance key. */
            parentProcessInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The parent element instance key. */
            parentElementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            tags?: components["schemas"]["TagSet"];
        };
        /** @description Process instance search response. */
        ProcessInstanceSearchQueryResult: {
            /** @description The matching process instances. */
            items: components["schemas"]["ProcessInstanceResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        ProcessInstanceCallHierarchyEntry: {
            /** @description The key of the process instance. */
            processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            /** @description The key of the process definition. */
            processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description The name of the process definition (fall backs to the process definition ID if not available). */
            processDefinitionName: string;
        };
        CancelProcessInstanceRequest: {
            operationReference?: components["schemas"]["OperationReference"];
        } | null;
        ProcessInstanceIncidentSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["IncidentSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        /** @description The migration instructions describe how to migrate a process instance from one process definition to another. */
        ProcessInstanceMigrationInstruction: {
            /** @description The key of process definition to migrate the process instance to. */
            targetProcessDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            /** @description Element mappings from the source process instance to the target process instance. */
            mappingInstructions: components["schemas"]["MigrateProcessInstanceMappingInstruction"][];
            operationReference?: components["schemas"]["OperationReference"];
        };
        /** @description Instructions describing which variables should be created. */
        ModifyProcessInstanceVariableInstruction: {
            /**
             * @description JSON document that will instantiate the variables for the root variable scope of the process instance.
             *     It must be a JSON object, as variables will be mapped in a key-value fashion.
             */
            variables: {
                [key: string]: unknown;
            };
            /**
             * @description The ID of the element in which scope the variables should be created.
             *     Leave empty to create the variables in the global scope of the process instance
             * @default
             */
            scopeId: string;
        };
        /** @description Instructions describing an element that should be activated. */
        ProcessInstanceModificationActivateInstruction: {
            /** @description The ID of the element that should be activated. */
            elementId: components["schemas"]["ElementId"];
            /** @description Instructions describing which variables should be created. */
            variableInstructions?: components["schemas"]["ModifyProcessInstanceVariableInstruction"][];
            /**
             * @description The key of the ancestor scope the element instance should be created in.
             *     Set to -1 to create the new element instance within an existing element instance of the
             *     flow scope.
             */
            ancestorElementInstanceKey?: string | components["schemas"]["ElementInstanceKey"];
        };
        /** @description Instructions describing which elements should be terminated. */
        ProcessInstanceModificationTerminateInstruction: {
            /** @description The ID of the element that should be terminated. */
            elementInstanceKey: components["schemas"]["ElementInstanceKey"];
        };
        ProcessInstanceModificationInstruction: {
            operationReference?: components["schemas"]["OperationReference"];
            /** @description Instructions describing which elements should be activated in which scopes and which variables should be created. */
            activateInstructions?: components["schemas"]["ProcessInstanceModificationActivateInstruction"][];
            /** @description Instructions describing which elements should be terminated. */
            terminateInstructions?: components["schemas"]["ProcessInstanceModificationTerminateInstruction"][];
        };
        /** @description Process instance sequence flow result. */
        ProcessInstanceSequenceFlowResult: {
            /** @description The sequence flow ID. */
            sequenceFlowId?: string;
            /** @description The key of this process instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The process definition key. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The process definition ID. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description The element ID for this sequence flow, as provided in the BPMN process. */
            elementId?: components["schemas"]["ElementId"];
            tenantId?: components["schemas"]["TenantId"];
        };
        /** @description Process instance sequence flows query response. */
        ProcessInstanceSequenceFlowsQueryResult: {
            /** @description The sequence flows. */
            items?: components["schemas"]["ProcessInstanceSequenceFlowResult"][];
        };
        /** @description Process instance element statistics query response. */
        ProcessInstanceElementStatisticsQueryResult: {
            /** @description The element statistics. */
            items?: components["schemas"]["ProcessElementStatisticsResult"][];
        };
        ResourceResult: {
            /** @description The resource name from which this resource was parsed. */
            resourceName?: string;
            /**
             * Format: int32
             * @description The assigned resource version.
             */
            version?: number;
            /** @description The version tag of this resource. */
            versionTag?: string;
            /** @description The resource ID of this resource. */
            resourceId?: string;
            /** @description The tenant ID of this resource. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The unique key of this resource. */
            resourceKey?: components["schemas"]["ResourceKey"];
        };
        DeleteResourceRequest: {
            operationReference?: components["schemas"]["OperationReference"];
        } | null;
        RoleCreateRequest: {
            /** @description The ID of the new role. */
            roleId: string;
            /** @description The display name of the new role. */
            name: string;
            /** @description The description of the new role. */
            description?: string;
        };
        RoleCreateResult: {
            /** @description The ID of the created role. */
            roleId?: string;
            /** @description The display name of the created role. */
            name?: string;
            /** @description The description of the created role. */
            description?: string;
        };
        RoleSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "name" | "roleId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Role filter request */
        RoleFilter: {
            /** @description The role ID search filters. */
            roleId?: string;
            /** @description The role name search filters. */
            name?: string;
        };
        /** @description Role search request. */
        RoleSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["RoleSearchQuerySortRequest"][];
            /** @description The role search filters. */
            filter?: components["schemas"]["RoleFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /** @description Role search response item. */
        RoleResult: {
            /** @description The role name. */
            name?: string;
            /** @description The role id. */
            roleId?: string;
            /** @description The description of the role. */
            description?: string;
        };
        /** @description Role search response. */
        RoleSearchQueryResult: {
            /** @description The matching roles. */
            items?: components["schemas"]["RoleResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        RoleUpdateRequest: {
            /** @description The display name of the new role. */
            name: string;
            /** @description The description of the new role. */
            description: string;
        };
        RoleUpdateResult: {
            /** @description The display name of the updated role. */
            name?: string;
            /** @description The description of the updated role. */
            description?: string;
            /** @description The ID of the updated role. */
            roleId?: string;
        };
        RoleClientSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "clientId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        RoleClientSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["RoleClientSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        RoleClientResult: {
            /** @description The ID of the client. */
            clientId?: string;
        };
        RoleClientSearchResult: {
            /** @description The matching clients. */
            items?: components["schemas"]["RoleClientResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        RoleGroupSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "groupId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        RoleGroupSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["RoleGroupSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        RoleGroupResult: {
            /** @description The id of the group. */
            groupId?: string;
        };
        RoleGroupSearchResult: {
            /** @description The matching groups. */
            items?: components["schemas"]["RoleGroupResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        RoleUserSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "username";
            order?: components["schemas"]["SortOrderEnum"];
        };
        RoleUserSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["RoleUserSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        RoleUserResult: {
            username?: components["schemas"]["Username"];
        };
        RoleUserSearchResult: {
            /** @description The matching users. */
            items?: components["schemas"]["RoleUserResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        UserRequest: {
            /** @description The password of the user. */
            password: string;
            /** @description The username of the user. */
            username: string;
            /** @description The name of the user. */
            name?: string;
            /** @description The email of the user. */
            email?: string;
        };
        SignalBroadcastRequest: {
            /** @description The name of the signal to broadcast. */
            signalName: string;
            /** @description The signal variables as a JSON object. */
            variables?: {
                [key: string]: unknown;
            };
            /** @description The ID of the tenant that owns the signal. */
            tenantId?: components["schemas"]["TenantId"];
        };
        /**
         * Format: SignalKey
         * @description System-generated key for an signal.
         * @example 22517998136987467
         */
        SignalKey: string & components["schemas"]["LongKey"];
        SignalBroadcastResult: {
            /** @description The tenant ID of the signal that was broadcast. */
            tenantId: components["schemas"]["TenantId"];
            /** @description The key of the broadcasted signal. */
            signalKey: components["schemas"]["SignalKey"];
        };
        UsageMetricsResponseItem: {
            /**
             * Format: int64
             * @description The amount of created root process instances.
             */
            processInstances?: number;
            /**
             * Format: int64
             * @description The amount of executed decision instances.
             */
            decisionInstances?: number;
            /**
             * Format: int64
             * @description The amount of unique active task users.
             */
            assignees?: number;
        };
        UsageMetricsResponse: {
            /**
             * Format: int64
             * @description The amount of active tenants.
             */
            activeTenants?: number;
            /** @description The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`. */
            tenants?: {
                [key: string]: components["schemas"]["UsageMetricsResponseItem"];
            };
        } & components["schemas"]["UsageMetricsResponseItem"];
        TenantCreateRequest: {
            /** @description The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`]. */
            tenantId: string;
            /** @description The name of the tenant. */
            name: string;
            /** @description The description of the tenant. */
            description?: string;
        };
        TenantCreateResult: {
            tenantId?: components["schemas"]["TenantId"];
            /**
             * @description The name of the tenant.
             * @example Customer Service Department
             */
            name?: string;
            /**
             * @description The description of the tenant.
             * @example Customer Service department business processes
             */
            description?: string;
        };
        TenantSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "key" | "name" | "tenantId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description Tenant filter request */
        TenantFilter: {
            tenantId?: components["schemas"]["TenantId"];
            /** @description The name of the tenant. */
            name?: string;
        };
        /** @description Tenant search request */
        TenantSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["TenantSearchQuerySortRequest"][];
            /** @description The tenant search filters. */
            filter?: components["schemas"]["TenantFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /** @description Tenant search response. */
        TenantSearchQueryResult: {
            /** @description The matching tenants. */
            items?: components["schemas"]["TenantResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        TenantUpdateRequest: {
            /** @description The new name of the tenant. */
            name: string;
            /** @description The new description of the tenant. */
            description: string;
        };
        TenantUpdateResult: {
            tenantId?: components["schemas"]["TenantId"];
            /** @description The name of the tenant. */
            name?: string;
            /** @description The description of the tenant. */
            description?: string;
        };
        TenantClientSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "clientId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        TenantClientSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["TenantClientSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        TenantClientResult: {
            /** @description The ID of the client. */
            clientId?: string;
        };
        TenantClientSearchResult: {
            /** @description The matching clients. */
            items?: components["schemas"]["TenantClientResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        TenantGroupSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "groupId";
            order?: components["schemas"]["SortOrderEnum"];
        };
        TenantGroupSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["TenantGroupSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        TenantGroupResult: {
            /** @description The groupId of the group. */
            groupId?: string;
        };
        TenantGroupSearchResult: {
            /** @description The matching groups. */
            items?: components["schemas"]["TenantGroupResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        TenantUserSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "username";
            order?: components["schemas"]["SortOrderEnum"];
        };
        TenantUserSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["TenantUserSearchQuerySortRequest"][];
        } & components["schemas"]["SearchQueryRequest"];
        TenantUserResult: {
            username?: components["schemas"]["Username"];
        };
        TenantUserSearchResult: {
            /** @description The matching users. */
            items?: components["schemas"]["TenantUserResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /** @description Provides information on a partition within a broker node. */
        Partition: {
            /**
             * Format: int32
             * @description The unique ID of this partition.
             * @example 1
             */
            partitionId: number;
            /**
             * @description Describes the Raft role of the broker for a given partition.
             * @example leader
             * @enum {string}
             */
            role: "leader" | "follower" | "inactive";
            /**
             * @description Describes the current health of the partition.
             * @example healthy
             * @enum {string}
             */
            health: "healthy" | "unhealthy" | "dead";
        };
        /** @description Provides information on a broker node. */
        BrokerInfo: {
            /**
             * Format: int32
             * @description The unique (within a cluster) node ID for the broker.
             * @example 0
             */
            nodeId: number;
            /**
             * @description The hostname for reaching the broker.
             * @example zeebe-0.zeebe-broker-service.b7fd7aa3-b973-4128-8789-74cd2318992c-zeebe.svc.cluster.local
             */
            host: string;
            /**
             * Format: int32
             * @description The port for reaching the broker.
             * @example 26501
             */
            port: number;
            /** @description A list of partitions managed or replicated on this broker. */
            partitions: components["schemas"]["Partition"][];
            /**
             * @description The broker version.
             * @example 8.8.0
             */
            version: string;
        };
        /** @description The response of a topology request. */
        TopologyResponse: {
            /** @description A list of brokers that are part of this cluster. */
            brokers: components["schemas"]["BrokerInfo"][];
            /** @description The cluster Id. */
            clusterId?: string | null;
            /**
             * Format: int32
             * @description The number of brokers in the cluster.
             * @example 3
             */
            clusterSize: number;
            /**
             * Format: int32
             * @description The number of partitions are spread across the cluster.
             * @example 3
             */
            partitionsCount: number;
            /**
             * Format: int32
             * @description The configured replication factor for this cluster.
             * @example 3
             */
            replicationFactor: number;
            /**
             * @description The version of the Zeebe Gateway.
             * @example 8.8.0
             */
            gatewayVersion: string;
            /**
             * @description ID of the last completed change
             * @example -1
             */
            lastCompletedChangeId: string;
        };
        UserCreateResult: {
            username?: components["schemas"]["Username"];
            /** @description The name of the user. */
            name?: string;
            /** @description The email of the user. */
            email?: string;
        };
        UserSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "username" | "name" | "email";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description User search filter. */
        UserFilter: {
            /** @description The username of the user. */
            username?: components["schemas"]["StringFilterProperty"];
            /** @description The name of the user. */
            name?: components["schemas"]["StringFilterProperty"];
            /** @description The email of the user. */
            email?: components["schemas"]["StringFilterProperty"];
        };
        UserSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["UserSearchQuerySortRequest"][];
            /** @description The user search filters. */
            filter?: components["schemas"]["UserFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        UserResult: {
            username?: components["schemas"]["Username"];
            /** @description The name of the user. */
            name?: string;
            /** @description The email of the user. */
            email?: string;
        };
        UserSearchResult: {
            /** @description The matching users. */
            items: components["schemas"]["UserResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        UserUpdateRequest: {
            /** @description The password of the user. If blank, the password is unchanged. */
            password?: string;
            /** @description The name of the user. */
            name?: string;
            /** @description The email of the user. */
            email?: string;
        };
        UserUpdateResult: {
            username?: components["schemas"]["Username"];
            /** @description The name of the user. */
            name?: string;
            /** @description The email of the user. */
            email?: string;
        };
        UserTaskSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "creationDate" | "completionDate" | "followUpDate" | "dueDate" | "priority" | "name";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * @description The state of the user task.
         * @enum {string}
         */
        UserTaskStateEnum: "CREATING" | "CREATED" | "ASSIGNING" | "UPDATING" | "COMPLETING" | "COMPLETED" | "CANCELING" | "CANCELED" | "FAILED";
        /**
         * Advanced filter
         * @description Advanced UserTaskStateEnum filter.
         */
        AdvancedUserTaskStateFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["UserTaskStateEnum"];
            /** @description Checks for inequality with the provided value. */
            $neq?: components["schemas"]["UserTaskStateEnum"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["UserTaskStateEnum"][];
            $like?: components["schemas"]["LikeFilter"];
        };
        /** @description UserTaskStateEnum property with full advanced search capabilities. */
        UserTaskStateFilterProperty: (string & components["schemas"]["UserTaskStateEnum"]) | components["schemas"]["AdvancedUserTaskStateFilter"];
        /** @description User task filter request. */
        UserTaskFilter: {
            /** @description The user task state. */
            state?: components["schemas"]["UserTaskStateFilterProperty"];
            /** @description The assignee of the user task. */
            assignee?: components["schemas"]["StringFilterProperty"];
            /** @description The priority of the user task. */
            priority?: components["schemas"]["IntegerFilterProperty"];
            /** @description The element ID of the user task. */
            elementId?: components["schemas"]["ElementId"];
            /** @description The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found. */
            name?: string;
            /** @description The candidate group for this user task. */
            candidateGroup?: components["schemas"]["StringFilterProperty"];
            /** @description The candidate user for this user task. */
            candidateUser?: components["schemas"]["StringFilterProperty"];
            /** @description Tenant ID of this user task. */
            tenantId?: components["schemas"]["StringFilterProperty"];
            /** @description The ID of the process definition. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /** @description The user task creation date. */
            creationDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The user task completion date. */
            completionDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The user task follow-up date. */
            followUpDate?: components["schemas"]["DateTimeFilterProperty"];
            /** @description The user task due date. */
            dueDate?: components["schemas"]["DateTimeFilterProperty"];
            processInstanceVariables?: components["schemas"]["VariableValueFilterProperty"][];
            localVariables?: components["schemas"]["VariableValueFilterProperty"][];
            /** @description The key for this user task. */
            userTaskKey?: components["schemas"]["UserTaskKey"];
            /** @description The key of the process definition. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The key of the process instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The key of the element instance. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
        };
        /** @description User task search query request. */
        UserTaskSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["UserTaskSearchQuerySortRequest"][];
            /** @description The user task search filters. */
            filter?: components["schemas"]["UserTaskFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        UserTaskResult: {
            /** @description The name for this user task. */
            name?: string;
            state?: components["schemas"]["UserTaskStateEnum"];
            /** @description The assignee of the user task. */
            assignee?: string;
            /** @description The element ID of the user task. */
            elementId?: components["schemas"]["ElementId"];
            /** @description The candidate groups for this user task. */
            candidateGroups?: string[];
            /** @description The candidate users for this user task. */
            candidateUsers?: string[];
            /** @description The ID of the process definition. */
            processDefinitionId?: components["schemas"]["ProcessDefinitionId"];
            /**
             * Format: date-time
             * @description The creation date of a user task.
             */
            creationDate?: string;
            /**
             * Format: date-time
             * @description The completion date of a user task.
             */
            completionDate?: string;
            /**
             * Format: date-time
             * @description The follow date of a user task.
             */
            followUpDate?: string;
            /**
             * Format: date-time
             * @description The due date of a user task.
             */
            dueDate?: string;
            tenantId?: components["schemas"]["TenantId"];
            /** @description The external form reference. */
            externalFormReference?: string;
            /**
             * Format: int32
             * @description The version of the process definition.
             */
            processDefinitionVersion?: number;
            /** @description Custom headers for the user task. */
            customHeaders?: {
                [key: string]: string;
            };
            /**
             * @description The priority of a user task. The higher the value the higher the priority.
             * @default 50
             */
            priority: number;
            /** @description The key of the user task. */
            userTaskKey?: components["schemas"]["UserTaskKey"];
            /** @description The key of the element instance. */
            elementInstanceKey?: components["schemas"]["ElementInstanceKey"];
            /** @description The name of the process definition. */
            processName?: string;
            /** @description The key of the process definition. */
            processDefinitionKey?: components["schemas"]["ProcessDefinitionKey"];
            /** @description The key of the process instance. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
            /** @description The key of the form. */
            formKey?: components["schemas"]["FormKey"];
        };
        /** @description User task search query response. */
        UserTaskSearchQueryResult: {
            /** @description The matching user tasks. */
            items?: components["schemas"]["UserTaskResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        /**
         * @description JSON object with changed task attribute values.
         *
         *     The following attributes can be adjusted with this endpoint, additional attributes
         *     will be ignored:
         *
         *     * `candidateGroups` - reset by providing an empty list
         *     * `candidateUsers` - reset by providing an empty list
         *     * `dueDate` - reset by providing an empty String
         *     * `followUpDate` - reset by providing an empty String
         *     * `priority` - minimum 0, maximum 100, default 50
         *
         *     Providing any of those attributes with a `null` value or omitting it preserves
         *     the persisted attribute's value.
         *
         *     The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
         *     This ensures correct event emission for assignee changes.
         */
        Changeset: ({
            /**
             * Format: date-time
             * @description The due date of the task. Reset by providing an empty String.
             */
            dueDate?: string | null;
            /**
             * Format: date-time
             * @description The follow-up date of the task. Reset by providing an empty String.
             */
            followUpDate?: string | null;
            /** @description The list of candidate users of the task. Reset by providing an empty list. */
            candidateUsers?: string[] | null;
            /** @description The list of candidate groups of the task. Reset by providing an empty list. */
            candidateGroups?: string[] | null;
            /**
             * Format: int32
             * @description The priority of the task.
             * @default 50
             */
            priority: number | null;
        } & {
            [key: string]: unknown;
        }) | null;
        UserTaskUpdateRequest: {
            changeset?: components["schemas"]["Changeset"];
            /** @description A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update". */
            action?: string | null;
        };
        UserTaskAssignmentRequest: {
            /** @description The assignee for the user task. The assignee must not be empty or `null`. */
            assignee?: string;
            /** @description By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions. */
            allowOverride?: boolean | null;
            /** @description A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign". */
            action?: string | null;
        };
        UserTaskCompletionRequest: {
            /** @description The variables to complete the user task with. */
            variables?: {
                [key: string]: unknown;
            } | null;
            /** @description A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete". */
            action?: string | null;
        };
        UserTaskVariableSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "value" | "name" | "tenantId" | "variableKey" | "scopeKey" | "processInstanceKey";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /** @description The user task variable search filters. */
        UserTaskVariableFilter: {
            /** @description Name of the variable. */
            name?: components["schemas"]["StringFilterProperty"];
        };
        /** @description User task search query request. */
        UserTaskVariableSearchQueryRequest: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["UserTaskVariableSearchQuerySortRequest"][];
            /** @description The user task variable search filters. */
            filter?: components["schemas"]["UserTaskVariableFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /**
         * Format: VariableKey
         * @description System-generated key for a variable.
         * @example 2251799813683287
         */
        VariableKey: string & components["schemas"]["LongKey"];
        /**
         * Format: ScopeKey
         * @description System-generated key for a scope.
         * @example 2251799813683890
         */
        ScopeKey: string & components["schemas"]["LongKey"];
        /** @description Variable response item. */
        VariableResultBase: {
            /** @description Name of this variable. */
            name?: string;
            /** @description Tenant ID of this variable. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description The key for this variable. */
            variableKey?: components["schemas"]["VariableKey"];
            /** @description The key of the scope of this variable. */
            scopeKey?: components["schemas"]["ScopeKey"];
            /** @description The key of the process instance of this variable. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKey"];
        };
        /** @description Variable search response item. */
        VariableSearchResult: {
            /** @description Value of this variable. Can be truncated. */
            value?: string;
            /** @description Whether the value is truncated or not. */
            isTruncated?: boolean;
        } & components["schemas"]["VariableResultBase"];
        /** @description Variable search query response. */
        VariableSearchQueryResult: {
            /** @description The matching variables. */
            items?: components["schemas"]["VariableSearchResult"][];
        } & components["schemas"]["SearchQueryResponse"];
        VariableSearchQuerySortRequest: {
            /**
             * @description The field to sort by.
             * @enum {string}
             */
            field: "value" | "name" | "tenantId" | "variableKey" | "scopeKey" | "processInstanceKey";
            order?: components["schemas"]["SortOrderEnum"];
        };
        /**
         * Advanced filter
         * @description Advanced VariableKey filter.
         */
        AdvancedVariableKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["VariableKey"];
            /** @description Checks for equality with the provided value. */
            $neq?: components["schemas"]["VariableKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["VariableKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["VariableKey"][];
        };
        /** @description VariableKey property with full advanced search capabilities. */
        VariableKeyFilterProperty: (string & components["schemas"]["VariableKey"]) | components["schemas"]["AdvancedVariableKeyFilter"];
        /**
         * Advanced filter
         * @description Advanced ScopeKey filter.
         */
        AdvancedScopeKeyFilter: {
            /** @description Checks for equality with the provided value. */
            $eq?: components["schemas"]["ScopeKey"];
            /** @description Checks for equality with the provided value. */
            $neq?: components["schemas"]["ScopeKey"];
            /** @description Checks if the current property exists. */
            $exists?: boolean;
            /** @description Checks if the property matches any of the provided values. */
            $in?: components["schemas"]["ScopeKey"][];
            /** @description Checks if the property matches none of the provided values. */
            $notIn?: components["schemas"]["ScopeKey"][];
        };
        /** @description ScopeKey property with full advanced search capabilities. */
        ScopeKeyFilterProperty: (string & components["schemas"]["ScopeKey"]) | components["schemas"]["AdvancedScopeKeyFilter"];
        /** @description Variable filter request. */
        VariableFilter: {
            /** @description Name of the variable. */
            name?: components["schemas"]["StringFilterProperty"];
            /** @description The value of the variable. */
            value?: components["schemas"]["StringFilterProperty"];
            /** @description Tenant ID of this variable. */
            tenantId?: components["schemas"]["TenantId"];
            /** @description Whether the value is truncated or not. */
            isTruncated?: boolean;
            /** @description The key for this variable. */
            variableKey?: components["schemas"]["VariableKeyFilterProperty"];
            /** @description The key of the scope of this variable. */
            scopeKey?: components["schemas"]["ScopeKeyFilterProperty"];
            /** @description The key of the process instance of this variable. */
            processInstanceKey?: components["schemas"]["ProcessInstanceKeyFilterProperty"];
        };
        /** @description Variable search query request. */
        VariableSearchQuery: {
            /** @description Sort field criteria. */
            sort?: components["schemas"]["VariableSearchQuerySortRequest"][];
            /** @description The variable search filters. */
            filter?: components["schemas"]["VariableFilter"];
        } & components["schemas"]["SearchQueryRequest"];
        /** @description Variable search response item. */
        VariableResult: {
            /** @description Full value of this variable. */
            value?: string;
        } & components["schemas"]["VariableResultBase"];
    };
    responses: {
        /** @description The request lacks valid authentication credentials. */
        Unauthorized: {
            headers: {
                "WWW-Authenticate"?: string;
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["ProblemDetail"];
            };
        };
        /** @description Forbidden. The request is not allowed. */
        Forbidden: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["ProblemDetail"];
            };
        };
        /** @description An internal error occurred while processing the request. */
        InternalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["ProblemDetail"];
            };
        };
        /** @description The provided data is not valid. */
        InvalidData: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["ProblemDetail"];
            };
        };
        /** @description The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure . */
        ServiceUnavailable: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["ProblemDetail"];
            };
        };
        /**
         * @description The server cannot process the request because the media type (Content-Type) of the request payload is not supported
         *     by the server for the requested resource and method.
         */
        UnsupportedMediaType: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["ProblemDetail"];
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getAuthentication: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The current user is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CamundaUserResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAuthorization: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthorizationCreateResult"];
            };
        };
        responses: {
            /** @description The authorization was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthorizationResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The owner was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchAuthorizations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AuthorizationSearchQuery"];
            };
        };
        responses: {
            /** @description The authorization search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthorizationSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAuthorization: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the authorization to get. */
                authorizationKey: components["schemas"]["AuthorizationKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The authorization was successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthorizationResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The authorization with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateAuthorization: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the authorization to delete. */
                authorizationKey: components["schemas"]["AuthorizationKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthorizationRequest"];
            };
        };
        responses: {
            /** @description The authorization was updated successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            /** @description The authorization with the authorizationKey was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    deleteAuthorization: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the authorization to delete. */
                authorizationKey: components["schemas"]["AuthorizationKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The authorization was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            /** @description The authorization with the authorizationKey was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchBatchOperationItems: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BatchOperationItemSearchQuery"];
            };
        };
        responses: {
            /** @description The batch operation search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationItemSearchQueryResult"];
                };
            };
            /** @description The provided data is not valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchBatchOperations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BatchOperationSearchQuery"];
            };
        };
        responses: {
            /** @description The batch operation search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationSearchQueryResult"];
                };
            };
            /** @description The provided data is not valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key (or operate legacy ID) of the batch operation. */
                batchOperationKey: components["schemas"]["BatchOperationKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The batch operation was found. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationResponse"];
                };
            };
            /** @description The provided data is not valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The batch operation is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    cancelBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key (or operate legacy ID) of the batch operation. */
                batchOperationKey: components["schemas"]["BatchOperationKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": unknown;
            };
        };
        responses: {
            /** @description The batch operation cancel request was created. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The batch operation was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    resumeBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key (or operate legacy ID) of the batch operation. */
                batchOperationKey: components["schemas"]["BatchOperationKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": unknown;
            };
        };
        responses: {
            /** @description The batch operation resume request was created. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The batch operation was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    suspendBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key (or operate legacy ID) of the batch operation. */
                batchOperationKey: components["schemas"]["BatchOperationKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": unknown;
            };
        };
        responses: {
            /** @description The batch operation pause request was created. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The batch operation was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    pinClock: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClockPinRequest"];
            };
        };
        responses: {
            /** @description The clock was successfully pinned. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    resetClock: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The clock was successfully reset to the system time. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchCorrelatedMessageSubscriptions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CorrelatedMessageSubscriptionSearchQuery"];
            };
        };
        responses: {
            /** @description The correlated message subscriptions search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CorrelatedMessageSubscriptionSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    evaluateDecision: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DecisionEvaluationInstruction"];
            };
        };
        responses: {
            /** @description The decision was evaluated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EvaluateDecisionResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            /** @description The decision is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchDecisionDefinitions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DecisionDefinitionSearchQuery"];
            };
        };
        responses: {
            /** @description The decision definition search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionDefinitionSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getDecisionDefinition: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the decision definition, which acts as a unique identifier for this decision. */
                decisionDefinitionKey: components["schemas"]["DecisionDefinitionKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The decision definition is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionDefinitionResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The decision definition with the given key was not found. More details are provided in the response body. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getDecisionDefinitionXML: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the decision definition, which acts as a unique identifier for this decision. */
                decisionDefinitionKey: components["schemas"]["DecisionDefinitionKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The XML of the decision definition is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/xml": string;
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The decision definition with the given key was not found. More details are provided in the response body. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchDecisionInstances: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DecisionInstanceSearchQuery"];
            };
        };
        responses: {
            /** @description The decision instance search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionInstanceSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getDecisionInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the decision instance, which acts as a unique identifier for this decision instance. */
                decisionEvaluationInstanceKey: components["schemas"]["DecisionInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The decision instance is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionInstanceGetQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The decision instance with the given key was not found. More details are provided in the response body. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchDecisionRequirements: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DecisionRequirementsSearchQuery"];
            };
        };
        responses: {
            /** @description The decision requirements search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionRequirementsSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getDecisionRequirements: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the decision requirements, which acts as a unique identifier for this decision requirements. */
                decisionRequirementsKey: components["schemas"]["DecisionRequirementsKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The decision requirements is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecisionRequirementsResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The decision requirements with the given key was not found. More details are provided in the response body. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getDecisionRequirementsXML: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the decision requirements, which acts as a unique identifier for this decision. */
                decisionRequirementsKey: components["schemas"]["DecisionRequirementsKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The XML of the decision requirements is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/xml": string;
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The decision requirements with the given key was not found. More details are provided in the response body. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    createDeployment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment. */
                    resources: string[];
                    tenantId?: components["schemas"]["TenantId"];
                };
            };
        };
        responses: {
            /** @description The resources are deployed. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeploymentResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    createDocument: {
        parameters: {
            query?: {
                /** @description The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores. */
                storeId?: string;
                /** @description The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists. */
                documentId?: components["schemas"]["DocumentId"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** Format: binary */
                    file: string;
                    metadata?: components["schemas"]["DocumentMetadata"];
                };
            };
        };
        responses: {
            /** @description The document was uploaded successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentReference"];
                };
            };
            400: components["responses"]["InvalidData"];
            415: components["responses"]["UnsupportedMediaType"];
        };
    };
    createDocuments: {
        parameters: {
            query?: {
                /** @description The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores. */
                storeId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** @description The documents to upload. */
                    files: string[];
                    /** @description Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array. */
                    metadataList?: components["schemas"]["DocumentMetadata"][];
                };
            };
        };
        responses: {
            /** @description All documents were uploaded successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentCreationBatchResponse"];
                };
            };
            /** @description Some documents were uploaded successfully, others failed. */
            207: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentCreationBatchResponse"];
                };
            };
            400: components["responses"]["InvalidData"];
            415: components["responses"]["UnsupportedMediaType"];
        };
    };
    getDocument: {
        parameters: {
            query?: {
                /** @description The ID of the document store to download the document from. */
                storeId?: string;
                /** @description The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected. */
                contentHash?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the document to download. */
                documentId: components["schemas"]["DocumentId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The document was downloaded successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description The document with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteDocument: {
        parameters: {
            query?: {
                /** @description The ID of the document store to delete the document from. */
                storeId?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the document to delete. */
                documentId: components["schemas"]["DocumentId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The document was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The document with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    createDocumentLink: {
        parameters: {
            query?: {
                /** @description The ID of the document store where the document is located. */
                storeId?: string;
                /** @description The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected. */
                contentHash?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the document to link. */
                documentId: components["schemas"]["DocumentId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DocumentLinkRequest"];
            };
        };
        responses: {
            /** @description The document link was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentLink"];
                };
            };
            400: components["responses"]["InvalidData"];
        };
    };
    activateAdHocSubProcessActivities: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the ad-hoc sub-process instance that contains the activities. */
                adHocSubProcessInstanceKey: components["schemas"]["ElementInstanceKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AdHocSubProcessActivateActivitiesInstruction"];
            };
        };
        responses: {
            /** @description The ad-hoc sub-process instance is modified. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The ad-hoc sub-process instance is not found or the provided key does not identify an ad-hoc sub-process. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchElementInstances: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ElementInstanceSearchQuery"];
            };
        };
        responses: {
            /** @description The element instance search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ElementInstanceSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getElementInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the element instance, which acts as a unique identifier for this element instance. */
                elementInstanceKey: components["schemas"]["ElementInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The element instance is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ElementInstanceResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /**
             * @description The element instance with the given key was not found.
             *     More details are provided in the response body.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchElementInstanceIncidents: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique key of the element instance to search incidents for. */
                elementInstanceKey: components["schemas"]["ElementInstanceKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ElementInstanceIncidentSearchQuery"];
            };
        };
        responses: {
            /** @description The element instance incident search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IncidentSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The element instance with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    createElementInstanceVariables: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /**
                 * @description The key of the element instance to update the variables for.
                 *     This can be the process instance key (as obtained during instance creation), or a given
                 *     element, such as a service task (see the `elementInstanceKey` on the job message).
                 */
                elementInstanceKey: components["schemas"]["ElementInstanceKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SetVariableRequest"];
            };
        };
        responses: {
            /** @description The variables were updated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    createGroup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["GroupCreateRequest"];
            };
        };
        responses: {
            /** @description The group was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupCreateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchGroups: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["GroupSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The groups search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description An internal error occurred while processing the request. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The group is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupUpdateRequest"];
            };
        };
        responses: {
            /** @description The group was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupUpdateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    deleteGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The group was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchClientsForGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["GroupClientSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The clients assigned to the group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupClientSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignClientToGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
                /** @description The client ID. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The client was assigned successfully to the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The client with the given ID is already assigned to the group. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignClientFromGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
                /** @description The client ID. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The client was unassigned successfully from the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found, or the client is not assigned to this group. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchMappingRulesForGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SearchQueryRequest"];
            };
        };
        responses: {
            /** @description The mapping rules assigned to the group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchQueryResponse"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignMappingRuleToGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
                /** @description The mapping rule ID. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The mapping rule was assigned successfully to the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The group or mapping rule with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The mapping rule with the given ID is already assigned to the group. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignMappingRuleFromGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
                /** @description The mapping rule ID. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The mapping rule was unassigned successfully from the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The group or mapping rule with the given ID was not found, or the mapping rule is not assigned to this group. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchRolesForGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SearchQueryRequest"];
            };
        };
        responses: {
            /** @description The roles assigned to the group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchQueryResponse"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchUsersForGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["GroupUserSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The users assigned to the group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GroupUserSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignUserToGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
                /** @description The user username. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was assigned successfully to the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The group or user with the given ID or username was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The user with the given ID is already assigned to the group. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignUserFromGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The group ID. */
                groupId: string;
                /** @description The user username. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was unassigned successfully from the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The group or user with the given ID was not found, or the user is not assigned to this group. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchIncidents: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["IncidentSearchQuery"];
            };
        };
        responses: {
            /** @description The incident search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IncidentSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getIncident: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the incident, which acts as a unique identifier for this incident. */
                incidentKey: components["schemas"]["IncidentKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The incident is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IncidentResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The incident with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    resolveIncident: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Key of the incident to resolve. */
                incidentKey: components["schemas"]["IncidentKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["IncidentResolutionRequest"];
            };
        };
        responses: {
            /** @description The incident is marked as resolved. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The incident with the incidentKey is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    activateJobs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["JobActivationRequest"];
            };
        };
        responses: {
            /** @description The list of activated jobs. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobActivationResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchJobs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["JobSearchQuery"];
            };
        };
        responses: {
            /** @description The job search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateJob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the job to update. */
                jobKey: components["schemas"]["JobKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["JobUpdateRequest"];
            };
        };
        responses: {
            /** @description The job was updated successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The job with the jobKey is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The job with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    completeJob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the job to complete. */
                jobKey: components["schemas"]["JobKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["JobCompletionRequest"];
            };
        };
        responses: {
            /** @description The job was completed successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The job with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The job with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    throwJobError: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the job. */
                jobKey: components["schemas"]["JobKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["JobErrorRequest"];
            };
        };
        responses: {
            /** @description An error is thrown for the job. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The job with the given key was not found or is not activated. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The job with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    failJob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the job to fail. */
                jobKey: components["schemas"]["JobKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["JobFailRequest"];
            };
        };
        responses: {
            /** @description The job is failed. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The job with the given jobKey is not found. It was completed by another worker, or the process instance itself was canceled. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The job with the given key is in the wrong state (i.e: not ACTIVATED or ACTIVATABLE). The job was failed by another worker with retries = 0, and the process is now in an incident state. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    getLicense: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Obtains the current status of the Camunda license. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LicenseResponse"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    createMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MappingRuleCreateRequest"];
            };
        };
        responses: {
            /** @description The mapping rule was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MappingRuleCreateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            /**
             * @description The request to create a mapping rule was denied.
             *     More details are provided in the response body.
             */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The request to create a mapping rule was denied. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MappingRuleSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The mapping rule search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MappingRuleSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the mapping rule to get. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The mapping rule was returned successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MappingRuleResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            /** @description The mapping rule with the mappingRuleId was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the mapping rule to update. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MappingRuleUpdateRequest"];
            };
        };
        responses: {
            /** @description The mapping rule was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MappingRuleUpdateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            /**
             * @description The request to update a mapping rule was denied.
             *     More details are provided in the response body.
             */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The request to update a mapping rule was denied. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    deleteMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the mapping rule to delete. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The mapping rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            /** @description The mapping rule with the mappingRuleId was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchMessageSubscriptions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MessageSubscriptionSearchQuery"];
            };
        };
        responses: {
            /** @description The message subscription search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageSubscriptionSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    correlateMessage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageCorrelationRequest"];
            };
        };
        responses: {
            /** @description The message is correlated to one or more process instances */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageCorrelationResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    publishMessage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessagePublicationRequest"];
            };
        };
        responses: {
            /** @description The message was published. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessagePublicationResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchProcessDefinitions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessDefinitionSearchQuery"];
            };
        };
        responses: {
            /** @description The process definition search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessDefinitionSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessDefinitionInstanceStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessDefinitionInstanceStatisticsQuery"];
            };
        };
        responses: {
            /** @description The process definition instance statistic result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessDefinitionInstanceStatisticsQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessDefinition: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the process definition, which acts as a unique identifier for this process definition. */
                processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The process definition is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessDefinitionResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The process definition with the given key was not found. More details are provided in the response body. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getStartProcessForm: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The process key. */
                processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The form is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormResult"];
                };
            };
            /** @description The process was found, but no form is associated with it. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessDefinitionStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the process definition, which acts as a unique identifier for this process definition. */
                processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessDefinitionElementStatisticsQuery"];
            };
        };
        responses: {
            /** @description The process definition statistics result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessDefinitionElementStatisticsQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessDefinitionXML: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the process definition, which acts as a unique identifier for this process definition. */
                processDefinitionKey: components["schemas"]["ProcessDefinitionKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The XML of the process definition is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/xml": string;
                };
            };
            /** @description The process definition was found but does not have XML. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /**
             * @description The process definition with the given key was not found.
             *     More details are provided in the response body.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessDefinitionInstanceVersionStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the process definition. */
                processDefinitionId: components["schemas"]["ProcessDefinitionId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessDefinitionInstanceVersionStatisticsQuery"];
            };
        };
        responses: {
            /** @description The process definition instance version statistic result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessDefinitionInstanceVersionStatisticsQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createProcessInstance: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceCreationInstruction"];
            };
        };
        responses: {
            /** @description The process instance was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateProcessInstanceResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
            /**
             * @description The process instance creation request timed out in the gateway.
             *     This can happen if the `awaitCompletion` request parameter is set to `true`
             *     and the created process instance did not complete within the defined request timeout.
             *     This often happens when the created instance is not fully automated or contains wait states.
             */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
        };
    };
    cancelProcessInstancesBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceCancellationBatchOperationRequest"];
            };
        };
        responses: {
            /** @description The batch operation request was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationCreatedResult"];
                };
            };
            /** @description The process instance batch operation failed. More details are provided in the response body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    resolveIncidentsBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceIncidentResolutionBatchOperationRequest"];
            };
        };
        responses: {
            /** @description The batch operation request was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationCreatedResult"];
                };
            };
            /** @description The process instance batch operation failed. More details are provided in the response body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    migrateProcessInstancesBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceMigrationBatchOperationRequest"];
            };
        };
        responses: {
            /** @description The batch operation request was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationCreatedResult"];
                };
            };
            /** @description The process instance batch operation failed. More details are provided in the response body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    modifyProcessInstancesBatchOperation: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceModificationBatchOperationRequest"];
            };
        };
        responses: {
            /** @description The batch operation request was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationCreatedResult"];
                };
            };
            /** @description The process instance batch operation failed. More details are provided in the response body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    searchProcessInstances: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceSearchQuery"];
            };
        };
        responses: {
            /** @description The process instance search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessInstanceSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The process instance key. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The process instance is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessInstanceResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The process instance with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessInstanceCallHierarchy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the process instance to fetch the hierarchy for. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The call hierarchy is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessInstanceCallHierarchyEntry"][];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The process instance is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    cancelProcessInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the process instance to cancel. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CancelProcessInstanceRequest"];
            };
        };
        responses: {
            /** @description The process instance is canceled. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The process instance is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    resolveProcessInstanceIncidents: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the process instance to resolve incidents for. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The batch operation request for incident resolution was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchOperationCreatedResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            /** @description The process instance is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchProcessInstanceIncidents: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the process instance, which acts as a unique identifier for this process instance. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceIncidentSearchQuery"];
            };
        };
        responses: {
            /** @description The process instance search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IncidentSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The process instance with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    migrateProcessInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the process instance that should be migrated. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceMigrationInstruction"];
            };
        };
        responses: {
            /** @description The process instance is migrated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The process instance is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The process instance migration failed. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    modifyProcessInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the process instance that should be modified. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProcessInstanceModificationInstruction"];
            };
        };
        responses: {
            /** @description The process instance is modified. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The process instance is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    getProcessInstanceSequenceFlows: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the process instance, which acts as a unique identifier for this process instance. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The process instance sequence flows result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessInstanceSequenceFlowsQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getProcessInstanceStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The assigned key of the process instance, which acts as a unique identifier for this process instance. */
                processInstanceKey: components["schemas"]["ProcessInstanceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The process instance statistics result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessInstanceElementStatisticsQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique key identifying the resource. */
                resourceKey: components["schemas"]["ResourceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The resource is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceResult"];
                };
            };
            /** @description A resource with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getResourceContent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique key identifying the resource. */
                resourceKey: components["schemas"]["ResourceKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The resource content is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description A resource with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteResource: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /**
                 * @description The key of the resource to delete.
                 *     This can be the key of a process definition, the key of a decision requirements
                 *     definition or the key of a form definition
                 */
                resourceKey: components["schemas"]["ResourceKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DeleteResourceRequest"];
            };
        };
        responses: {
            /** @description The resource is deleted. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The resource is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    createRole: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RoleCreateRequest"];
            };
        };
        responses: {
            /** @description The role was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleCreateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchRoles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RoleSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The roles search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description An internal error occurred while processing the request. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The role with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RoleUpdateRequest"];
            };
        };
        responses: {
            /** @description The role was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleUpdateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            /** @description The role with the ID is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    deleteRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            /** @description The role with the ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchClientsForRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RoleClientSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The clients with the assigned role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleClientSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The role with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignRoleToClient: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The client ID. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was assigned successfully to the client. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The role was already assigned to the client with the given ID. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignRoleFromClient: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The client ID. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was unassigned successfully from the client. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or client with the given ID or username was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchGroupsForRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RoleGroupSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The groups with assigned role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleGroupSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The role with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignRoleToGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was assigned successfully to the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The role is already assigned to the group with the given ID. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignRoleFromGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The group ID. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was unassigned successfully from the group. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or group with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchMappingRulesForRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MappingRuleSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The mapping rules with assigned role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchQueryResponse"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The role with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignRoleToMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The mapping rule ID. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was assigned successfully to the mapping rule. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or mapping rule with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The role is already assigned to the mapping rule with the given ID. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignRoleFromMappingRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The mapping rule ID. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was unassigned successfully from the mapping rule. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or mapping rule with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchUsersForRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RoleUserSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The users with the assigned role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoleUserSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The role with the given ID was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    assignRoleToUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The user username. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was assigned successfully to the user. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or user with the given ID or username was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The role is already assigned to the user with the given ID. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignRoleFromUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The role ID. */
                roleId: string;
                /** @description The user username. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was unassigned successfully from the user. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The role or user with the given ID or username was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    createAdminUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserRequest"];
            };
        };
        responses: {
            /** @description The admin user was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    broadcastSignal: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SignalBroadcastRequest"];
            };
        };
        responses: {
            /** @description The signal was broadcast. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SignalBroadcastResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            /** @description The signal is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    getStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The cluster is UP and has at least one partition with a healthy leader. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The cluster is DOWN and does not have any partition with a healthy leader. */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getUsageMetrics: {
        parameters: {
            query: {
                /** @description The start date for usage metrics, including this date. Value in ISO 8601 format. */
                startTime: string;
                /** @description The end date for usage metrics, including this date. Value in ISO 8601 format. */
                endTime: string;
                /** @description Restrict results to a specific tenant ID. If not provided, results for all tenants are returned. */
                tenantId?: components["schemas"]["TenantId"];
                /** @description Whether to return tenant metrics in addition to the total metrics or not. Default false. */
                withTenants?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The usage metrics search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UsageMetricsResponse"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createTenant: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TenantCreateRequest"];
            };
        };
        responses: {
            /** @description The tenant was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantCreateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The resource was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description Tenant with this id already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchTenants: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TenantSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The tenants search result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    getTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The tenant was retrieved successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Tenant not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TenantUpdateRequest"];
            };
        };
        responses: {
            /** @description The tenant was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantUpdateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    deleteTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The tenant was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchClientsForTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TenantClientSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The search result of users for the tenant. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantClientSearchResult"];
                };
            };
        };
    };
    assignClientToTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the application. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The client was successfully assigned to the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The tenant was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignClientFromTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the application. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The client was successfully unassigned from the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The tenant does not exist or the client was not assigned to it. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchGroupIdsForTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TenantGroupSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The search result of groups for the tenant. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantGroupSearchResult"];
                };
            };
        };
    };
    assignGroupToTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the group. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The group was successfully assigned to the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or group was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignGroupFromTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the group. */
                groupId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The group was successfully unassigned from the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or group was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchMappingRulesForTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SearchQueryRequest"];
            };
        };
        responses: {
            /** @description The search result of MappingRules for the tenant. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchQueryResponse"];
                };
            };
        };
    };
    assignMappingRuleToTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the mapping rule. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The mapping rule was successfully assigned to the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or mapping rule was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignMappingRuleFromTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the mapping rule. */
                mappingRuleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The mapping rule was successfully unassigned from the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or mapping rule was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchRolesForTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SearchQueryRequest"];
            };
        };
        responses: {
            /** @description The search result of roles for the tenant. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchQueryResponse"];
                };
            };
        };
    };
    assignRoleToTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the role. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was successfully assigned to the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or role was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignRoleFromTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the role. */
                roleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role was successfully unassigned from the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or role was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchUsersForTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TenantUserSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The search result of users for the tenant. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TenantUserSearchResult"];
                };
            };
        };
    };
    assignUserToTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the user. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was successfully assigned to the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or user was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignUserFromTenant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the tenant. */
                tenantId: components["schemas"]["TenantId"];
                /** @description The unique identifier of the user. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was successfully unassigned from the tenant. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description Not found. The tenant or user was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    getTopology: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Obtains the current topology of the cluster the gateway is part of. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopologyResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserRequest"];
            };
        };
        responses: {
            /** @description The user was created successfully. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserCreateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description A user with this username already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchUsers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The user search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserSearchResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResult"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The user with the given username was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user to update. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserUpdateRequest"];
            };
        };
        responses: {
            /** @description The user was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserUpdateResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            403: components["responses"]["Forbidden"];
            /** @description The user was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    deleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username of the user to delete. */
                username: components["schemas"]["Username"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The user is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    searchUserTasks: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserTaskSearchQuery"];
            };
        };
        responses: {
            /** @description The user task search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserTaskSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getUserTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The user task key. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user task is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserTaskResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description The user task with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    updateUserTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the user task to update. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserTaskUpdateRequest"];
            };
        };
        responses: {
            /** @description The user task was updated successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The user task with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The user task with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    unassignUserTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the user task. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user task was unassigned successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The user task with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The user task with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    assignUserTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the user task to assign. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserTaskAssignmentRequest"];
            };
        };
        responses: {
            /** @description The user task's assignment was adjusted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The user task with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The user task with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    completeUserTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the user task to complete. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserTaskCompletionRequest"];
            };
        };
        responses: {
            /** @description The user task was completed successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            /** @description The user task with the given key was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            /** @description The user task with the given key is in the wrong state currently. More details are provided in the response body. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
            503: components["responses"]["ServiceUnavailable"];
        };
    };
    getUserTaskForm: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The user task key. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The form is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormResult"];
                };
            };
            /** @description The user task was found, but no form is associated with it. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    searchUserTaskVariables: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the user task. */
                userTaskKey: components["schemas"]["UserTaskKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserTaskVariableSearchQueryRequest"];
            };
        };
        responses: {
            /** @description The user task variable search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VariableSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            500: components["responses"]["InternalServerError"];
        };
    };
    searchVariables: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VariableSearchQuery"];
            };
        };
        responses: {
            /** @description The variable search result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VariableSearchQueryResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The variable key. */
                variableKey: components["schemas"]["VariableKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The variable is successfully returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VariableResult"];
                };
            };
            400: components["responses"]["InvalidData"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/problem+json": components["schemas"]["ProblemDetail"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
}
