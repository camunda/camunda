<?xml version="1.0" encoding="UTF-8" ?>
<!--
  ~ Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under
  ~ one or more contributor license agreements. See the NOTICE file distributed
  ~ with this work for additional information regarding copyright ownership.
  ~ Licensed under the Camunda License 1.0. You may not use this file
  ~ except in compliance with the Camunda License 1.0.
  -->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="io.camunda.db.rdbms.sql.ProcessInstanceMapper">
  <select id="findOne" parameterType="java.lang.Long"
    resultMap="io.camunda.db.rdbms.sql.ProcessInstanceMapper.searchResultMap">
    SELECT pi.PROCESS_INSTANCE_KEY,
           pi.BPMN_PROCESS_ID,
           pi.PROCESS_DEFINITION_KEY,
           pi.STATE,
           pi.START_DATE,
           pi.END_DATE,
           pi.TENANT_ID,
           NULL           as TREE_PATH,
           NULL           as ROOT_PROCESS_INSTANCE_KEY,
           NULL           as INCIDENT,
           pi.PARENT_PROCESS_INSTANCE_KEY,
           pi.PARENT_ELEMENT_INSTANCE_KEY,
           pi.ELEMENT_ID,
           pi.VERSION,
           pd.NAME        AS PROCESS_DEFINITION_NAME,
           pd.VERSION_TAG AS PROCESS_DEFINITION_VERSION_TAG
    FROM PROCESS_INSTANCE pi
           LEFT JOIN PROCESS_DEFINITION pd ON (pi.PROCESS_DEFINITION_KEY = pd.PROCESS_DEFINITION_KEY)
    WHERE PROCESS_INSTANCE_KEY = #{processInstanceKey}
  </select>

  <select id="count">
    SELECT COUNT(*)
    FROM PROCESS_INSTANCE pi
    <!-- TODO: only when definition filters are active -->
    LEFT JOIN PROCESS_DEFINITION pd ON (pi.PROCESS_DEFINITION_KEY = pd.PROCESS_DEFINITION_KEY)
    <include refid="io.camunda.db.rdbms.sql.ProcessInstanceMapper.searchFilter"/>
  </select>

  <!-- default search statement for databases supporting LIMIT/OFFSET-->
  <select id="search" parameterType="io.camunda.db.rdbms.domain.ProcessInstanceDbFilter" resultMap="io.camunda.db.rdbms.sql.ProcessInstanceMapper.searchResultMap">
    SELECT
      pi.PROCESS_INSTANCE_KEY,
      pi.BPMN_PROCESS_ID,
      pi.PROCESS_DEFINITION_KEY,
      pi.STATE,
      pi.START_DATE,
      pi.END_DATE,
      pi.TENANT_ID,
      NULL as TREE_PATH,
      NULL as ROOT_PROCESS_INSTANCE_KEY,
      NULL as INCIDENT,
      pi.PARENT_PROCESS_INSTANCE_KEY,
      pi.PARENT_ELEMENT_INSTANCE_KEY,
      pi.ELEMENT_ID,
      pi.VERSION,
      pd.NAME AS PROCESS_DEFINITION_NAME,
      pd.VERSION_TAG AS PROCESS_DEFINITION_VERSION_TAG
    FROM PROCESS_INSTANCE pi
        LEFT JOIN PROCESS_DEFINITION pd ON (pi.PROCESS_DEFINITION_KEY = pd.PROCESS_DEFINITION_KEY)
    <include refid="io.camunda.db.rdbms.sql.ProcessInstanceMapper.searchFilter"/>
    <if test="sort != null and sort.orderings != null and !sort.orderings.isEmpty()">
      <foreach collection="sort.orderings" open="ORDER BY " separator=", " item="item">
        <include refid="io.camunda.db.rdbms.sql.ProcessInstanceMapper.processInstanceSortMapper"/>
        ${item.order}
      </foreach>
    </if>
    ${paging.after}
  </select>

  <sql id="searchFilter">
    WHERE 1 = 1
    <!-- basic filters -->
    <if test="filter.processInstanceKeys != null and !filter.processInstanceKeys.isEmpty()">
      AND PROCESS_INSTANCE_KEY IN
      <foreach collection="filter.processInstanceKeys" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.processDefinitionIds != null and !filter.processDefinitionIds.isEmpty()">
      AND pi.BPMN_PROCESS_ID IN
      <foreach collection="filter.processDefinitionIds" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.processDefinitionKeys != null and !filter.processDefinitionKeys.isEmpty()">
      AND pi.PROCESS_DEFINITION_KEY IN
      <foreach collection="filter.processDefinitionKeys" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.parentProcessInstanceKeys != null and !filter.parentProcessInstanceKeys.isEmpty()">
      AND PARENT_PROCESS_INSTANCE_KEY IN
      <foreach collection="filter.parentProcessInstanceKeys" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.parentFlowNodeInstanceKeys != null and !filter.parentFlowNodeInstanceKeys.isEmpty()">
      AND PARENT_ELEMENT_INSTANCE_KEY IN
      <foreach collection="filter.parentFlowNodeInstanceKeys" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.states != null and !filter.states.isEmpty()">
      AND pi.STATE IN
      <foreach collection="filter.states" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.tenantIds != null and !filter.tenantIds.isEmpty()">
      AND TENANT_ID IN
      <foreach collection="filter.tenantIds" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>

    <!-- date filters -->
    <if test="filter.startDate != null and filter.startDate.before != null">
      AND START_DATE &lt; #{filter.startDate.before}
    </if>
    <if test="filter.startDate != null and filter.startDate.after != null">
      AND START_DATE &gt; #{filter.startDate.after}
    </if>
    <if test="filter.endDate != null and filter.endDate.before != null">
      AND END_DATE &lt; #{filter.endDate.before}
    </if>
    <if test="filter.endDate != null and filter.endDate.after != null">
      AND END_DATE &gt; #{filter.endDate.after}
    </if>

    <!-- process definition filters -->
    <if test="filter.processDefinitionNames != null and !filter.processDefinitionNames.isEmpty()">
      AND pd.NAME IN
      <foreach collection="filter.processDefinitionNames" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.processDefinitionVersions != null and !filter.processDefinitionVersions.isEmpty()">
      AND pd.VERSION IN
      <foreach collection="filter.processDefinitionVersions" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
    <if test="filter.processDefinitionVersionTags != null and !filter.processDefinitionVersionTags.isEmpty()">
      AND pd.VERSION_TAG IN
      <foreach collection="filter.processDefinitionVersionTags" item="value" open="(" separator=", " close=")">#{value}</foreach>
    </if>
  </sql>

  <sql id="processInstanceSortMapper">
    <choose>
      <when test='item.field == "bpmnProcessId"'>
        BPMN_PROCESS_ID
      </when>
      <when test='item.field == "processName"'>
        NAME
      </when>
      <when test='item.field == "processVersion"'>
        VERSION
      </when>
      <when test='item.field == "processVersionTag"'>
        VERSION_TAG
      </when>
      <when test='item.field == "processDefinitionKey"'>
        PROCESS_DEFINITION_KEY
      </when>
      <when test='item.field == "parentProcessInstanceKey"'>
        PARENT_PROCESS_INSTANCE_KEY
      </when>
      <when test='item.field == "startDate"'>
        START_DATE
      </when>
      <when test='item.field == "endDate"'>
        END_DATE
      </when>
      <when test='item.field == "tenantId"'>
        TENANT_ID
      </when>
      <otherwise>
        ${field}
      </otherwise>
    </choose>
  </sql>

  <!-- TODO: Find better way to automatically type the constructor parameters -->
  <resultMap id="searchResultMap" type="io.camunda.search.entities.ProcessInstanceEntity">
    <constructor>
      <idArg column="PROCESS_INSTANCE_KEY" javaType="java.lang.Long"/>
      <arg column="BPMN_PROCESS_ID" javaType="java.lang.String"/>
      <arg column="PROCESS_DEFINITION_NAME" javaType="java.lang.String"/>
      <arg column="VERSION" javaType="java.lang.Integer"/>
      <arg column="PROCESS_DEFINITION_VERSION_TAG" javaType="java.lang.String"/>
      <arg column="PROCESS_DEFINITION_KEY" javaType="java.lang.Long"/>
      <arg column="ROOT_PROCESS_INSTANCE_KEY" javaType="java.lang.Long"/>
      <arg column="PARENT_PROCESS_INSTANCE_KEY" javaType="java.lang.Long"/>
      <arg column="PARENT_ELEMENT_INSTANCE_KEY" javaType="java.lang.Long"/>
      <arg column="TREE_PATH" javaType="java.lang.String"/>
      <arg column="START_DATE" javaType="java.lang.String" typeHandler="io.camunda.db.rdbms.sql.typehandler.OffsetDateTimeToStringTypeHandler"/>
      <arg column="END_DATE" javaType="java.lang.String" typeHandler="io.camunda.db.rdbms.sql.typehandler.OffsetDateTimeToStringTypeHandler"/>
      <arg column="STATE" javaType="io.camunda.search.entities.ProcessInstanceEntity$ProcessInstanceState"/>
      <arg column="INCIDENT" javaType="java.lang.Boolean"/>
      <arg column="TENANT_ID" javaType="java.lang.String"/>
    </constructor>

  </resultMap>

  <insert
    id="insert"
    parameterType="io.camunda.db.rdbms.domain.ProcessInstanceDbModel"
    flushCache="true">
    INSERT INTO PROCESS_INSTANCE (PROCESS_INSTANCE_KEY, BPMN_PROCESS_ID, PROCESS_DEFINITION_KEY, STATE, START_DATE, END_DATE, TENANT_ID, PARENT_PROCESS_INSTANCE_KEY, PARENT_ELEMENT_INSTANCE_KEY,
                                  VERSION)
    VALUES (#{processInstanceKey}, #{bpmnProcessId}, #{processDefinitionKey}, #{state}, #{startDate, jdbcType=TIMESTAMP}, #{endDate, jdbcType=TIMESTAMP}, #{tenantId}, #{parentProcessInstanceKey},
            #{parentElementInstanceKey}, #{version})
  </insert>

  <update
    id="update"
    statementType="PREPARED"
    parameterType="io.camunda.db.rdbms.domain.ProcessInstanceDbModel"
    flushCache="true"
    timeout="20">
    UPDATE PROCESS_INSTANCE p
    SET STATE    = #{state},
        END_DATE = #{endDate}
    WHERE PROCESS_INSTANCE_KEY = #{processInstanceKey}
  </update>

  <update
    id="updateCurrentElementId"
    statementType="PREPARED"
    parameterType="hashMap"
    flushCache="true"
    timeout="20">
    UPDATE PROCESS_INSTANCE p
    SET ELEMENT_ID = #{elementId}
    WHERE PROCESS_INSTANCE_KEY = #{processInstanceKey}
  </update>
</mapper>
