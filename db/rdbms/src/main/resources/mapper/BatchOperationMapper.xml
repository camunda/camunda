<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="io.camunda.db.rdbms.sql.BatchOperationMapper">

  <resultMap id="BatchOperationResultMap"
    type="io.camunda.db.rdbms.write.domain.BatchOperationDbModel">
    <constructor>
      <idArg column="BATCH_OPERATION_KEY" javaType="java.lang.String"/>
      <arg column="STATE"
        javaType="io.camunda.search.entities.BatchOperationEntity$BatchOperationState"/>
      <arg column="OPERATION_TYPE" javaType="java.lang.String"/>
      <arg column="START_DATE" javaType="java.time.OffsetDateTime"/>
      <arg column="END_DATE" javaType="java.time.OffsetDateTime"/>
      <arg column="OPERATIONS_TOTAL_COUNT" javaType="int"/>
      <arg column="OPERATIONS_FAILED_COUNT" javaType="int"/>
      <arg column="OPERATIONS_COMPLETED_COUNT" javaType="int"/>
      <arg column="PARTITION_ID" javaType="int"/>
      <arg column="IS_LEAD" javaType="java.lang.Boolean"/>
    </constructor>
  </resultMap>

  <resultMap id="BatchOperationItemResultMap"
    type="io.camunda.search.entities.BatchOperationEntity$BatchOperationItemEntity">
    <constructor>
      <idArg column="BATCH_OPERATION_KEY" javaType="java.lang.String"/>
      <arg column="ITEM_KEY" javaType="java.lang.Long"/>
      <arg column="PROCESS_INSTANCE_KEY" javaType="java.lang.Long"/>
      <arg column="STATE"
        javaType="io.camunda.search.entities.BatchOperationEntity$BatchOperationItemState"/>
      <arg column="PROCESSED_DATE" javaType="java.time.OffsetDateTime"/>
      <arg column="ERROR_MESSAGE" javaType="java.lang.String"/>
    </constructor>
  </resultMap>

  <insert id="insert" parameterType="io.camunda.db.rdbms.write.domain.BatchOperationDbModel">
    INSERT INTO ${prefix}BATCH_OPERATION (BATCH_OPERATION_KEY,
                                 STATE,
    STATE_UPDATED_DATE,
                                 OPERATION_TYPE,
                                 START_DATE,
                                 END_DATE,
                                 OPERATIONS_TOTAL_COUNT,
                                 OPERATIONS_FAILED_COUNT,
                                          OPERATIONS_COMPLETED_COUNT,
                                          PARTITION_ID,
                                          IS_LEAD)
    VALUES (#{batchOperationKey},
            #{state},
    <include refid="io.camunda.db.rdbms.sql.Commons.now"/>,
            #{operationType},
            #{startDate},
            #{endDate},
            #{operationsTotalCount},
            #{operationsFailedCount},
            #{operationsCompletedCount},
            #{partitionId},
            #{isLead})
  </insert>

  <insert id="insertItems"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationItemsDto">
    INSERT INTO ${prefix}BATCH_OPERATION_ITEM (BATCH_OPERATION_KEY, ITEM_KEY, PROCESS_INSTANCE_KEY,
    PARTITION_ID)
    VALUES
    <foreach collection="items" item="item" separator=",">
      (#{batchOperationKey}, #{item.itemKey}, #{item.processInstanceKey}, #{partitionId})
    </foreach>
  </insert>

  <update id="updateCompleted"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationUpdateDto">
    UPDATE ${prefix}BATCH_OPERATION
    SET STATE = #{state},
        END_DATE = #{endDate}
    WHERE BATCH_OPERATION_KEY = #{batchOperationKey}
      AND PARTITION_ID = #{partitionId}
  </update>

  <update id="updateItem"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationItemDto">
    UPDATE ${prefix}BATCH_OPERATION_ITEM
    SET STATE = #{state},
        PROCESSED_DATE = #{processedDate},
        ERROR_MESSAGE = #{errorMessage}
    WHERE BATCH_OPERATION_KEY = #{batchOperationKey}
      AND ITEM_KEY = #{itemKey}
  </update>

  <update id="updateItemsWithState"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationItemStatusUpdateDto">
    UPDATE ${prefix}BATCH_OPERATION_ITEM
    SET STATE = #{newState}
    WHERE BATCH_OPERATION_KEY = #{batchOperationKey}
      AND PARTITION_ID = #{partitionId}
      AND STATE = #{oldState}
  </update>

  <update id="incrementOperationsTotalCount"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationUpdateTotalCountDto">
    UPDATE ${prefix}BATCH_OPERATION
    SET OPERATIONS_TOTAL_COUNT = OPERATIONS_TOTAL_COUNT + #{operationsTotalCount}
    WHERE BATCH_OPERATION_KEY = #{batchOperationKey}
      AND PARTITION_ID = #{partitionId}
  </update>

  <update id="incrementFailedOperationsCount"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationUpdateCountsDto">
    UPDATE ${prefix}BATCH_OPERATION t
    SET OPERATIONS_FAILED_COUNT = OPERATIONS_FAILED_COUNT + 1
    WHERE BATCH_OPERATION_KEY = #{batchOperationKey}
      AND PARTITION_ID = #{partitionId}
    AND EXISTS(
      SELECT 1
      FROM ${prefix}BATCH_OPERATION_ITEM i
      WHERE i.BATCH_OPERATION_KEY = t.BATCH_OPERATION_KEY
      AND i.ITEM_KEY = #{itemKey}
    )
  </update>

  <update id="incrementCompletedOperationsCount"
    parameterType="io.camunda.db.rdbms.sql.BatchOperationMapper$BatchOperationUpdateCountsDto">
    UPDATE ${prefix}BATCH_OPERATION t
    SET OPERATIONS_COMPLETED_COUNT = OPERATIONS_COMPLETED_COUNT + 1
    WHERE BATCH_OPERATION_KEY = #{batchOperationKey}
      AND PARTITION_ID = #{partitionId}
      AND EXISTS(
      SELECT 1
      FROM ${prefix}BATCH_OPERATION_ITEM i
      WHERE i.BATCH_OPERATION_KEY = t.BATCH_OPERATION_KEY
        AND i.ITEM_KEY = #{itemKey}
    )
  </update>

  <select id="count" resultType="java.lang.Long">
      Select count(*) from batch_operation
           inner join (Select batch_operation_key,
                MAX(state_updated_date)         AS last_state_updated_date
             from batch_operation
             group by batch_operation.batch_operation_key
           ) as groupedByKeyAndStatus
      on batch_operation.batch_operation_key = groupedByKeyAndStatus.batch_operation_key
        and batch_operation.state_updated_date = groupedByKeyAndStatus.last_state_updated_date
    <include refid="io.camunda.db.rdbms.sql.BatchOperationMapper.searchFilter"/>
  </select>

  <select id="search"
    parameterType="io.camunda.db.rdbms.read.domain.BatchOperationDbQuery"
    resultMap="BatchOperationResultMap"
    statementType="PREPARED">
    SELECT * FROM (
    Select batch_operation.batch_operation_key,
           batch_operation.state,
           batch_operation.operation_type,
           batch_operation.start_date,
           batch_operation.end_date,
           groupedByKeyAndStatus.operations_completed_count,
           groupedByKeyAndStatus.operations_failed_count,
           groupedByKeyAndStatus.operations_total_count,
           batch_operation.partition_id,
           batch_operation.is_lead
    from batch_operation
           inner join (Select batch_operation_key,
                MAX(state_updated_date)         AS last_state_updated_date,
                SUM(operations_completed_count) as operations_completed_count,
                SUM(operations_failed_count)    as operations_failed_count,
                SUM(operations_total_count)     as operations_total_count
             from batch_operation
             group by batch_operation.batch_operation_key
           ) as groupedByKeyAndStatus
      on batch_operation.batch_operation_key = groupedByKeyAndStatus.batch_operation_key
        and batch_operation.state_updated_date = groupedByKeyAndStatus.last_state_updated_date
    <include refid="io.camunda.db.rdbms.sql.BatchOperationMapper.searchFilter"/>
    ) t
    <include refid="io.camunda.db.rdbms.sql.Commons.keySetPageFilter"/>
    <include refid="io.camunda.db.rdbms.sql.Commons.orderBy"/>
    <include refid="io.camunda.db.rdbms.sql.Commons.paging"/>
  </select>

  <sql id="searchFilter">
    WHERE 1 = 1
    <!-- basic filters -->
    <if test="filter.batchOperationIds != null and !filter.batchOperationIds.isEmpty()">
      AND BATCH_OPERATION_KEY IN
      <foreach collection="filter.batchOperationIds" item="value" open="(" separator=", "
        close=")">#{value}
      </foreach>
    </if>
    <if test="filter.operationTypes != null and !filter.operationTypes.isEmpty()">
      AND OPERATION_TYPE IN
      <foreach collection="filter.operationTypes" item="value" open="(" separator=", " close=")">
        #{value}
      </foreach>
    </if>
    <if test="filter.state != null and !filter.state.isEmpty()">
      AND STATE IN
      <foreach collection="filter.state" item="value" open="(" separator=", " close=")">#{value}
      </foreach>
    </if>
  </sql>

  <select id="countItems" resultType="java.lang.Long">
    SELECT COUNT(*)
    FROM ${prefix}BATCH_OPERATION_ITEM
    <include refid="io.camunda.db.rdbms.sql.BatchOperationMapper.itemSearchFilter"/>
  </select>

  <select id="searchItems"
    parameterType="io.camunda.db.rdbms.read.domain.BatchOperationItemDbQuery"
    resultMap="BatchOperationItemResultMap"
    statementType="PREPARED">

    SELECT * FROM (
    SELECT BATCH_OPERATION_KEY, ITEM_KEY, PROCESS_INSTANCE_KEY, STATE, PROCESSED_DATE, ERROR_MESSAGE
    FROM ${prefix}BATCH_OPERATION_ITEM
    <include refid="io.camunda.db.rdbms.sql.BatchOperationMapper.itemSearchFilter"/>
    ) filtered
    <include refid="io.camunda.db.rdbms.sql.Commons.keySetPageFilter"/>
    <include refid="io.camunda.db.rdbms.sql.Commons.orderBy"/>
    <include refid="io.camunda.db.rdbms.sql.Commons.paging"/>
  </select>

  <sql id="itemSearchFilter">
    WHERE 1 = 1
    <!-- basic filters -->
    <if test="filter.batchOperationIds != null and !filter.batchOperationIds.isEmpty()">
      AND BATCH_OPERATION_KEY IN
      <foreach collection="filter.batchOperationIds" item="value" open="(" separator=", "
        close=")">#{value}
      </foreach>
    </if>
    <if test="filter.itemKeys != null and !filter.itemKeys.isEmpty()">
      AND ITEM_KEYS IN
      <foreach collection="filter.itemKeys" item="value" open="(" separator=", " close=")">
        #{value}
      </foreach>
    </if>
    <if test="filter.processInstanceKeys != null and !filter.processInstanceKeys.isEmpty()">
      AND PROCESS_INSTANCE_KEY IN
      <foreach collection="filter.processInstanceKeys" item="value" open="(" separator=", " close=")">#{value}
      </foreach>
    </if>
    <if test="filter.state != null and !filter.state.isEmpty()">
      AND STATE IN
      <foreach collection="filter.state" item="value" open="(" separator=", " close=")">#{value}
      </foreach>
    </if>
  </sql>

</mapper>
