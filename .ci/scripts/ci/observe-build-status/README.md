# JUnit Test Results to JSONL Converter

## Overview

This Python script converts JUnit XML test result files into JSON Lines (JSONL) format for CI analytics and monitoring purposes. It's designed to process test results from the Camunda build system and extract meaningful metrics for analysis.

## What it does

The script:
- **Parses JUnit XML files** - Reads standard JUnit XML test result files
- **Handles flaky test detection** - Identifies tests marked as flaky (files ending with `FLAKY.xml`)
- **Extracts test metrics** - Captures test names, class names, durations, and status
- **Deduplicates results** - Prioritizes flaky test results over regular results for the same test
- **Outputs JSONL format** - Each test result becomes one JSON object per line

## Input Expectations

### Input Method

- **Reads from stdin**: File paths are provided via standard input, one file path per line
- **File format**: Expects JUnit XML files (typically named `TEST-*.xml`)
- **Flaky test detection**: Files ending with `FLAKY.xml` are treated as flaky test results. Results are generated by a maven [flaky-extractor-maven-plugin](https://github.com/camunda/flaky-test-extractor-maven-plugin)

### XML Structure Expected

The script expects standard JUnit XML format:

```xml
<testsuite name="..." time="..." tests="..." failures="..." errors="...">
  <testcase classname="com.example.TestClass" name="testMethod" time="0.123">
    <!-- Optional failure/error/skipped elements -->
    <failure message="...">...</failure>
  </testcase>
</testsuite>
```

## Output Format

Each line of output is a JSON object with the following structure:

```json
{
  "test_class_name": "com.example.TestClass",
  "test_class_duration_milliseconds": 1500,
  "test_name": "testMethodName",
  "test_duration_milliseconds": 123,
  "test_status": "success|failure|error|skipped|flaky"
}
```

### Field Descriptions

- `test_class_name`: The Java class name containing the test
- `test_class_duration_milliseconds`: Total duration of the test suite in milliseconds
- `test_name`: The test method name (with " (Flaky Test)" suffix removed if present)
- `test_duration_milliseconds`: Individual test execution time in milliseconds
- `test_status`: One of:
  - `success`: Test passed
  - `failure`: Test failed with assertion error
  - `error`: Test failed with unexpected error
  - `skipped`: Test was skipped
  - `flaky`: Test is marked as flaky (from `FLAKY.xml` files)

## Usage Examples

### Basic Usage (Command Line)

```bash
# Find XML files and pipe to the script
find . -name "TEST-*.xml" | python3 junit-test-results-to-jsonl.py > results.jsonl
```

### GitHub Actions Usage

```yaml
- name: Convert test results to JSONL
  shell: bash
  run: |
    find . -iname 'TEST-*.xml' | python3 .ci/scripts/ci/observe-build-status/junit-test-results-to-jsonl.py > test-results.jsonl
```

### Processing Output

```bash
# Count total tests
wc -l < results.jsonl

# Count failed tests
grep '"test_status":"failure"' results.jsonl | wc -l

# Extract flaky tests
grep '"test_status":"flaky"' results.jsonl | jq -r '.test_name'
```

## Key Features

### Flaky Test Handling

- Tests from `*FLAKY.xml` files are automatically marked with `test_status: "flaky"`
- If the same test appears in both regular and flaky results, only the flaky version is included
- This prevents double-counting of flaky tests

### Error Handling

- Gracefully handles malformed XML files
- Continues processing other files if one file fails
- Errors are written to stderr, not mixed with JSONL output

### Performance Optimizations

- Uses stdin for file paths to avoid ARG_MAX limitations with large numbers of files
- Processes files in streaming fashion to handle large test suites
- Two-pass processing ensures flaky test deduplication

## Integration Context

This script is typically used as part of the Camunda CI/CD pipeline:

1. **Test Execution**: Maven/Gradle runs tests and generates JUnit XML files
2. **File Discovery**: CI finds all `TEST-*.xml` files in the workspace
3. **Conversion**: This script converts XML to JSONL format
4. **Analytics**: JSONL data is submitted to CI analytics systems for monitoring

## Dependencies

- **Python 3.x** (uses built-in libraries only)
  - `xml.etree.ElementTree` - XML parsing
  - `json` - JSON serialization
  - `sys` - Standard I/O operations

No external dependencies required - uses only Python standard library.

## Error Scenarios

The script handles these error conditions:
- **Malformed XML**: Logs error to stderr and continues with other files
- **Missing attributes**: Uses defaults (0 for time, empty string for names)
- **File access issues**: Reports error and continues processing
- **Empty input**: Produces no output (not an error)

## Output Validation

The generated JSONL can be validated to ensure all required fields are present:

```bash
# Check for required fields
jq -c 'select((has("test_name") and has("test_status")) | not)' results.jsonl
```

If this command produces output, there are invalid lines missing required fields.
