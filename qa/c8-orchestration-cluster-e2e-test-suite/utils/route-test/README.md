# route-test utility

Declarative, spec‑driven HTTP response shape assertions for the Camunda Orchestration Cluster E2E Playwright test suite.

This helper wires the OpenAPI–derived `responses.json` (produced by the `response-required-extractor` tool) into Playwright fixtures so tests can validate the structural shape of JSON responses without re‑encoding the contract manually.

## What it gives you

* `routePath`, `routeMethod`, `routeStatus` fixtures – declaratively pick the response schema you want validated.
* `routeCtx` – exposes resolved method, status, required & optional field specs for the chosen route.
* `expectResponseShape(body)` – validates (recursively):
  * All required fields exist (top‑level + nested)
  * Types of required and present optional fields
  * Enum membership (when enum metadata present)
  * Wrapper primitives (object shells that wrap a primitive) using their underlying primitive
  * Array element types (samples up to a cap to keep cost bounded)
  * Rejects unexpected additional properties (emits `[EXTRA]`)
* Fast fail if:
  * The path does not exist in `responses.json`
  * A method/status filter combination has no matching spec entry

## Where the spec data comes from

`responses.json` (default) lives at:
```
qa/c8-orchestration-cluster-e2e-test-suite/response-required-extractor/output/responses.json
```
It is generated by the `response-required-extractor` package which flattens OpenAPI schemas (resolving `$ref`, `allOf`, enums, wrappers, etc). Regenerate it whenever the upstream OpenAPI spec changes.

Override for experiments / unit tests:

Set `ROUTE_TEST_RESPONSES_FILE=/abs/or/relative/path/to/responses.json` to load an alternate schema set (used by `validator.spec.ts`).

## Fixtures overview

| Fixture | Type | Purpose |
|--------|------|---------|
| `routePath` | `string` | The API path (e.g. `/authentication/me`) – REQUIRED for shape validation. |
| `routeMethod` | `string?` | Optional HTTP method filter (e.g. `GET`). Case‑insensitive. |
| `routeStatus` | `string?` | Optional status code filter (e.g. `200`). |
| `routeCtx` | `RouteContext` | Resolved schema context: method, status, required/optional field specs. |
| `expectResponseShape` | `(body: unknown) => void` | Performs validation, throwing aggregated errors. |

If `routeMethod` / `routeStatus` are omitted the selector heuristics prefer:
1. `GET 200`
2. Any `200`
3. `201`
4. First available entry

## Error format

Errors aggregate with a header:
```
Response shape errors for route GET 200 /authentication/me:
[MISSING] /id expected string
[TYPE] /items/0/state expected enum<string>[ACTIVE|FAILED] but got number
[ENUM] /status value "PENDING" not in [ACTIVE, INACTIVE]
...and 3 more
```

* JSON Pointers (RFC 6901) identify locations.
* Tags: `[MISSING]`, `[TYPE]`, `[ENUM]`, `[EXTRA]`.
* Wrapper primitives display as e.g. `string (wrapper SomeWrapper)`.

## Quick example

```ts
import {routeTest as test, expect} from './utils/route-test';

// Apply at describe scope so each test gets the schema context
test.describe('Current user', () => {
  test.use({
    routePath: '/authentication/me',
    routeMethod: 'GET',
    routeStatus: '200',
  });

  test('shape + a business assertion', async ({request, expectResponseShape, routeCtx}) => {
    const res = await request.get(`/authentication/me`);
    expect(res.status()).toBe(200);
    const body = await res.json();

    // Contract assertion (structure + types + enums)
    expectResponseShape(body);

    // You can still perform semantic checks:
    expect(body.username).toBeDefined();
  expect(routeCtx.requiredFieldNames).toContain('username');
  // Any undeclared key would now trigger an [EXTRA] error.
  });
});
```

## Multiple endpoints in one describe

If a single `describe` contains tests hitting different endpoints (so a static `routePath` fixture isn't suitable) you have three options:

1. Split into nested `describe` blocks, each with its own `test.use({ routePath, routeMethod, routeStatus })`.
2. Set `routePath` dynamically at test level with `test.use({...})` as the first line of the test (Playwright applies it for that test only).
3. Use the ad‑hoc helper `expectResponseShapeFor({ path, method, status }, body, testInfo)` which bypasses the fixture and performs a one‑off lookup + validation.

Example using the helper:
```ts
import {routeTest as test, expectResponseShapeFor} from './utils/route-test';

test('mixed endpoints example', async ({request}, testInfo) => {
  const searchRes = await request.post('/groups/search', { data: { filter: { name: 'abc' }}});
  const searchJson = await searchRes.json();
  expectResponseShapeFor({ path: '/groups/search', method: 'POST', status: '200' }, searchJson, testInfo);

  const getRes = await request.get('/groups/123');
  const getJson = await getRes.json();
  expectResponseShapeFor({ path: '/groups/{groupId}', method: 'GET', status: '200' }, getJson, testInfo);
});
```

Trade‑offs:
* Fixture approach (options 1/2) gives you `routeCtx` automatically.
* Helper approach (option 3) is concise for sporadic validations and still records bodies / deep presence.

## Selecting a specific response variant

If multiple responses share a path (different methods / statuses) you can narrow:
```ts
test.use({ routePath: '/jobs/search', routeMethod: 'POST', routeStatus: '200' });
```
If the combination doesn’t exist you get a descriptive error listing available `(method status)` pairs.

## When a path is new
If you write a test before the extractor has produced an entry for that path you will get:
```
Error: No OpenAPI response spec entries found for path /new/path
```
Regenerate `responses.json` (or add the missing spec) before continuing.

## Custom / partial validation
If you need only a subset of checks you can still inspect `routeCtx.requiredFields` & `routeCtx.optionalFields` directly—`expectResponseShape` is opt‑in per test.

## Recommendations

* Always set `routePath` at `describe` scope to avoid per‑test boilerplate.
* Keep business assertions (ordering, cross‑field logic) separate from structural validation – fail fast on shape so debugging remains clear.
* Regenerate the extractor output in CI as part of the spec update workflow, and commit the artifact (for deterministic tests).

## Extending
Possible future enhancements (open to contribution):
* Allow ignoring specific fields (`test.use({ routeIgnore: ['/complex/debug'] })`).
* Pluggable scalar coercion (e.g. treat numeric strings as numbers).
* Snapshot diff mode comparing actual object against a synthesized minimal skeleton of required fields.

## Response body recorder (experimental)

If you set the environment variable `TEST_RESPONSE_BODY_RECORD_DIR` the fixture will append each observed response body to a JSON Lines (`.jsonl`) file per route variant:

File naming pattern:
```
<METHOD>_<STATUS>_<sanitized-path>.jsonl
```
Example path `/authentication/me` (GET 200):
```
GET_200_authentication_me.jsonl
```

Each line is a JSON object:
```json
{
  "ts": "2025-09-24T12:34:56.789Z",
  "route": "/authentication/me",
  "method": "GET",
  "status": "200",
  "test": "Authentication API Tests > Get Current User shape & content",
  "required": ["username", "userId"],
  "present": ["username", "userId", "roles", "tenants"],
  "deepPresent": ["/username", "/roles", "/roles/*", "/tenants", "/tenants/*/tenantId"],
  "body": { /* full response body */ }
}
```

Purpose:
* Empirically detect fields that are always present yet marked optional in the spec.
* Build frequency / presence statistics offline to propose promoting fields to required.

Notes:
* Both top‑level (`present`) and recursive JSON Pointer style paths (`deepPresent`) are collected. Arrays use `*` as a wildcard segment.
* Recorder is best-effort; IO errors are swallowed to avoid test flakiness.
* Directory is created if missing.

Example aggregation (bash + jq):
```bash
jq -r '.present[]' GET_200_authentication_me.jsonl | sort | uniq -c | sort -nr
```

You can then diff the stable `required` list with high-frequency `present` keys to propose contract tightening.

### Summarizer script

Use `summarize-recordings.ts` to propose candidates for promotion to required:

```bash
ts-node utils/route-test/summarize-recordings.ts ./response-observations 100 > promote-report.json
```

Arguments:
* directory (defaults to `TEST_RESPONSE_BODY_RECORD_DIR`)
* threshold percentage (default 100 = appears in every sample)

Output JSON includes `items[].promote[]` with fields that meet the threshold (top-level and deep). Deep paths appear as JSON Pointers (arrays wildcarded with `*`).

### Spec diff (focused promotion candidates)

For a spec‑aware diff that only lists optional spec fields (and deep paths under those optional parents) that meet a promotion threshold, use:

```bash
ts-node utils/route-test/diff-recordings-vs-spec.ts ./response-observations 100 > promotion.json
```

Arguments (positional):
1. Recordings directory (defaults to `TEST_RESPONSE_BODY_RECORD_DIR` if omitted)
2. Threshold percent (default `100`)

Differences vs `summarize-recordings.ts`:
* Filters out fields already required.
* Excludes fields not declared in the spec (never suggests extras).
* Adds deep path suggestions only when their top-level optional parent also meets the threshold.
* Emits a concise human summary to stderr and a structured JSON payload to stdout.

JSON shape:
```json
{
  "generatedAt": "...",
  "thresholdPct": 100,
  "totalGroups": 3,
  "items": [
    {
      "route": "/v1/things",
      "method": "GET",
      "status": "200",
      "samples": 42,
      "specRequired": ["id"],
      "specOptional": ["foo", "bar"],
      "candidates": [
        {"field": "foo", "pct": 100, "count": 42, "level": "top", "reason": "..."}
      ]
    }
  ]
}
```

Use this output to drive a manual or automated promotion workflow (e.g. patching the OpenAPI or regenerating `responses.json`).

---
Maintained within `utils/route-test`. See `index.ts` for implementation details.
