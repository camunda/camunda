/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under
 * one or more contributor license agreements. See the NOTICE file distributed
 * with this work for additional information regarding copyright ownership.
 * Licensed under the Camunda License 1.0. You may not use this file
 * except in compliance with the Camunda License 1.0.
 */
package io.camunda.configuration;

import static org.assertj.core.api.Assertions.assertThat;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class GenerateDefaultsTest {

  @TempDir Path tempDir;

  @Nested
  class IntegrationTests {

    @Test
    void shouldGenerateYamlFromMetadata() throws IOException {
      // given
      final var inputFile = createTestMetadataFile();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(inputFile.toFile(), output.toFile());

      // then
      assertThat(output).exists();
      final var content = Files.readString(output);

      // Check header is present
      assertThat(content).contains("# This file is AUTO-GENERATED");
      assertThat(content).contains("# DO NOT edit this file manually");

      // Check property is present with correct format
      assertThat(content).contains("test:");
      assertThat(content).contains("  property: \"default-value\"");

      // Check metadata comments are present
      assertThat(content).contains("# Type:");
      assertThat(content).contains("Env: TEST_PROPERTY");
    }

    @Test
    void shouldIncludeDescriptionsInComments() throws IOException {
      // given
      final var inputFile = createTestMetadataFile();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(inputFile.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content).contains("# A test property description");
    }

    @Test
    void shouldCleanHtmlTagsFromDescriptions() throws IOException {
      // given
      final var input = createTestMetadataWithHtml();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content)
          .contains("# Description with link: https://example.com")
          .doesNotContain("<a href")
          .doesNotContain("</a>");
    }

    @Test
    void shouldGenerateEnvironmentVariableNames() throws IOException {
      // given
      final var input = createTestMetadataFile();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content).contains("Env: TEST_PROPERTY");
    }

    @Test
    void shouldSkipDeprecatedProperties() throws IOException {
      // given
      final var input = createTestMetadataWithDeprecated();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content).doesNotContain("deprecated-property").contains("test:");
    }

    @Test
    void shouldHandleNestedProperties() throws IOException {
      // given
      final var input = createNestedMetadataFile();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content)
          .contains("test:")
          .contains("  nested:")
          .contains("    property: \"value\"");
    }

    @Test
    void shouldVerifyMatchingFiles() throws IOException {
      // given
      final var input = createTestMetadataFile();
      final var output = tempDir.resolve("output.yaml");

      // Generate the file first
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // when/then - verification should pass without exception
      GenerateDefaults.verify(input.toFile(), output.toFile());
    }

    private Path createTestMetadataFile() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.property",
              "type": "java.lang.String",
              "description": "A test property description",
              "defaultValue": "default-value",
              "deprecated": false
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    private Path createTestMetadataWithHtml() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.property",
              "type": "java.lang.String",
              "description": "Description with link: <a href=\\"https://example.com\\">example</a>",
              "defaultValue": "value",
              "deprecated": false
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    private Path createTestMetadataWithDeprecated() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.property",
              "type": "java.lang.String",
              "description": "Active property",
              "defaultValue": "value",
              "deprecated": false
            },
            {
              "name": "deprecated-property",
              "type": "java.lang.String",
              "description": "Old property",
              "defaultValue": "old",
              "deprecated": true
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    private Path createNestedMetadataFile() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.nested.property",
              "type": "java.lang.String",
              "description": "A nested property",
              "defaultValue": "value",
              "deprecated": false
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    @Test
    void shouldReplaceJavadocCodeTagsWithMarkdown() throws IOException {
      // given
      final var input = createTestMetadataWithJavadocCode();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content)
          .contains("# Max pool size is `availableProcessors *# maxPoolSizeMultiplier` for now")
          .contains("# Code with spaces `some code here` should work")
          .doesNotContain("{@code");
    }

    private Path createTestMetadataWithJavadocCode() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.property",
              "type": "java.lang.String",
              "description": "Max pool size is {@code availableProcessors *# maxPoolSizeMultiplier} for now",
              "defaultValue": "value",
              "deprecated": false
            },
            {
              "name": "test.spaces",
              "type": "java.lang.String",
              "description": "Code with spaces {@code some code here} should work",
              "defaultValue": "value",
              "deprecated": false
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    @Test
    void shouldHandleMultiLineDescriptions() throws IOException {
      // given
      final var input = createTestMetadataWithLongDescription();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      // Each line should start with # and be followed by indentation if it's a property
      assertThat(content)
          .contains("# This is a very long description that should be wrapped into multiple lines")
          .contains("# starts with a hash mark and is correctly indented.");
    }

    private Path createTestMetadataWithLongDescription() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.long.property",
              "type": "java.lang.String",
              "description": "This is a very long description that should be wrapped into multiple lines to ensure that each line starts with a hash mark and is correctly indented.",
              "defaultValue": "value",
              "deprecated": false
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    @Test
    void shouldHandleParagraphTags() throws IOException {
      // given
      final var input = createTestMetadataWithParagraphs();
      final var output = tempDir.resolve("output.yaml");

      // when
      GenerateDefaults.generate(input.toFile(), output.toFile());

      // then
      final var content = Files.readString(output);
      assertThat(content).contains("  # Line 1");
      assertThat(content).contains("  # Line 2");
      assertThat(content).doesNotContain("\n  Line 2");
    }

    private Path createTestMetadataWithParagraphs() throws IOException {
      final var metadata =
          """
        {
          "groups": [],
          "properties": [
            {
              "name": "test.paragraph",
              "type": "java.lang.String",
              "description": "Line 1 <p> Line 2",
              "defaultValue": "value",
              "deprecated": false
            }
          ]
        }
        """;
      return writeJsonFile(metadata);
    }

    private Path writeJsonFile(final String content) throws IOException {
      final var file = tempDir.resolve("metadata.json");
      Files.writeString(file, content);
      return file;
    }
  }
}
