# description: Adds release comments to issues that were fixed in recent releases
# type: CI Helper
# owner: @v.heinila

---
name: Add Release Comments to Issues

on:
  workflow_dispatch:
    inputs:
      days_back:
        description: 'Number of days back to look for releases (default: 10)'
        required: false
        default: '10'
      dry_run:
        description: 'Dry run - only log what would be done, do not post comments'
        required: false
        type: boolean
        default: false

env:
  GHA_BEST_PRACTICES_LINTER: enabled

permissions: {}

jobs:
  add-release-comments:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    defaults:
      run:
        shell: bash
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4
        with:
          fetch-depth: 0

      - name: Add release comments to issues
        env:
          GH_TOKEN: ${{ github.token }}
          DAYS_BACK: ${{ github.event.inputs.days_back || '10' }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        shell: bash
        run: |
          set -euo pipefail
          
          # Calculate the date to look back from
          CUTOFF_DATE=$(date -d "-${DAYS_BACK} days" --iso-8601)
          echo "Looking for releases since: $CUTOFF_DATE"
          
          # Fetch releases from GitHub API
          echo "Fetching recent releases..."
          RELEASES=$(gh api repos/${{ github.repository }}/releases \
            --jq ".[] | select(.published_at > \"$CUTOFF_DATE\") | {tag_name, html_url, published_at, body}" \
            --paginate)
          
          if [ -z "$RELEASES" ]; then
            echo "No releases found since $CUTOFF_DATE"
            exit 0
          fi
          
          echo "Found releases:"
          echo "$RELEASES" | jq -r '.tag_name + " - " + .published_at'
          
          # Process each release
          echo "$RELEASES" | jq -c '.' | while read -r release; do
            TAG_NAME=$(echo "$release" | jq -r '.tag_name')
            RELEASE_URL=$(echo "$release" | jq -r '.html_url')
            PUBLISHED_AT=$(echo "$release" | jq -r '.published_at')
            RELEASE_BODY=$(echo "$release" | jq -r '.body')
            
            echo ""
            echo "Processing release: $TAG_NAME ($PUBLISHED_AT)"
            echo "Release URL: $RELEASE_URL"
            
            # Extract issue numbers from release body
            # Look for various patterns like #1234, camunda/camunda#1234, issues/1234, etc.
            # Also extract from markdown links like [#1234](url) and full GitHub URLs
            ISSUE_NUMBERS=$(echo "$RELEASE_BODY" | \
              grep -oE '(\#|issues?[/#]|issue[/#]|camunda/camunda\#)[0-9]+|\[#[0-9]+\]|github\.com/camunda/camunda/(issues|pull)/[0-9]+' | \
              grep -oE '[0-9]+' | \
              sort -u || true)
            
            if [ -z "$ISSUE_NUMBERS" ]; then
              echo "No issue references found in release $TAG_NAME"
              continue
            fi
            
            echo "Found issue references: $(echo "$ISSUE_NUMBERS" | tr '\n' ' ')"
            
            # Process each issue
            for ISSUE_NUMBER in $ISSUE_NUMBERS; do
              echo "  Checking issue #$ISSUE_NUMBER..."
              
              # Get issue details to verify it's an issue (not a PR) and check if comment already exists
              ISSUE_INFO=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER 2>/dev/null || true)
              
              if [ -z "$ISSUE_INFO" ]; then
                echo "    Issue #$ISSUE_NUMBER not found or not accessible"
                continue
              fi
              
              # Check if this is a pull request (PRs have pull_request field)
              IS_PR=$(echo "$ISSUE_INFO" | jq -r '.pull_request // empty')
              if [ -n "$IS_PR" ]; then
                echo "    Skipping #$ISSUE_NUMBER - it's a pull request"
                continue
              fi
              
              # Check if the issue is closed (we typically only comment on resolved issues)
              STATE=$(echo "$ISSUE_INFO" | jq -r '.state')
              if [ "$STATE" != "closed" ]; then
                echo "    Skipping #$ISSUE_NUMBER - issue is not closed (state: $STATE)"
                continue
              fi
              
              # Check if we already commented about this release
              COMMENT_EXISTS=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER/comments \
                --jq ".[] | select(.body | contains(\"released in version $TAG_NAME\")) | .id" | head -n 1 || true)
              
              if [ -n "$COMMENT_EXISTS" ]; then
                echo "    Skipping #$ISSUE_NUMBER - release comment already exists"
                continue
              fi
              
              # Prepare the comment
              COMMENT_BODY="This has been released in version [$TAG_NAME]($RELEASE_URL). See release notes [here]($RELEASE_URL) for details."
              
              if [ "$DRY_RUN" = "true" ]; then
                echo "    [DRY RUN] Would add comment to issue #$ISSUE_NUMBER:"
                echo "    Comment: $COMMENT_BODY"
              else
                echo "    Adding comment to issue #$ISSUE_NUMBER"
                gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER/comments \
                  -f body="$COMMENT_BODY" > /dev/null
                echo "    âœ“ Comment added successfully"
              fi
            done
          done
          
          echo ""
          echo "Release comment processing completed."

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}