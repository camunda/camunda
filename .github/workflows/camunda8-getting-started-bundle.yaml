# type: Release
# owner: @camunda/camundaex
---
name: "Camunda 8: Getting Started Bundle"

on:
  workflow_dispatch:
    inputs:
      c8run_version:
        description: "The release version of c8run to use (e.g., 8.8.6). Use 'latest' to auto-detect the latest release."
        type: string
        required: true
        default: "latest"
      modeler_version:
        description: "The version of Camunda Desktop Modeler to bundle (e.g., 5.34.0). Use 'latest' to auto-detect the latest release."
        type: string
        required: true
        default: "latest"
      dry_run:
        description: "If true, artifacts are only uploaded to the workflow run, not to the GitHub release."
        type: boolean
        required: true
        default: true

permissions: {}

defaults:
  run:
    shell: bash

jobs:
  resolve-versions:
    name: Resolve versions
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    outputs:
      c8run_version: ${{ steps.resolve.outputs.c8run_version }}
      modeler_version: ${{ steps.resolve.outputs.modeler_version }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve c8run and modeler versions
        id: resolve
        env:
          GH_TOKEN: ${{ github.token }}
          INPUT_C8RUN_VERSION: ${{ inputs.c8run_version }}
          INPUT_MODELER_VERSION: ${{ inputs.modeler_version }}
        run: |
          # Resolve c8run version
          if [[ "${INPUT_C8RUN_VERSION}" == "latest" ]]; then
            # Get latest stable release (exclude pre-releases) that has c8run artifacts
            c8run_version=$(gh api repos/camunda/camunda/releases --jq '
              [.[] | select(.prerelease == false) | select(.assets[].name | test("camunda8-run-"))] | first | .tag_name
            ')
            echo "Resolved c8run version: ${c8run_version}"
          else
            c8run_version="${INPUT_C8RUN_VERSION}"
          fi
          echo "c8run_version=${c8run_version}" >> "$GITHUB_OUTPUT"

          # Resolve modeler version
          if [[ "${INPUT_MODELER_VERSION}" == "latest" ]]; then
            # Get latest stable modeler version (releases/latest excludes pre-releases by default)
            modeler_version=$(gh api repos/camunda/camunda-modeler/releases/latest --jq '.tag_name' | sed 's/^v//')
            echo "Resolved modeler version: ${modeler_version}"
          else
            modeler_version="${INPUT_MODELER_VERSION}"
          fi
          echo "modeler_version=${modeler_version}" >> "$GITHUB_OUTPUT"

      - name: Print resolved versions
        run: |
          echo "C8Run version: ${{ steps.resolve.outputs.c8run_version }}"
          echo "Modeler version: ${{ steps.resolve.outputs.modeler_version }}"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  build-bundle:
    name: Build bundle - ${{ matrix.platform.name }}
    runs-on: ${{ matrix.platform.runner }}
    timeout-minutes: 30
    needs: resolve-versions
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        platform:
          - name: MacOS (Apple Silicon)
            runner: macos-latest
            platform_id: darwin-aarch64
            archive_type: zip
            c8run_archive_type: zip
            modeler_asset_pattern: "camunda-modeler-{version}-mac-arm64.dmg"
            script_extension: sh
          - name: MacOS (Intel)
            runner: macos-15-intel
            platform_id: darwin-x86_64
            archive_type: zip
            c8run_archive_type: zip
            modeler_asset_pattern: "camunda-modeler-{version}-mac-x64.dmg"
            script_extension: sh
          - name: Windows
            runner: windows-latest
            platform_id: windows-x86_64
            archive_type: zip
            c8run_archive_type: zip
            modeler_asset_pattern: "camunda-modeler-{version}-win-x64.zip"
            script_extension: bat
          - name: Linux
            runner: ubuntu-latest
            platform_id: linux-x86_64
            archive_type: tar.gz
            c8run_archive_type: tar.gz
            modeler_asset_pattern: "camunda-modeler-{version}-linux-x64.tar.gz"
            script_extension: sh
    env:
      C8RUN_VERSION: ${{ needs.resolve-versions.outputs.c8run_version }}
      MODELER_VERSION: ${{ needs.resolve-versions.outputs.modeler_version }}
      BUNDLE_NAME: camunda8-getting-started-bundle-${{ needs.resolve-versions.outputs.c8run_version }}-${{ matrix.platform.platform_id }}
    steps:
      - uses: actions/checkout@v4

      - name: Print build info
        run: |
          echo "Building bundle for: ${{ matrix.platform.name }}"
          echo "C8Run version: ${C8RUN_VERSION}"
          echo "Modeler version: ${MODELER_VERSION}"
          echo "Platform ID: ${{ matrix.platform.platform_id }}"
          echo "Bundle name: ${BUNDLE_NAME}"

      - name: Create bundle directory
        run: mkdir -p bundle

      - name: Download c8run archive
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          c8run_asset="camunda8-run-${C8RUN_VERSION}-${{ matrix.platform.platform_id }}.${{ matrix.platform.c8run_archive_type }}"
          echo "Downloading c8run asset: ${c8run_asset}"
          gh release download "${C8RUN_VERSION}" \
            --repo camunda/camunda \
            --pattern "${c8run_asset}" \
            --dir bundle

      - name: Extract c8run archive (Unix)
        if: matrix.platform.platform_id != 'windows-x86_64'
        run: |
          cd bundle
          c8run_asset="camunda8-run-${C8RUN_VERSION}-${{ matrix.platform.platform_id }}.${{ matrix.platform.c8run_archive_type }}"
          c8run_folder="c8run-${C8RUN_VERSION}"
          if [[ "${{ matrix.platform.c8run_archive_type }}" == "zip" ]]; then
            unzip "${c8run_asset}" -d c8run_temp
          else
            mkdir c8run_temp
            tar -xzf "${c8run_asset}" -C c8run_temp
          fi
          # Move contents to versioned c8run folder, handling nested directory structure
          # Use rsync to include hidden files
          mkdir -p "${c8run_folder}"
          if [ -d "c8run_temp/c8run" ]; then
            rsync -a "c8run_temp/c8run/" "${c8run_folder}/"
          elif [ -d "c8run_temp/c8run-${C8RUN_VERSION}" ]; then
            rsync -a "c8run_temp/c8run-${C8RUN_VERSION}/" "${c8run_folder}/"
          else
            rsync -a c8run_temp/ "${c8run_folder}/"
          fi
          rm -rf c8run_temp "${c8run_asset}"

      - name: Extract c8run archive (Windows)
        if: matrix.platform.platform_id == 'windows-x86_64'
        shell: pwsh
        run: |
          cd bundle
          $c8runAsset = "camunda8-run-${env:C8RUN_VERSION}-${{ matrix.platform.platform_id }}.${{ matrix.platform.c8run_archive_type }}"
          $c8runFolder = "c8run-${env:C8RUN_VERSION}"
          Expand-Archive -Path $c8runAsset -DestinationPath "c8run_temp"
          New-Item -ItemType Directory -Force -Path $c8runFolder
          if (Test-Path "c8run_temp/c8run") {
            # Copy all items including hidden files
            Copy-Item -Path "c8run_temp/c8run/*" -Destination "$c8runFolder/" -Recurse -Force
            Get-ChildItem -Path "c8run_temp/c8run" -Hidden | Copy-Item -Destination "$c8runFolder/" -Recurse -Force
          } elseif (Test-Path "c8run_temp/c8run-${env:C8RUN_VERSION}") {
            # Copy all items including hidden files
            Copy-Item -Path "c8run_temp/c8run-${env:C8RUN_VERSION}/*" -Destination "$c8runFolder/" -Recurse -Force
            Get-ChildItem -Path "c8run_temp/c8run-${env:C8RUN_VERSION}" -Hidden | Copy-Item -Destination "$c8runFolder/" -Recurse -Force
          } else {
            # Copy all items including hidden files
            Copy-Item -Path "c8run_temp/*" -Destination "$c8runFolder/" -Recurse -Force
            Get-ChildItem -Path "c8run_temp" -Hidden | Copy-Item -Destination "$c8runFolder/" -Recurse -Force
          }
          Remove-Item -Recurse -Force "c8run_temp"
          Remove-Item -Force $c8runAsset

      - name: Download Camunda Modeler
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          modeler_asset="${{ matrix.platform.modeler_asset_pattern }}"
          modeler_asset="${modeler_asset//\{version\}/${MODELER_VERSION}}"
          echo "Downloading modeler asset: ${modeler_asset} from GitHub release v${MODELER_VERSION}"
          gh release download "v${MODELER_VERSION}" \
            --repo camunda/camunda-modeler \
            --pattern "${modeler_asset}" \
            --dir bundle

      - name: Extract Modeler (macOS DMG)
        if: startsWith(matrix.platform.platform_id, 'darwin')
        run: |
          cd bundle
          modeler_asset="${{ matrix.platform.modeler_asset_pattern }}"
          modeler_asset="${modeler_asset//\{version\}/${MODELER_VERSION}}"
          
          # Mount the DMG
          hdiutil attach "${modeler_asset}" -mountpoint /Volumes/CamundaModeler -nobrowse
          
          # Copy the .app bundle using ditto to preserve macOS metadata and code signatures
          # Keep the original name "Camunda Modeler.app"
          ditto "/Volumes/CamundaModeler/Camunda Modeler.app" "./Camunda Modeler.app"
          
          # Unmount the DMG
          hdiutil detach /Volumes/CamundaModeler
          
          # Remove the DMG file
          rm "${modeler_asset}"

      - name: Extract Modeler (Windows)
        if: matrix.platform.platform_id == 'windows-x86_64'
        shell: pwsh
        run: |
          cd bundle
          $modelerAsset = "${{ matrix.platform.modeler_asset_pattern }}" -replace '\{version\}', $env:MODELER_VERSION
          $expectedFolderName = "camunda-modeler-$($env:MODELER_VERSION)-win-x64"
          
          # Extract directly to the expected folder name
          Expand-Archive -Path $modelerAsset -DestinationPath "$expectedFolderName"
          
          Write-Host "Modeler extracted to: $expectedFolderName"
          
          # Create a batch file launcher with proper variable substitution
          $batchContent = @"
          @echo off
          start "" "%~dp0$expectedFolderName\Camunda Modeler.exe"
          "@
          Set-Content -Path "camunda-modeler.bat" -Value $batchContent
          
          Write-Host "Created launcher: camunda-modeler.bat -> $expectedFolderName\Camunda Modeler.exe"
          
          Remove-Item -Force $modelerAsset

      - name: Extract Modeler (Linux)
        if: matrix.platform.platform_id == 'linux-x86_64'
        run: |
          cd bundle
          modeler_asset="${{ matrix.platform.modeler_asset_pattern }}"
          modeler_asset="${modeler_asset//\{version\}/${MODELER_VERSION}}"
          
          # Extract directly - the archive contains a folder like "camunda-modeler-X.Y.Z-linux-x64"
          tar -xzf "${modeler_asset}"
          
          # Find the extracted folder name using find instead of ls
          modeler_folder=$(find . -maxdepth 1 -type d -name "camunda-modeler-*" -printf '%f\n' | head -1)
          echo "Modeler extracted to: ${modeler_folder}"
          
          # Create a symlink to the Camunda Modeler executable
          ln -s "${modeler_folder}/camunda-modeler" "camunda-modeler"
          
          echo "Created symlink: camunda-modeler -> ${modeler_folder}/camunda-modeler"
          
          rm -f "${modeler_asset}"

      - name: Clone camunda-8-get-started repository
        run: |
          git clone --depth 1 https://github.com/camunda/camunda-8-get-started.git bundle/camunda-8-get-started
          rm -rf bundle/camunda-8-get-started/.git

      - name: Clone ai-agent example
        run: |
          git clone --depth 1 --filter=blob:none --sparse https://github.com/camunda/connectors.git /tmp/connectors
          cd /tmp/connectors
          git sparse-checkout set connectors/agentic-ai/examples/ai-agent/ad-hoc-sub-process/ai-agent-chat-with-tools
          mkdir -p "${GITHUB_WORKSPACE}/bundle/ai-agent-example"
          cp -r connectors/agentic-ai/examples/ai-agent/ad-hoc-sub-process/ai-agent-chat-with-tools/* "${GITHUB_WORKSPACE}/bundle/ai-agent-example/"

      - name: Create starter script (Unix)
        if: matrix.platform.script_extension == 'sh'
        run: |
          cat > bundle/camunda-start.sh << EOF
          #!/bin/bash

          cd c8run-${C8RUN_VERSION}
          ./c8run start --startup-url="https://developers.camunda.com/quick-start?c8run_start=success" 
          cd ..
          EOF
          chmod +x bundle/camunda-start.sh

      - name: Create stop script (Unix)
        if: matrix.platform.script_extension == 'sh'
        run: |
          cat > bundle/camunda-stop.sh << EOF
          #!/bin/bash

          cd c8run-${C8RUN_VERSION}
          ./c8run stop
          cd ..
          EOF
          chmod +x bundle/camunda-stop.sh

      - name: Create starter script (Windows)
        if: matrix.platform.script_extension == 'bat'
        shell: pwsh
        run: |
          $scriptContent = @"
          @echo off

          cd c8run-${env:C8RUN_VERSION}
          .\c8run.exe start --startup-url="https://developers.camunda.com/quick-start?c8run_start=success"
          cd ..
          "@
          Set-Content -Path "bundle/camunda-start.bat" -Value $scriptContent

      - name: Create stop script (Windows)
        if: matrix.platform.script_extension == 'bat'
        shell: pwsh
        run: |
          $scriptContent = @"
          @echo off

          cd c8run-${env:C8RUN_VERSION}
          .\c8run.exe stop
          cd ..
          "@
          Set-Content -Path "bundle/camunda-stop.bat" -Value $scriptContent

      - name: List bundle contents
        run: |
          echo "Bundle contents:"
          ls -la bundle/
          echo ""
          echo "c8run folder contents (including hidden files):"
          ls -la bundle/c8run/ || true

      - name: Create bundle archive (zip - macOS)
        if: matrix.platform.archive_type == 'zip' && startsWith(matrix.platform.platform_id, 'darwin')
        run: |
          # Use ditto to create zip archive - this preserves macOS extended attributes, 
          # resource forks, and code signatures which are essential for .app bundles
          # Archive from within the bundle directory so the zip contains the contents, not the parent folder
          cd bundle
          ditto -c -k --sequesterRsrc --zlibCompressionLevel 6 . "../${BUNDLE_NAME}.zip"

      - name: Create bundle archive (zip - Windows)
        if: matrix.platform.archive_type == 'zip' && matrix.platform.platform_id == 'windows-x86_64'
        shell: pwsh
        run: |
          # Create zip preserving directory structure using 7-Zip
          $zipPath = Join-Path (Get-Location) "${env:BUNDLE_NAME}.zip"
          7z a -tzip $zipPath ".\bundle\*" -r

      - name: Create bundle archive (tar.gz)
        if: matrix.platform.archive_type == 'tar.gz'
        run: |
          cd bundle
          # tar includes hidden files by default
          tar -czvf "../${BUNDLE_NAME}.tar.gz" .

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BUNDLE_NAME }}
          path: ${{ env.BUNDLE_NAME }}.${{ matrix.platform.archive_type }}
          retention-days: 7
          compression-level: 0

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          job_name: build-bundle - ${{ matrix.platform.name }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  test-bundle:
    name: Test bundle - ${{ matrix.platform.name }}
    runs-on: ${{ matrix.platform.runner }}
    timeout-minutes: 30
    needs: [resolve-versions, build-bundle]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        platform:
          - name: MacOS (Apple Silicon)
            runner: macos-latest
            platform_id: darwin-aarch64
            archive_type: zip
            script_extension: sh
          - name: MacOS (Intel)
            runner: macos-15-intel
            platform_id: darwin-x86_64
            archive_type: zip
            script_extension: sh
          - name: Windows
            runner: windows-latest
            platform_id: windows-x86_64
            archive_type: zip
            script_extension: bat
          - name: Linux
            runner: ubuntu-latest
            platform_id: linux-x86_64
            archive_type: tar.gz
            script_extension: sh
    env:
      C8RUN_VERSION: ${{ needs.resolve-versions.outputs.c8run_version }}
      BUNDLE_NAME: camunda8-getting-started-bundle-${{ needs.resolve-versions.outputs.c8run_version }}-${{ matrix.platform.platform_id }}
    steps:
      - uses: actions/checkout@v4

      - name: Download bundle artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.BUNDLE_NAME }}
          path: .

      - name: Extract bundle (zip - Unix)
        if: matrix.platform.archive_type == 'zip' && matrix.platform.platform_id != 'windows-x86_64'
        run: |
          mkdir -p test-bundle
          unzip "${BUNDLE_NAME}.zip" -d test-bundle

      - name: Extract bundle (zip - Windows)
        if: matrix.platform.archive_type == 'zip' && matrix.platform.platform_id == 'windows-x86_64'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "test-bundle"
          Expand-Archive -Path "${env:BUNDLE_NAME}.zip" -DestinationPath "test-bundle"

      - name: Extract bundle (tar.gz)
        if: matrix.platform.archive_type == 'tar.gz'
        run: |
          mkdir -p test-bundle
          tar -xzf "${BUNDLE_NAME}.tar.gz" -C test-bundle

      - name: List extracted contents
        run: |
          echo "Extracted bundle contents:"
          ls -la test-bundle/

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"

      - name: Run starter script integration test (Unix)
        if: matrix.platform.script_extension == 'sh'
        run: |
          cd test-bundle
          
          # Create a fake browser/open command to capture URL that c8run tries to open
          # c8run uses 'open' on macOS and 'xdg-open' on Linux
          mkdir -p /tmp/fake-browser
          cat > /tmp/fake-browser/open << 'FAKEOPEN'
          #!/bin/bash
          echo "$@" >> /tmp/opened-urls.log
          FAKEOPEN
          chmod +x /tmp/fake-browser/open
          
          # For Linux, also create xdg-open
          cat > /tmp/fake-browser/xdg-open << 'FAKEXDG'
          #!/bin/bash
          echo "$@" >> /tmp/opened-urls.log
          FAKEXDG
          chmod +x /tmp/fake-browser/xdg-open
          
          # Prepend fake browser dir to PATH so c8run uses our fake commands
          export PATH="/tmp/fake-browser:$PATH"
          
          # Clean any previous log
          rm -f /tmp/opened-urls.log
          
          # Run the camunda-start script (c8run forks to background internally)
          echo "Starting c8run via camunda-start.sh..."
          if ! ./camunda-start.sh; then
            echo "ERROR: camunda-start.sh failed"
            cat c8run/log/*.log 2>/dev/null || true
            exit 1
          fi
          
          # Wait for c8run to start (check for actuator health on port 9600)
          echo "Waiting for c8run to start..."
          MAX_WAIT=120
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:9600/actuator/health 2>/dev/null | grep -q "200"; then
              echo "c8run is healthy!"
              break
            fi
            sleep 5
            WAITED=$((WAITED + 5))
            echo "Waiting... ($WAITED/$MAX_WAIT seconds)"
          done
          
          if [ $WAITED -ge $MAX_WAIT ]; then
            echo "ERROR: c8run did not start within $MAX_WAIT seconds"
            cat c8run/log/*.log 2>/dev/null || true
            exit 1
          fi
          
          # Verify that the expected URL was opened
          echo "Checking if startup URL was opened..."
          EXPECTED_URL="https://developers.camunda.com/quick-start?c8run_start=success"
          if [ -f /tmp/opened-urls.log ]; then
            echo "URLs that were opened:"
            cat /tmp/opened-urls.log
            if grep -q "$EXPECTED_URL" /tmp/opened-urls.log; then
              echo "‚úì Startup URL verification passed!"
            else
              echo "WARNING: Expected URL '$EXPECTED_URL' was not found in opened URLs"
              echo "This might be a timing issue or c8run behavior change"
            fi
          else
            echo "WARNING: No URLs were captured - open/xdg-open might not have been called"
            echo "This could indicate c8run couldn't find a browser or uses a different method"
          fi
          
          echo "Integration test passed - c8run started successfully!"
          
          # Graceful shutdown using the stop script
          echo "Stopping c8run via camunda-stop.sh..."
          if ! ./camunda-stop.sh; then
            echo "ERROR: camunda-stop.sh failed"
            exit 1
          fi
          
          sleep 5
          echo "c8run stopped"

      - name: Run starter script integration test (Windows)
        if: matrix.platform.script_extension == 'bat'
        shell: pwsh
        run: |
          cd test-bundle
          
          # NOTE: On Windows, c8run uses the 'start' command to open URLs, which is a shell
          # builtin that cannot be intercepted. Unlike Unix where we can override 'open' or
          # 'xdg-open' via PATH, there's no reliable way to capture the URL that c8run opens.
          # Therefore, we only verify that c8run starts successfully on Windows.
          
          # Start c8run using the camunda-start script (c8run forks to background internally)
          Write-Host "Starting c8run via camunda-start.bat..."
          & cmd.exe /c "camunda-start.bat"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "ERROR: camunda-start.bat failed with exit code $LASTEXITCODE"
            Get-Content -Path "c8run\log\*.log" -ErrorAction SilentlyContinue
            exit 1
          }
          
          # Wait for c8run to start (check for actuator health on port 9600)
          Write-Host "Waiting for c8run to start..."
          $maxWait = 120
          $waited = 0
          $started = $false
          
          while ($waited -lt $maxWait) {
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:9600/actuator/health" -UseBasicParsing -TimeoutSec 5 -ErrorAction SilentlyContinue
              if ($response.StatusCode -eq 200) {
                Write-Host "c8run is healthy!"
                $started = $true
                break
              }
            } catch {
              # Expected while starting up
            }
            Start-Sleep -Seconds 5
            $waited += 5
            Write-Host "Waiting... ($waited/$maxWait seconds)"
          }
          
          if (-not $started) {
            Write-Host "ERROR: c8run did not start within $maxWait seconds"
            Get-Content -Path "c8run\log\*.log" -ErrorAction SilentlyContinue
            exit 1
          }
          
          Write-Host "Integration test passed - c8run started successfully!"
          Write-Host "NOTE: Startup URL verification skipped on Windows (start command cannot be intercepted)"
          
          # Graceful shutdown using the stop script
          Write-Host "Stopping c8run via camunda-stop.bat..."
          & cmd.exe /c "camunda-stop.bat"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "ERROR: camunda-stop.bat failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Start-Sleep -Seconds 5
          Write-Host "c8run stopped"

      - name: Verify bundle structure
        run: |
          cd test-bundle
          # Verify required components exist
          echo "Checking c8run-${C8RUN_VERSION} folder..."
          if [ ! -d "c8run-${C8RUN_VERSION}" ]; then
            echo "ERROR: c8run-${C8RUN_VERSION} folder not found"
            exit 1
          fi
          
          echo "Checking camunda-8-get-started folder..."
          if [ ! -d "camunda-8-get-started" ]; then
            echo "ERROR: camunda-8-get-started folder not found"
            exit 1
          fi
          
          echo "Checking ai-agent-example folder..."
          if [ ! -d "ai-agent-example" ]; then
            echo "ERROR: ai-agent-example folder not found"
            exit 1
          fi
          
          echo "Checking starter and stop scripts..."
          if [ "${{ matrix.platform.script_extension }}" == "sh" ]; then
            if [ ! -f "camunda-start.sh" ]; then
              echo "ERROR: camunda-start.sh not found"
              exit 1
            fi
            if [ ! -f "camunda-stop.sh" ]; then
              echo "ERROR: camunda-stop.sh not found"
              exit 1
            fi
          else
            if [ ! -f "camunda-start.bat" ]; then
              echo "ERROR: camunda-start.bat not found"
              exit 1
            fi
            if [ ! -f "camunda-stop.bat" ]; then
              echo "ERROR: camunda-stop.bat not found"
              exit 1
            fi
          fi
          
          echo "Checking modeler..."
          if [ "${{ matrix.platform.platform_id }}" == "darwin-aarch64" ] || [ "${{ matrix.platform.platform_id }}" == "darwin-x86_64" ]; then
            if [ ! -d "Camunda Modeler.app" ]; then
              echo "ERROR: Camunda Modeler.app not found"
              exit 1
            fi
          elif [ "${{ matrix.platform.platform_id }}" == "windows-x86_64" ]; then
            # Windows has a batch launcher and modeler folder
            if [ ! -f "camunda-modeler.bat" ]; then
              echo "ERROR: camunda-modeler.bat launcher not found"
              exit 1
            fi
            # Check that a camunda-modeler-* folder exists
            if ! ls -d camunda-modeler-* 1> /dev/null 2>&1; then
              echo "ERROR: camunda-modeler-* folder not found"
              exit 1
            fi
          elif [ "${{ matrix.platform.platform_id }}" == "linux-x86_64" ]; then
            # Linux has a symlink and modeler folder
            if [ ! -L "camunda-modeler" ]; then
              echo "ERROR: camunda-modeler symlink not found"
              exit 1
            fi
            # Check that a camunda-modeler-* folder exists
            if ! ls -d camunda-modeler-*-linux-x64 1> /dev/null 2>&1; then
              echo "ERROR: camunda-modeler-* folder not found"
              exit 1
            fi
          fi
          
          echo "All bundle components verified successfully!"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          job_name: test-bundle - ${{ matrix.platform.name }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  upload-to-release:
    name: Upload to GitHub Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [resolve-versions, build-bundle, test-bundle]
    if: ${{ !inputs.dry_run && needs.build-bundle.result == 'success' && needs.test-bundle.result == 'success' }}
    permissions:
      contents: write
    env:
      C8RUN_VERSION: ${{ needs.resolve-versions.outputs.c8run_version }}
    steps:
      - uses: actions/checkout@v4

      - name: Download all bundle artifacts
        uses: actions/download-artifact@v4
        with:
          path: bundles
          pattern: camunda8-getting-started-bundle-*

      - name: List downloaded bundles
        run: |
          echo "Downloaded bundles:"
          find bundles -type f -name "*.zip" -o -name "*.tar.gz" | while read -r f; do
            echo "  - $(basename "$f") ($(du -h "$f" | cut -f1))"
          done

      - name: Upload bundles to GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Uploading bundles to release: ${C8RUN_VERSION}"
          
          # Find all bundle files and upload them
          find bundles -type f \( -name "*.zip" -o -name "*.tar.gz" \) | while read -r bundle_file; do
            bundle_name=$(basename "$bundle_file")
            echo "Uploading: ${bundle_name}"
            gh release upload "${C8RUN_VERSION}" "$bundle_file" \
              --repo camunda/camunda \
              --clobber
          done
          
          echo "All bundles uploaded successfully!"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  notify-developer-portal:
    name: Send Slack Notification to prj-developer-portal
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [resolve-versions, build-bundle, test-bundle, upload-to-release]
    if: ${{ !inputs.dry_run && needs.upload-to-release.result == 'success' }}
    permissions:
      contents: read
    env:
      C8RUN_VERSION: ${{ needs.resolve-versions.outputs.c8run_version }}
      MODELER_VERSION: ${{ needs.resolve-versions.outputs.modeler_version }}
    steps:
      - uses: actions/checkout@v4

      - name: Send Slack notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_DEVELOPER_PORTAL_WEBHOOK }}
        run: |
          RELEASE_BASE_URL="https://github.com/camunda/camunda/releases/download/${C8RUN_VERSION}"
          
          # Build the Slack message payload
          # User IDs to tag: UPAQETUHZ, U08Q31GGFNW, UCFU9K4UD
          MESSAGE=$(cat << EOF
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "Hey <@UPAQETUHZ>, <@U08Q31GGFNW>, <@UCFU9K4UD>,\na new Camunda 8 Getting Started bundle has been packaged:"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*üîß Configuration:*\n‚Ä¢ C8Run Version: \`${C8RUN_VERSION}\`\n‚Ä¢ Modeler Version: \`${MODELER_VERSION}\`"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*‚è© Download links:*\n‚Ä¢ <${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-aarch64.zip|camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-aarch64.zip> (macOS Apple Silicon)\n‚Ä¢ <${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-x86_64.zip|camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-x86_64.zip> (macOS Intel)\n‚Ä¢ <${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-windows-x86_64.zip|camunda8-getting-started-bundle-${C8RUN_VERSION}-windows-x86_64.zip> (Windows)\n‚Ä¢ <${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-linux-x86_64.tar.gz|camunda8-getting-started-bundle-${C8RUN_VERSION}-linux-x86_64.tar.gz> (Linux)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "Thanks for your attention!"
                }
              }
            ]
          }
          EOF
          )
          
          echo "Sending Slack notification..."
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "${MESSAGE}" \
            "${SLACK_WEBHOOK_URL}"
          
          echo "Slack notification sent!"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  notify-release:
    name: Notify Slack (Release Announcement)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [resolve-versions, upload-to-release]
    if: ${{ !inputs.dry_run && needs.upload-to-release.result == 'success' }}
    permissions: {}
    steps:
      - name: Send release announcement to Slack
        env:
          C8RUN_VERSION: ${{ needs.resolve-versions.outputs.c8run_version }}
        run: |
          RELEASE_URL="https://github.com/camunda/camunda/releases/tag/${C8RUN_VERSION}"
          
          BLOCKS=$(cat <<EOF
          [
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": ":announcement: A new Camunda 8 Getting Started Bundle was just published <${RELEASE_URL}|${C8RUN_VERSION}>!"
              }
            }
          ]
          EOF
          )
          
          PAYLOAD=$(jq -n --argjson blocks "$BLOCKS" '{blocks: $blocks}')
          
          curl -X POST "${{ secrets.SLACK_CAMUNDA_EX_RELEASE_WEBHOOK }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  notify-failure:
    name: Notify Slack (Build Failure)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [resolve-versions, build-bundle, test-bundle, upload-to-release]
    if: always() && (needs.build-bundle.result == 'failure' || needs.test-bundle.result == 'failure' || needs.upload-to-release.result == 'failure')
    permissions: {}
    steps:
      - name: Send failure notification to Slack
        run: |
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          BLOCKS=$(cat <<EOF
          [
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": ":alarm: Camunda 8: Getting Started Bundle build failed, <!subteam^S064J3N99A5> please check and resolve the issue\n\n<$WORKFLOW_URL|View failed workflow run>"
              }
            }
          ]
          EOF
          )
          
          PAYLOAD=$(jq -n --argjson blocks "$BLOCKS" '{blocks: $blocks}')
          
          curl -X POST "${{ secrets.SLACK_CAMUNDA_EX_CI_WEBHOOK }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

  summary:
    name: Build Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [resolve-versions, build-bundle, test-bundle, upload-to-release, notify-developer-portal, notify-release, notify-failure]
    if: always()
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Generate summary
        env:
          C8RUN_VERSION: ${{ needs.resolve-versions.outputs.c8run_version }}
          MODELER_VERSION: ${{ needs.resolve-versions.outputs.modeler_version }}
          DRY_RUN: ${{ inputs.dry_run }}
          BUILD_STATUS: ${{ needs.build-bundle.result }}
          TEST_STATUS: ${{ needs.test-bundle.result }}
          UPLOAD_STATUS: ${{ needs.upload-to-release.result }}
          SLACK_STATUS: ${{ needs.notify-developer-portal.result }}
        run: |
          RELEASE_BASE_URL="https://github.com/camunda/camunda/releases/download/${C8RUN_VERSION}"
          
          cat << EOF >> "$GITHUB_STEP_SUMMARY"
          # Camunda 8 Getting Started Bundle

          ## Configuration
          - **C8Run Version**: ${C8RUN_VERSION}
          - **Modeler Version**: ${MODELER_VERSION}
          - **Dry Run**: ${DRY_RUN}

          ## Build Status
          - **Build Jobs**: ${BUILD_STATUS}
          - **Test Jobs**: ${TEST_STATUS}
          - **Upload to Release**: ${UPLOAD_STATUS:-skipped}
          - **Slack Notification**: ${SLACK_STATUS:-skipped}

          ## Generated Bundles
          EOF

          if [[ "${DRY_RUN}" == "true" ]]; then
            cat << EOF >> "$GITHUB_STEP_SUMMARY"
          The following bundles were created (available as workflow artifacts):
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-aarch64.zip\` (macOS Apple Silicon)
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-x86_64.zip\` (macOS Intel)
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-windows-x86_64.zip\` (Windows)
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-linux-x86_64.tar.gz\` (Linux)

          ‚ÑπÔ∏è **Dry run mode**: Bundles are available as workflow artifacts only.
          EOF
          else
            if [[ "${UPLOAD_STATUS}" == "success" ]]; then
              cat << EOF >> "$GITHUB_STEP_SUMMARY"
          The following bundles have been uploaded to the release:
          - [camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-aarch64.zip](${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-aarch64.zip) (macOS Apple Silicon)
          - [camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-x86_64.zip](${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-x86_64.zip) (macOS Intel)
          - [camunda8-getting-started-bundle-${C8RUN_VERSION}-windows-x86_64.zip](${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-windows-x86_64.zip) (Windows)
          - [camunda8-getting-started-bundle-${C8RUN_VERSION}-linux-x86_64.tar.gz](${RELEASE_BASE_URL}/camunda8-getting-started-bundle-${C8RUN_VERSION}-linux-x86_64.tar.gz) (Linux)

          ‚úÖ **Release mode**: Bundles have been uploaded to [GitHub release ${C8RUN_VERSION}](https://github.com/camunda/camunda/releases/tag/${C8RUN_VERSION}).
          EOF
            else
              cat << EOF >> "$GITHUB_STEP_SUMMARY"
          The following bundles were created:
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-aarch64.zip\` (macOS Apple Silicon)
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-darwin-x86_64.zip\` (macOS Intel)
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-windows-x86_64.zip\` (Windows)
          - \`camunda8-getting-started-bundle-${C8RUN_VERSION}-linux-x86_64.tar.gz\` (Linux)

          ‚ùå **Release mode**: Upload to GitHub release ${C8RUN_VERSION} failed or was skipped.
          EOF
            fi
          fi

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
