# type: Project Management
# owner: @camunda/core-features-team
---
# Urgency Field Automation
#
# This workflow automatically calculates and updates the Urgency field for issues in GitHub Projects.
#
# How it works:
# - Triggers when issues are opened, labeled, unlabeled, reopened, or transferred
# - Calculates urgency based on severity and likelihood labels using a risk matrix
# - Updates the Urgency field in ProjectV2 with values: immediate, next, planned, someday
# - Applies to any issue with a severity label (not limited to Bug type)
#
# Labels:
# - severity/{low,mid,high,critical} - Required to trigger urgency calculation
# - likelihood/{low,mid,high,unknown} - Optional, defaults to unknown (treated as low)
# - urgency-locked - Prevents automatic urgency updates while showing calculated value
#
# Matrix:
#   Likelihood ‚Üí     low        mid        high
#   Severity ‚Üì
#   low              someday    someday    someday
#   mid              someday    planned    planned
#   high             planned    next       next
#   critical         immediate  immediate  immediate
#
# Manual usage:
#   gh workflow run assign-urgency-to-issue.yml -f issue_number=123 -f project_id=173
#
name: Assign urgency field when issue is updated

on:
  issues:
    types: [opened, labeled, unlabeled, reopened, transferred]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process (optional)'
        required: false
      project_id:
        description: 'Target project ID (optional, defaults to job env)'
        required: false
      dry_run:
        description: 'Dry run mode - calculate urgency but do not update field'
        required: false
        type: boolean
        default: false

concurrency:
  group: update-urgency-${{ github.event.inputs.issue_number || github.event.issue.number }}
  cancel-in-progress: true

jobs:
  assign-urgency-to-issue:
    runs-on: ubuntu-latest
    permissions: {}
    timeout-minutes: 10
    env:
      GH_TOKEN: ${{ secrets.GH_PROJECT_AUTOMATION_TOKEN }}
      OWNER: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}
      ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
      PROJECT_NUMBER: ${{ github.event.inputs.project_id || '173' }}
      URGENCY_FIELD_NAME: 'Urgency'
      DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Dump issue JSON
        run: |
          cat << 'EOF'
          ${{ toJSON(github.event.issue) }}
          EOF
      - name: Fetch issue and project data
        id: fetch_data
        run: |
          set -euo pipefail

          if [[ "$DRY_RUN" == "true" ]]; then
            echo "üî¨ DRY RUN MODE - No changes will be made"
          fi

          echo "üîç Fetching issue #${ISSUE_NUMBER} and project ${PROJECT_NUMBER} data"

          # Single GraphQL query fetches: project info, project item, labels, issue type, and current urgency value
          # projectItems section is needed to:
          #   - Get PROJECT_ITEM_ID (required for updating the urgency field)
          #   - Verify the issue is in the target project (filter by project.number)
          #   - Fetch current urgency value (from fieldValues to check if update is needed)
          # Note: Limited to first 100 projects - if issue is in 100+ projects, target might be missed
          QUERY="query(\$owner:String!,\$repo:String!,\$issueNumber:Int!,\$projectNumber:Int!){
            repository(owner:\$owner,name:\$repo){
              issue(number:\$issueNumber){
                id
                issueType { name }
                labels(first:100){ nodes { name } }
                projectItems(first:100){
                  nodes{
                    id
                    project{ id number }
                    fieldValues(first:50){
                      nodes{
                        ... on ProjectV2ItemFieldSingleSelectValue {
                          field { ... on ProjectV2SingleSelectField { name } }
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
            organization(login:\$owner){
              projectV2(number:\$projectNumber){ id }
            }
          }"

          RESP=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F repo="$REPO" -F issueNumber="$ISSUE_NUMBER" -F projectNumber="$PROJECT_NUMBER") || {
            echo "‚ùå GraphQL query failed:"
            echo "$RESP"
            exit 1
          }

          # Store raw response parts in outputs for extraction where needed
          ISSUE_DATA=$(echo "$RESP" | jq -c '.data.repository.issue')
          PROJECT_DATA=$(echo "$RESP" | jq -c '.data.organization.projectV2')

          echo "‚úÖ Fetched issue and project data"

          # Store raw data in outputs for next steps
          {
            echo "issue_data<<EOF"
            echo "$ISSUE_DATA"
            echo "EOF"
            echo "project_data<<EOF"
            echo "$PROJECT_DATA"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Validate project membership
        id: validate_project
        run: |
          set -euo pipefail

          ISSUE_DATA='${{ steps.fetch_data.outputs.issue_data }}'
          PROJECT_DATA='${{ steps.fetch_data.outputs.project_data }}'

          # Extract project information
          TARGET_PROJECT_NODE_ID=$(echo "$PROJECT_DATA" | jq -r '.id // empty')
          PROJECT_ITEM_ID=$(echo "$ISSUE_DATA" | jq -r --argjson pn "$PROJECT_NUMBER" \
            '.projectItems.nodes[] | select(.project.number==$pn) | .id // empty')

          echo "üì¶ Project: #${PROJECT_NUMBER} (id: ${TARGET_PROJECT_NODE_ID:-not found})"
          echo "üîó Project item: ${PROJECT_ITEM_ID:-not found}"

          # Check if project exists
          if [[ -z "$TARGET_PROJECT_NODE_ID" ]]; then
            echo "‚ùå Target project #${PROJECT_NUMBER} not found in organization ${OWNER}"
            echo "üí° Check that the project exists and PROJECT_NUMBER is correct"
            exit 1
          fi

          # Check if issue is in the project
          if [[ -z "$PROJECT_ITEM_ID" ]]; then
            echo "‚è≠Ô∏è Issue #${ISSUE_NUMBER} is not in target project #${PROJECT_NUMBER}; skipping"
            echo "in_target_project=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Issue is in target project (item: $PROJECT_ITEM_ID)"

          # Store extracted IDs for later use
          {
            echo "in_target_project=true"
            echo "project_v2_id=$TARGET_PROJECT_NODE_ID"
            echo "project_item_id=$PROJECT_ITEM_ID"
          } >> "$GITHUB_OUTPUT"

      - name: Check labels
        id: check_labels
        if: steps.validate_project.outputs.in_target_project == 'true'
        run: |
          set -euo pipefail

          ISSUE_DATA='${{ steps.fetch_data.outputs.issue_data }}'

          # Extract issue type and labels
          ISSUE_TYPE=$(echo "$ISSUE_DATA" | jq -r '.issueType.name // empty')
          LABELS=$(echo "$ISSUE_DATA" | jq -c '.labels.nodes | map(.name)')

          echo "üìã Issue type: ${ISSUE_TYPE:-none}"

          # Extract and validate severity & likelihood
          severity=$(echo "$LABELS" | jq -r '.[] | select(startswith("severity/")) | sub("severity/"; "") | select(. == "low" or . == "mid" or . == "high" or . == "critical")' | head -n1)
          likelihood=$(echo "$LABELS" | jq -r '.[] | select(startswith("likelihood/")) | sub("likelihood/"; "") | select(. == "low" or . == "mid" or . == "high" or . == "unknown")' | head -n1)

          # Check if issue has a severity label
          if [[ -z "$severity" ]]; then
            echo "‚è≠Ô∏è Issue does not have a valid severity label; skipping"
          else
            echo "üè∑Ô∏è Severity: $severity"
          fi


          # Check for urgency-locked label
          has_urgency_locked=$(echo "$LABELS" | jq -r 'any(. == "urgency-locked")')

          if [[ "$has_urgency_locked" == "true" ]]; then
            echo "üîí Issue has 'urgency-locked' label - automatic urgency updates will be skipped"
          fi

          {
            echo "severity=$severity"
            echo "likelihood=$likelihood"
            echo "has_urgency_locked=$has_urgency_locked"
          } >> "$GITHUB_OUTPUT"

      - name: Calculate urgency
        id: calculate_urgency
        if: steps.check_labels.outputs.severity != ''
        run: |
          set -euo pipefail
          SEVERITY='${{ steps.check_labels.outputs.severity }}'
          LIKELIHOOD='${{ steps.check_labels.outputs.likelihood }}'

          # Default likelihood to unknown if not set
          if [[ -z "$LIKELIHOOD" ]]; then
            LIKELIHOOD="unknown"
            echo "‚ÑπÔ∏è  Likelihood not set, defaulting to unknown"
          fi

          # Treat unknown likelihood as low for matrix lookup
          LOOKUP_LIKELIHOOD="$LIKELIHOOD"
          if [[ "$LIKELIHOOD" == "unknown" ]]; then
            LOOKUP_LIKELIHOOD="low"
            echo "‚ÑπÔ∏è  Using likelihood=low for urgency calculation (actual: unknown)"
          fi

          # severity: low, mid, high, critical
          # likelihood: low, mid, high (unknown treated as low)
          # urgency: immediate, next, planned, someday
          declare -A MATRIX=(
            [low_low]=someday
            [low_mid]=someday
            [low_high]=someday
            [mid_low]=someday
            [mid_mid]=planned
            [mid_high]=planned
            [high_low]=planned
            [high_mid]=next
            [high_high]=next
            [critical_low]=immediate
            [critical_mid]=immediate
            [critical_high]=immediate
          )
          key="${SEVERITY}_${LOOKUP_LIKELIHOOD}"
          URGENCY="${MATRIX[$key]:-someday}"

          echo "üéØ Urgency: $URGENCY"
          echo "urgency=$URGENCY" >> "$GITHUB_OUTPUT"

      - name: Update Urgency
        if: steps.calculate_urgency.outputs.urgency != ''
        run: |
          set -euo pipefail

          ISSUE_DATA='${{ steps.fetch_data.outputs.issue_data }}'
          PROJECT_ITEM_ID='${{ steps.validate_project.outputs.project_item_id }}'
          PROJECT_V2_ID='${{ steps.validate_project.outputs.project_v2_id }}'
          NEW_URGENCY='${{ steps.calculate_urgency.outputs.urgency }}'
          HAS_URGENCY_LOCKED='${{ steps.check_labels.outputs.has_urgency_locked }}'

          # Extract current urgency value from the specific project item
          CURRENT_URGENCY=$(echo "$ISSUE_DATA" | jq -r --argjson pn "$PROJECT_NUMBER" --arg fieldName "$URGENCY_FIELD_NAME" \
            '.projectItems.nodes[] | select(.project.number==$pn) | .fieldValues.nodes[] | select(.field.name==$fieldName) | .name // empty')

          echo "üìå Current urgency: ${CURRENT_URGENCY:-(not set)}"

          # Check for urgency-locked label - skip updates but show what would change
          if [[ "$HAS_URGENCY_LOCKED" == "true" ]]; then
            echo "üîí Skipping urgency update - issue has 'urgency-locked' label"
            echo "‚ÑπÔ∏è  Calculated urgency: '$NEW_URGENCY' (current: '$CURRENT_URGENCY')"
            exit 0
          fi

          # Check if urgency matches - skip if already correct
          if [[ "$CURRENT_URGENCY" == "$NEW_URGENCY" ]]; then
            echo "‚è≠Ô∏è Urgency already set to '$NEW_URGENCY'; skipping update"
            exit 0
          fi

          # Dry run check
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "üî¨ DRY RUN: Would update urgency from '$CURRENT_URGENCY' to '$NEW_URGENCY'"
            exit 0
          fi

          # Fetch project fields (single query for both clear and update)
          FIELD_DATA=$(gh api graphql -f query="
            query(\$projectId:ID!){
              node(id:\$projectId){
                ... on ProjectV2 {
                  fields(first:100){
                    nodes{
                      ... on ProjectV2SingleSelectField { id name options { id name } }
                    }
                  }
                }
              }
            }" -F projectId="$PROJECT_V2_ID") || {
            echo "‚ùå Failed to fetch project fields"
            exit 1
          }

          FIELD_ID=$(echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" \
            '.data.node.fields.nodes[] | select(.name==$name) | .id // empty')

          if [[ -z "$FIELD_ID" ]]; then
            echo "‚ùå Field '$URGENCY_FIELD_NAME' does not exist in project"
            echo "üí° Please create a single-select field named '$URGENCY_FIELD_NAME' with options: immediate, next, planned, someday"
            exit 1
          fi

          # Build and execute mutation
          OPTION_ID=$(echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" --arg value "$NEW_URGENCY" \
            '.data.node.fields.nodes[] | select(.name==$name) | .options[]? | select(.name==$value) | .id // empty')

          OPTION_ID=$(echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" --arg value "$NEW_URGENCY" \
            '.data.node.fields.nodes[] | select(.name==$name) | .options[]? | select(.name==$value) | .id // empty')

          if [[ -z "$OPTION_ID" ]]; then
            echo "‚ùå Option '$NEW_URGENCY' not found in field '$URGENCY_FIELD_NAME'"
            echo "üí° Available options:"
            echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" \
              '.data.node.fields.nodes[] | select(.name==$name) | .options[] | "  - \(.name)"'
            exit 1
          fi

          JSON_PAYLOAD=$(jq -n \
            --arg projectId "$PROJECT_V2_ID" \
            --arg itemId "$PROJECT_ITEM_ID" \
            --arg fieldId "$FIELD_ID" \
            --arg optionId "$OPTION_ID" \
            '{
              "query": "mutation($input: UpdateProjectV2ItemFieldValueInput!) { updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } } }",
              "variables": {
                "input": {
                  "projectId": $projectId,
                  "itemId": $itemId,
                  "fieldId": $fieldId,
                  "value": { "singleSelectOptionId": $optionId }
                }
              }
            }')

          # Execute mutation
          MUTATION_RESP=$(gh api graphql -H "Content-Type: application/json" --input - <<< "$JSON_PAYLOAD" 2>&1) || {
            echo "‚ùå GraphQL mutation failed:"
            echo "$MUTATION_RESP"
            exit 1
          }

          if echo "$MUTATION_RESP" | jq -e '.errors' > /dev/null 2>&1; then
            echo "‚ùå GraphQL mutation returned errors:"
            echo "$MUTATION_RESP" | jq '.errors'
            exit 1
          fi

          echo "‚úÖ Updated urgency from '$CURRENT_URGENCY' to '$NEW_URGENCY'"

      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}

