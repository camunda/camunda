# type: Project Management
# owner: @camunda/core-features-team
---
name: Assign urgency field when issue is updated

on:
  issues:
    types: [opened, labeled, unlabeled, reopened, transferred]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process (optional)'
        required: false
      project_id:
        description: 'Target project ID (optional, defaults to job env)'
        required: false
      dry_run:
        description: 'Dry run mode - calculate urgency but do not update field'
        required: false
        type: boolean
        default: false

concurrency:
  group: update-urgency-${{ github.event.inputs.issue_number || github.event.issue.number }}
  cancel-in-progress: true

jobs:
  assign-urgency-to-issue:
    # Always run for manual dispatch, only run for Bug type issues when triggered by issue events
    if: github.event_name == 'workflow_dispatch' || github.event.issue.issueType.name == 'Bug'
    runs-on: ubuntu-latest
    permissions: {}
    timeout-minutes: 10
    env:
      GH_TOKEN: ${{ secrets.GH_PROJECT_AUTOMATION_TOKEN }}
      OWNER: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}
      ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number }}
      PROJECT_NUMBER: ${{ github.event.inputs.project_id || '173' }}
      URGENCY_FIELD_NAME: 'Urgency'
      DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Check issue
        id: check_issue
        run: |
          set -euo pipefail

          if [[ "$DRY_RUN" == "true" ]]; then
            echo "üî¨ DRY RUN MODE - No changes will be made"
          fi

          echo "üîç Checking project membership for issue #${ISSUE_NUMBER} in project ${PROJECT_NUMBER}"

          # Single GraphQL query fetches: project info, project item, labels, issue type, and current urgency value
          QUERY="query(\$owner:String!,\$repo:String!,\$issueNumber:Int!,\$projectNumber:Int!){
            repository(owner:\$owner,name:\$repo){
              issue(number:\$issueNumber){
                id
                issueType { name }
                labels(first:100){ nodes { name } }
                projectItems(first:100){
                  nodes{
                    id
                    project{ id number }
                    fieldValues(first:50){
                      nodes{
                        ... on ProjectV2ItemFieldSingleSelectValue {
                          field { ... on ProjectV2SingleSelectField { name } }
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
            organization(login:\$owner){
              projectV2(number:\$projectNumber){ id }
            }
          }"

          RESP=$(gh api graphql -f query="$QUERY" -F owner="$OWNER" -F repo="$REPO" -F issueNumber="$ISSUE_NUMBER" -F projectNumber="$PROJECT_NUMBER") || {
            echo "‚ùå GraphQL query failed:"
            echo "$RESP"
            exit 1
          }

          ISSUE_NODE_ID=$(echo "$RESP" | jq -r '.data.repository.issue.id // empty')
          ISSUE_TYPE=$(echo "$RESP" | jq -r '.data.repository.issue.issueType.name // empty')
          TARGET_PROJECT_NODE_ID=$(echo "$RESP" | jq -r '.data.organization.projectV2.id // empty')

          # Check if issue is a Bug type
          if [[ "$ISSUE_TYPE" != "Bug" ]]; then
            echo "‚è≠Ô∏è Issue type is '$ISSUE_TYPE', not 'Bug'; skipping"
            echo "is_relevant_issue=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Issue is a Bug"

          if [[ -z "$TARGET_PROJECT_NODE_ID" ]]; then
            echo "‚è≠Ô∏è Target project not found; skipping"
            echo "is_relevant_issue=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          PROJECT_ITEM_ID=$(echo "$RESP" | jq -r --argjson pn "$PROJECT_NUMBER" \
            '.data.repository.issue.projectItems.nodes[] | select(.project.number==$pn) | .id // empty')

          if [[ -z "$PROJECT_ITEM_ID" ]]; then
            echo "‚è≠Ô∏è Issue not in target project; skipping"
            echo "is_relevant_issue=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Issue is in target project (item: $PROJECT_ITEM_ID)"

          # Extract current urgency value from the specific project item we found
          CURRENT_URGENCY=$(echo "$RESP" | jq -r --argjson pn "$PROJECT_NUMBER" --arg fieldName "$URGENCY_FIELD_NAME" \
            '.data.repository.issue.projectItems.nodes[] | select(.project.number==$pn) | .fieldValues.nodes[] | select(.field.name==$fieldName) | .name // empty')

          if [[ -n "$CURRENT_URGENCY" ]]; then
            echo "üìå Current urgency: $CURRENT_URGENCY"
          else
            echo "üìå Current urgency: (not set)"
          fi

          # Store all labels for next step
          LABELS_JSON=$(echo "$RESP" | jq -c '.data.repository.issue.labels.nodes | map(.name)')

          {
            echo "is_relevant_issue=true"
            echo "issue_node_id=$ISSUE_NODE_ID"
            echo "project_v2_id=$TARGET_PROJECT_NODE_ID"
            echo "project_item_id=$PROJECT_ITEM_ID"
            echo "current_urgency=$CURRENT_URGENCY"
            echo "labels=$LABELS_JSON"
          } >> "$GITHUB_OUTPUT"

      - name: Check Labels
        id: check_labels
        if: steps.check_issue.outputs.is_relevant_issue == 'true'
        run: |
          set -euo pipefail

          LABELS='${{ steps.check_issue.outputs.labels }}'

          # Extract and validate severity & likelihood using jq directly
          severity=$(echo "$LABELS" | jq -r '.[] | select(startswith("severity/")) | sub("severity/"; "") | select(. == "low" or . == "mid" or . == "high" or . == "critical")' | head -n1)
          likelihood=$(echo "$LABELS" | jq -r '.[] | select(startswith("likelihood/")) | sub("likelihood/"; "") | select(. == "low" or . == "mid" or . == "high")' | head -n1)

          if [[ -z "$severity" ]]; then
            echo "‚ö†Ô∏è No valid severity label found (expected: severity/low|mid|high|critical)"
          else
            echo "üè∑Ô∏è Severity: $severity"
          fi

          if [[ -z "$likelihood" ]]; then
            echo "‚ö†Ô∏è No valid likelihood label found (expected: likelihood/low|mid|high)"
          else
            echo "üè∑Ô∏è Likelihood: $likelihood"
          fi

          echo "severity=$severity" >> "$GITHUB_OUTPUT"
          echo "likelihood=$likelihood" >> "$GITHUB_OUTPUT"

      - name: Calculate urgency
        id: calculate_urgency
        if: steps.check_issue.outputs.is_relevant_issue == 'true'
        run: |
          set -euo pipefail
          SEVERITY='${{ steps.check_labels.outputs.severity }}'
          LIKELIHOOD='${{ steps.check_labels.outputs.likelihood }}'

          if [[ -z "$SEVERITY" || -z "$LIKELIHOOD" ]]; then
            echo "‚ö†Ô∏è Missing severity or likelihood labels - urgency will not be set"
            if [[ -z "$SEVERITY" ]]; then
              echo "  ‚ùå Missing severity label (expected: severity/low|mid|high|critical)"
            fi
            if [[ -z "$LIKELIHOOD" ]]; then
              echo "  ‚ùå Missing likelihood label (expected: likelihood/low|mid|high)"
            fi
            URGENCY=""
          else
            # severity: low, mid, high, critical
            # likelihood: low, mid, high
            # urgency: immediate, next, planned, someday
            declare -A MATRIX=(
              [low_low]=someday
              [low_mid]=someday
              [low_high]=someday
              [mid_low]=someday
              [mid_mid]=planned
              [mid_high]=planned
              [high_low]=planned
              [high_mid]=next
              [high_high]=next
              [critical_low]=immediate
              [critical_mid]=immediate
              [critical_high]=immediate
            )
            key="${SEVERITY}_${LIKELIHOOD}"
            URGENCY="${MATRIX[$key]:-someday}"

            # Alternative mathematical calculation (unused / illustrative only)
            # S=$(case "$SEVERITY" in low)1;; mid)2;; high)3;; *)1;; esac)
            # L=$(case "$LIKELIHOOD" in low)1;; mid)2;; high)3;; *)1;; esac)
            # score=$((S*L))
            # if (( score <= 2 )); then URGENCY="someday"
            # elif (( score <= 4 )); then URGENCY="planned"
            # elif (( score <= 6 )); then URGENCY="next"
            # else URGENCY="immediate"; fi
            
            echo "üéØ Urgency: $URGENCY"
          fi

          echo "urgency=$URGENCY" >> "$GITHUB_OUTPUT"

      - name: Update Urgency
        if: steps.check_issue.outputs.is_relevant_issue == 'true'
        run: |
          set -euo pipefail
          PROJECT_ITEM_ID='${{ steps.check_issue.outputs.project_item_id }}'
          PROJECT_V2_ID='${{ steps.check_issue.outputs.project_v2_id }}'
          CURRENT_URGENCY='${{ steps.check_issue.outputs.current_urgency }}'
          NEW_URGENCY='${{ steps.calculate_urgency.outputs.urgency }}'

          # Determine what action to take
          if [[ -z "$NEW_URGENCY" && -z "$CURRENT_URGENCY" ]]; then
            echo "‚è≠Ô∏è No urgency to set and field is already empty; skipping"
            exit 0
          elif [[ -n "$NEW_URGENCY" && "$CURRENT_URGENCY" == "$NEW_URGENCY" ]]; then
            echo "‚è≠Ô∏è Urgency already set to '$NEW_URGENCY'; skipping update"
            exit 0
          fi

          # Determine mutation type
          if [[ -z "$NEW_URGENCY" ]]; then
            MUTATION_TYPE="clear"
            echo "üßπ Clearing urgency field (was '$CURRENT_URGENCY') due to missing severity/likelihood labels"
          else
            MUTATION_TYPE="update"
          fi

          # Dry run check
          if [[ "$DRY_RUN" == "true" ]]; then
            if [[ "$MUTATION_TYPE" == "clear" ]]; then
              echo "üî¨ DRY RUN: Would clear urgency field"
            else
              echo "üî¨ DRY RUN: Would update urgency from '$CURRENT_URGENCY' to '$NEW_URGENCY'"
            fi
            exit 0
          fi

          # Fetch project fields (single query for both clear and update)
          FIELD_DATA=$(gh api graphql -f query="
            query(\$projectId:ID!){
              node(id:\$projectId){
                ... on ProjectV2 {
                  fields(first:100){
                    nodes{
                      ... on ProjectV2SingleSelectField { id name options { id name } }
                    }
                  }
                }
              }
            }" -F projectId="$PROJECT_V2_ID") || {
            echo "‚ùå Failed to fetch project fields"
            exit 1
          }

          FIELD_ID=$(echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" \
            '.data.node.fields.nodes[] | select(.name==$name) | .id // empty')

          if [[ -z "$FIELD_ID" ]]; then
            if [[ "$MUTATION_TYPE" == "clear" ]]; then
              echo "‚ö†Ô∏è Field '$URGENCY_FIELD_NAME' does not exist; cannot clear"
              exit 0
            else
              echo "‚ùå Field '$URGENCY_FIELD_NAME' does not exist in project"
              echo "ÔøΩ Please create a single-select field named '$URGENCY_FIELD_NAME' with options: immediate, next, planned, someday"
              exit 1
            fi
          fi

          # Build and execute mutation
          if [[ "$MUTATION_TYPE" == "clear" ]]; then
            JSON_PAYLOAD=$(jq -n \
              --arg projectId "$PROJECT_V2_ID" \
              --arg itemId "$PROJECT_ITEM_ID" \
              --arg fieldId "$FIELD_ID" \
              '{
                "query": "mutation($input: ClearProjectV2ItemFieldValueInput!) { clearProjectV2ItemFieldValue(input: $input) { projectV2Item { id } } }",
                "variables": {
                  "input": {
                    "projectId": $projectId,
                    "itemId": $itemId,
                    "fieldId": $fieldId
                  }
                }
              }')
          else
            OPTION_ID=$(echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" --arg value "$NEW_URGENCY" \
              '.data.node.fields.nodes[] | select(.name==$name) | .options[]? | select(.name==$value) | .id // empty')

            if [[ -z "$OPTION_ID" ]]; then
              echo "‚ùå Option '$NEW_URGENCY' not found in field '$URGENCY_FIELD_NAME'"
              echo "üí° Available options:"
              echo "$FIELD_DATA" | jq -r --arg name "$URGENCY_FIELD_NAME" \
                '.data.node.fields.nodes[] | select(.name==$name) | .options[] | "  - \(.name)"'
              exit 1
            fi

            JSON_PAYLOAD=$(jq -n \
              --arg projectId "$PROJECT_V2_ID" \
              --arg itemId "$PROJECT_ITEM_ID" \
              --arg fieldId "$FIELD_ID" \
              --arg optionId "$OPTION_ID" \
              '{
                "query": "mutation($input: UpdateProjectV2ItemFieldValueInput!) { updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } } }",
                "variables": {
                  "input": {
                    "projectId": $projectId,
                    "itemId": $itemId,
                    "fieldId": $fieldId,
                    "value": { "singleSelectOptionId": $optionId }
                  }
                }
              }')
          fi

          # Execute mutation with unified error handling
          MUTATION_RESP=$(gh api graphql -H "Content-Type: application/json" --input - <<< "$JSON_PAYLOAD" 2>&1) || {
            echo "‚ùå GraphQL mutation failed:"
            echo "$MUTATION_RESP"
            exit 1
          }

          if echo "$MUTATION_RESP" | jq -e '.errors' > /dev/null 2>&1; then
            echo "‚ùå GraphQL returned errors:"
            echo "$MUTATION_RESP" | jq '.errors'
            exit 1
          fi

          # Success message
          if [[ "$MUTATION_TYPE" == "clear" ]]; then
            echo "‚úÖ Cleared urgency field"
          else
            echo "‚úÖ Updated urgency from '$CURRENT_URGENCY' to '$NEW_URGENCY'"
          fi

