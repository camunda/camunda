name: Camunda Platform Release Workflow
on:
  workflow_call:
    inputs:
      releaseBranch:
        description: 'The branch to perform the release on, defaults to `release-$releaseVersion`'
        type: string
        required: false
        default: ''
      releaseVersion:
        description: 'The version to be build and released. If no releaseBranch specified, expecting `release-$releaseVersion` to already exist.'
        type: string
        required: true
      nextDevelopmentVersion:
        description: 'Next development version, e.g. 8.X.X-SNAPSHOT.'
        type: string
        required: true
      isLatest:
        description: 'Whether this is the latest release and the docker image should be tagged as camunda/{component}:latest'
        type: boolean
        required: false
        default: false
      dryRun:
        description: 'Whether to perform a dry release where no changes or artifacts are pushed, defaults to true.'
        type: boolean
        default: true

defaults:
  run:
    shell: bash

env:
  RELEASE_BRANCH: ${{ inputs.releaseBranch != '' && inputs.releaseBranch || format('release-{0}', inputs.releaseVersion) }}
  RELEASE_VERSION: ${{ inputs.releaseVersion }}
  GH_TOKEN: ${{ github.token }} # needs to be available for the gh CLI tool
  GITHUB_TOKEN_USR: ${{ github.token }} # needs to be available for the SCM URL in pom.xml
jobs:
  release:
    name: Maven Release
    runs-on: gcp-core-16-release
    outputs:
      releaseTagRevision: ${{ steps.maven-perform-release.outputs.tagRevision }}
      releaseBranch: ${{ env.RELEASE_BRANCH }}
    env:
      DEVELOPMENT_VERSION: ${{ inputs.nextDevelopmentVersion }}
      PUSH_CHANGES: ${{ inputs.dryRun == false }}
    steps:
      - name: Output Inputs
        run: echo "${{ toJSON(github.event.inputs) }}"
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_BRANCH }}
      - name: Import Secrets
        id: secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/github.com/organizations/camunda MAVEN_CENTRAL_GPG_SIGNING_KEY_PASSPHRASE;
            secret/data/github.com/organizations/camunda MAVEN_CENTRAL_GPG_SIGNING_KEY_SEC;
            secret/data/github.com/organizations/camunda MAVEN_CENTRAL_GPG_SIGNING_KEY_PUB;
            secret/data/github.com/organizations/camunda MAVEN_CENTRAL_DEPLOYMENT_USR;
            secret/data/github.com/organizations/camunda MAVEN_CENTRAL_DEPLOYMENT_PSW;
      - name: Git User Setup
        run: |
          git config --global user.email "github-actions[release]"
          git config --global user.name "github-actions[release]@users.noreply.github.com"
      - name: Install Maven Central GPG Key
        # setup-maven supports this as well but needs the key in the armor ascii format,
        # while we only have it plain bas64 encoded
        # see https://github.com/actions/setup-java/issues/100#issuecomment-742679976
        run: |
          echo -n "${{ steps.secrets.outputs.MAVEN_CENTRAL_GPG_SIGNING_KEY_SEC }}" \
            | base64 --decode \
            | gpg -q --allow-secret-key-import --import --no-tty --batch --yes
          echo -n "${{ steps.secrets.outputs.MAVEN_CENTRAL_GPG_SIGNING_KEY_PUB }}" \
            | base64 --decode \
            | gpg -q --import --no-tty --batch --yes
      - name: Setup Github cli
        # On non-Github hosted runners it may be missing
        # https://github.com/cli/cli/blob/trunk/docs/install_linux.md#debian-ubuntu-linux-raspberry-pi-os-apt
        run: |
          type -p curl >/dev/null || sudo apt install curl -y
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
      - name: Setup Build Tooling
        uses: ./.github/actions/setup-build
        with:
          maven-servers: |
            [{
                "id": "central",
                "username": "${{ steps.secrets.outputs.MAVEN_CENTRAL_DEPLOYMENT_USR }}",
                "password": "${{ steps.secrets.outputs.MAVEN_CENTRAL_DEPLOYMENT_PSW }}"
            }]
          vault-address: ${{ secrets.VAULT_ADDR }}
          vault-role-id: ${{ secrets.VAULT_ROLE_ID }}
          vault-secret-id: ${{ secrets.VAULT_SECRET_ID }}

      - name: Update Compat Version
        run: |
          if [[ ! "$RELEASE_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Skipping updating the compat version as ${RELEASE_VERSION} is not a stable version"
            exit 0
          fi

          ./mvnw -B versions:set-property -DgenerateBackupPoms=false -Dproperty=backwards.compat.version -DnewVersion="${RELEASE_VERSION}"
          FILE=$(./mvnw -B help:evaluate -Dexpression=ignored.changes.file -q -DforceStdout)
          rm -f "clients/java/${FILE}" "test/${FILE}" "exporter-api/${FILE}" "protocol/${FILE}" "bpmn-model/${FILE}"
          git commit -am "build(project): update java compat versions"
      - name: Delete version-specific allowed API breaking changes
        run: |
          IFS='\n' readarray -t files <<< $(find . -name 'ignored-changes.json')
          for file in "${files[@]}"; do
            if [ '${{ inputs.dryRun }}' = 'false' ]; then
              echo "[DRY RUN] rm -f ${file}"
            else
              rm -f "${file}"
            fi
          done
      - name: Push Changes to Release branch
        if: ${{ inputs.dryRun == false }}
        run: git push origin "${RELEASE_BRANCH}"
      - name: Cleanup Maven Central GPG Key
        # make sure we always remove the imported signing key to avoid it leaking on runners
        if: always()
        run: rm -rf $HOME/.gnupg
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}

  github:
    needs: release
    name: Github Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_BRANCH }}
          fetch-depth: 0 # To fetch tags as well - necessary for the changelog generation
      - name: Install Zeebe changelog tool
        run: |
          gh release download --repo camunda/zeebe-changelog --pattern '*_Linux_i386.tar.gz'
          tar -xzvf zeebe-changelog_*
          chmod +x zcl
      - name: Generate Changelog for patch release
        id: gen-changelog
        run: |
          # We set some bash properties to better fail/debug this script
          #
          # * https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html
          # * https://explainshell.com/explain?cmd=set+-euox+pipefail
          #
          set -euox pipefail

          # Default changelog value
          changelog="Release ${{ inputs.releaseVersion }}"

          # Right now we only support patch releases for generating the changelog
          # as it is the easiest to automate and the most repetitive work to do on a release
          if [[ "${{ inputs.releaseVersion }}" =~ ^8\.[1-9][0-9]*\.[1-9][0-9]*$ ]]
          then
            # Next, add the release labels to the release's issues, specifying the previous and current release in place of ZCL_FROM_REV and ZCL_TARGET_REV, respectively.
            #
            # ZCL_TARGET_REV should be replaced with the tag name for the version you are releasing, and
            # ZCL_FROM_REV should be replaced as the tag name for the previous version, based on the release type:
            #
            # PATCH: the tag for the previous patch version on the same minor branch. e.g. if you're releasing 1.2.3, then ZCL_FROM_REV=1.2.2.

            # To find the previous patch version we extract the patch version and subtract by one
            patchVersion=$(echo ${{ inputs.releaseVersion }} | sed 's/8\.[1-9][0-9]*\.//')
            majorMinor=$(echo ${{ inputs.releaseVersion }} | sed 's/\.[1-9][0-9]*$//')
            ZCL_FROM_REV="$majorMinor".$(( patchVersion - 1 ))
            ZCL_TARGET_REV="${{ inputs.releaseVersion }}"

            # The following command will add labels to the issues on GitHub.
            # You can verify this step by looking at closed issues. They should now be tagged with the release.
            ./zcl add-labels \
            --token=${{ secrets.GITHUB_TOKEN }} \
            --from=$ZCL_FROM_REV \
            --target=$ZCL_TARGET_REV \
            --label="version:$ZCL_TARGET_REV" \
            --org camunda --repo zeebe

            # The following command will print the markdown code to sysout - we are storing this into our variable "changelog"
            changelog=$(./zcl generate \
            --token=${{ secrets.GITHUB_TOKEN }} \
            --label="version:$ZCL_TARGET_REV" \
            --org camunda --repo zeebe)
          fi

          # With multiline strings the output needs to be set differently.
          #
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#example-of-a-multiline-string
          #
          echo 'CHANGELOG<<EOF' >> $GITHUB_OUTPUT
          echo $changelog >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

          # To show the changelog also as step summary
          echo "$changelog" >> $GITHUB_STEP_SUMMARY

      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install @actions/artifact@2.1.9
      - name: download-build-artifact
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          WORKFLOW_RUN_ID: 14191393894
          ARTIFACT_ID: 2857926797
          ARTIFACTS_FOLDER: release-artifacts
        with:
          script: |
            const {default: artifactClient} = require('@actions/artifact')
            const { ARTIFACT_ID, ARTIFACTS_FOLDER, WORKFLOW_RUN_ID } = process.env
            await artifactClient.downloadArtifact(ARTIFACT_ID, { path: ARTIFACTS_FOLDER, findBy: { workflowRunId: WORKFLOW_RUN_ID, token: GH_TOKEN, repositoryOwner: camunda, repositoryName: camunda } })

      - name: Create Artifact Checksums
        id: checksum
        working-directory: ./release-artifacts
        run: |
          for filename in *; do
            checksumFile="${filename}.sha1sum"
            sha1sum "${filename}" > "${checksumFile}"
            sha1sumResult=$?
            if [ ! -f "${checksumFile}" ]; then
              echo "Failed to created checksum of ${filename} at ${checksumFile}; [sha1sum] exited with result ${sha1sumResult}. Check the logs for errors."
              exit 1
            fi
          done
      - name: Determine if Pre-Release
        id: pre-release
        run: |
          shopt -s nocasematch # set matching to case insensitive
          PRE_RELEASE=false
          if [[ "${RELEASE_VERSION}" =~ ^.*-(alpha|rc|SNAPSHOT)[\d]*$ ]]; then
            PRE_RELEASE=true
          fi
          shopt -u nocasematch # reset it
          echo "result=${PRE_RELEASE}" >> $GITHUB_OUTPUT
      - name: Create Github release
        uses: ncipollo/release-action@v1
        if: ${{ inputs.dryRun == false }}
        with:
          name: ${{ inputs.releaseVersion }}
          artifacts: "release-artifacts/*"
          artifactErrorsFailBuild: true
          draft: true
          body: ${{ steps.gen-changelog.outputs.changelog }}
          token: ${{ secrets.GITHUB_TOKEN }}
          prerelease: ${{ steps.pre-release.outputs.result }}
          tag: ${{ inputs.releaseVersion }}
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}

  zeebe-docker:
    needs: release
    name: Zeebe docker Image Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    services:
      # Local registry is used as multi arch images cannot be loaded locally but only pushed to a
      # registry. As we want to verify the images first before pushing them to dockerhub though,
      # a local registry is used and if verification passes images are pushed to the remote registry.
      registry:
        image: registry:2
        ports:
          - 5000:5000
    env:
      PLATFORMS: "linux/amd64,linux/arm64"
      LOCAL_DOCKER_IMAGE: localhost:5000/camunda/zeebe
      DOCKER_IMAGE: camunda/zeebe
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_BRANCH }}
      - name: Import Secrets
        id: secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/products/zeebe/ci/zeebe REGISTRY_HUB_DOCKER_COM_USR;
            secret/data/products/zeebe/ci/zeebe REGISTRY_HUB_DOCKER_COM_PSW;
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_USR }}
          password: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_PSW }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install @actions/artifact@2.1.9
      - name: download-build-artifact
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          WORKFLOW_RUN_ID: 14191393894
          ARTIFACT_ID: 2857926797
          ARTIFACTS_FOLDER: release-artifacts
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const {default: artifactClient} = require('@actions/artifact')
            const { ARTIFACT_ID, ARTIFACTS_FOLDER, WORKFLOW_RUN_ID, GH_TOKEN } = process.env
            await artifactClient.downloadArtifact(ARTIFACT_ID, { path: ARTIFACTS_FOLDER, findBy: { workflowRunId: WORKFLOW_RUN_ID, token: GH_TOKEN, repositoryOwner: camunda, repositoryName: camunda } })

      - name: Build Zeebe Docker Image
        uses: ./.github/actions/build-platform-docker
        id: build-zeebe-docker
        with:
          repository: ${{ env.LOCAL_DOCKER_IMAGE }}
          version: ${{ inputs.releaseVersion }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          # pushes to local registry for verification prior pushing to remote
          push: true
          distball: camunda-zeebe-${{ inputs.releaseVersion }}.tar.gz
          platforms: ${{ env.PLATFORMS }}
      - name: Verify Zeebe Docker image
        uses: ./.github/actions/verify-platform-docker
        with:
          imageName: ${{ env.LOCAL_DOCKER_IMAGE }}
          date: ${{ steps.build-zeebe-docker.outputs.date }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          version: ${{ inputs.releaseVersion }}
          platforms: ${{ env.PLATFORMS }}
      - name: Sync Docker Image to DockerHub
        id: push-docker
        if: ${{ inputs.dryRun == false }}
        # see https://docs.docker.com/build/ci/github-actions/examples/#copy-images-between-registries
        run: |
          docker buildx imagetools create \
            --tag ${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_VERSION }} \
            ${{ inputs.isLatest && format('--tag {0}:latest', env.DOCKER_IMAGE) || '' }} \
            ${{ steps.build-zeebe-docker.outputs.image }}
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}

  operate-docker:
    needs: release
    name: Operate Docker Image Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    services:
      # Local registry is used as multi arch images cannot be loaded locally but only pushed to a
      # registry. As we want to verify the images first before pushing them to dockerhub though,
      # a local registry is used and if verification passes images are pushed to the remote registry.
      registry:
        image: registry:2
        ports:
          - 5000:5000
    env:
      PLATFORMS: "linux/amd64,linux/arm64"
      LOCAL_DOCKER_IMAGE: localhost:5000/camunda/operate
      DOCKER_IMAGE: camunda/operate
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_BRANCH }}
      - name: Import Secrets
        id: secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/products/operate/ci/github-actions REGISTRY_HUB_DOCKER_COM_USR;
            secret/data/products/operate/ci/github-actions REGISTRY_HUB_DOCKER_COM_PSW;
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_USR }}
          password: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_PSW }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install @actions/artifact@2.1.9
      - name: download-build-artifact
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          WORKFLOW_RUN_ID: 14191393894
          ARTIFACT_ID: 2857926797
          ARTIFACTS_FOLDER: release-artifacts
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const {default: artifactClient} = require('@actions/artifact')
            const { ARTIFACT_ID, ARTIFACTS_FOLDER, WORKFLOW_RUN_ID, GH_TOKEN } = process.env
            await artifactClient.downloadArtifact(ARTIFACT_ID, { path: ARTIFACTS_FOLDER, findBy: { workflowRunId: WORKFLOW_RUN_ID, token: GH_TOKEN, repositoryOwner: camunda, repositoryName: camunda } })

      - name: Build Operate Docker Image
        uses: ./.github/actions/build-platform-docker
        id: build-operate-docker
        with:
          repository: ${{ env.LOCAL_DOCKER_IMAGE }}
          version: ${{ inputs.releaseVersion }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          # pushes to local registry for verification prior pushing to remote
          push: true
          distball: camunda-zeebe-${{ inputs.releaseVersion }}.tar.gz
          platforms: ${{ env.PLATFORMS }}
          dockerfile: operate.Dockerfile
      - name: Verify Operate Docker image
        uses: ./.github/actions/verify-platform-docker
        with:
          imageName: ${{ env.LOCAL_DOCKER_IMAGE }}
          date: ${{ steps.build-operate-docker.outputs.date }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          version: ${{ inputs.releaseVersion }}
          platforms: ${{ env.PLATFORMS }}
          dockerfile: operate.Dockerfile
          goldenfile: operate-docker-labels.golden.json
      - name: Sync Operate Docker Image to DockerHub
        id: push-docker
        if: ${{ inputs.dryRun == false }}
        # see https://docs.docker.com/build/ci/github-actions/examples/#copy-images-between-registries
        run: |
          docker buildx imagetools create \
            --tag ${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_VERSION }} \
            ${{ inputs.isLatest && format('--tag {0}:latest', env.DOCKER_IMAGE) || '' }} \
            ${{ steps.build-operate-docker.outputs.image }}
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}

  tasklist-docker:
    needs: release
    name: Tasklist Docker Image Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    services:
      # Local registry is used as multi arch images cannot be loaded locally but only pushed to a
      # registry. As we want to verify the images first before pushing them to dockerhub though,
      # a local registry is used and if verification passes images are pushed to the remote registry.
      registry:
        image: registry:2
        ports:
          - 5000:5000
    env:
      PLATFORMS: "linux/amd64,linux/arm64"
      LOCAL_DOCKER_IMAGE: localhost:5000/camunda/tasklist
      DOCKER_IMAGE: camunda/tasklist
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_BRANCH }}
      - name: Import Secrets
        id: secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/products/tasklist/ci/tasklist REGISTRY_HUB_DOCKER_COM_USR;
            secret/data/products/tasklist/ci/tasklist REGISTRY_HUB_DOCKER_COM_PSW;
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_USR }}
          password: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_PSW }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install @actions/artifact@2.1.9
      - name: download-build-artifact
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          WORKFLOW_RUN_ID: 14191393894
          ARTIFACT_ID: 2857926797
          ARTIFACTS_FOLDER: release-artifacts
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const {default: artifactClient} = require('@actions/artifact')
            const { ARTIFACT_ID, ARTIFACTS_FOLDER, WORKFLOW_RUN_ID, GH_TOKEN } = process.env
            await artifactClient.downloadArtifact(ARTIFACT_ID, { path: ARTIFACTS_FOLDER, findBy: { workflowRunId: WORKFLOW_RUN_ID, token: GH_TOKEN, repositoryOwner: camunda, repositoryName: camunda } })

      - name: Build Tasklist Docker Image
        uses: ./.github/actions/build-platform-docker
        id: build-tasklist-docker
        with:
          repository: ${{ env.LOCAL_DOCKER_IMAGE }}
          version: ${{ inputs.releaseVersion }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          # pushes to local registry for verification prior pushing to remote
          push: true
          distball: camunda-zeebe-${{ inputs.releaseVersion }}.tar.gz
          platforms: ${{ env.PLATFORMS }}
          dockerfile: tasklist.Dockerfile
      - name: Verify Tasklist Docker image
        uses: ./.github/actions/verify-platform-docker
        with:
          imageName: ${{ env.LOCAL_DOCKER_IMAGE }}
          date: ${{ steps.build-tasklist-docker.outputs.date }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          version: ${{ inputs.releaseVersion }}
          platforms: ${{ env.PLATFORMS }}
          dockerfile: tasklist.Dockerfile
          goldenfile: tasklist-docker-labels.golden.json
      - name: Sync Tasklist Docker Image to DockerHub
        id: push-docker
        if: ${{ inputs.dryRun == false }}
        # see https://docs.docker.com/build/ci/github-actions/examples/#copy-images-between-registries
        run: |
          docker buildx imagetools create \
            --tag ${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_VERSION }} \
            ${{ inputs.isLatest && format('--tag {0}:latest', env.DOCKER_IMAGE) || '' }} \
            ${{ steps.build-tasklist-docker.outputs.image }}
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}

  camunda-docker:
    needs: release
    name: Camunda Docker Image Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    services:
      # Local registry is used as multi arch images cannot be loaded locally but only pushed to a
      # registry. As we want to verify the images first before pushing them to dockerhub though,
      # a local registry is used and if verification passes images are pushed to the remote registry.
      registry:
        image: registry:2
        ports:
          - 5000:5000
    env:
      PLATFORMS: "linux/amd64,linux/arm64"
      LOCAL_DOCKER_IMAGE: localhost:5000/camunda/camunda
      DOCKER_IMAGE: camunda/camunda
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_BRANCH }}
      - name: Import Secrets
        id: secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/products/camunda/ci/github-actions REGISTRY_HUB_DOCKER_COM_USR;
            secret/data/products/camunda/ci/github-actions REGISTRY_HUB_DOCKER_COM_PSW;
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_USR }}
          password: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_PSW }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install @actions/artifact@2.1.9
      - name: download-build-artifact
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          WORKFLOW_RUN_ID: 14191393894
          ARTIFACT_ID: 2857926797
          ARTIFACTS_FOLDER: release-artifacts
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const {default: artifactClient} = require('@actions/artifact')
            const { ARTIFACT_ID, ARTIFACTS_FOLDER, WORKFLOW_RUN_ID, GH_TOKEN } = process.env
            await artifactClient.downloadArtifact(ARTIFACT_ID, { path: ARTIFACTS_FOLDER, findBy: { workflowRunId: WORKFLOW_RUN_ID, token: GH_TOKEN, repositoryOwner: camunda, repositoryName: camunda } })

      - name: Build Camunda Docker Image
        uses: ./.github/actions/build-platform-docker
        id: build-camunda-docker
        with:
          repository: ${{ env.LOCAL_DOCKER_IMAGE }}
          version: ${{ inputs.releaseVersion }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          # pushes to local registry for verification prior pushing to remote
          push: true
          distball: camunda-zeebe-${{ inputs.releaseVersion }}.tar.gz
          platforms: ${{ env.PLATFORMS }}
          dockerfile: camunda.Dockerfile
      - name: Verify Camunda Docker image
        uses: ./.github/actions/verify-platform-docker
        with:
          imageName: ${{ env.LOCAL_DOCKER_IMAGE }}
          date: ${{ steps.build-camunda-docker.outputs.date }}
          revision: ${{ needs.release.outputs.releaseTagRevision }}
          version: ${{ inputs.releaseVersion }}
          platforms: ${{ env.PLATFORMS }}
          dockerfile: camunda.Dockerfile
          goldenfile: camunda-docker-labels.golden.json
      - name: Sync Camunda Docker Image to DockerHub
        id: push-docker
        if: ${{ inputs.dryRun == false }}
        # see https://docs.docker.com/build/ci/github-actions/examples/#copy-images-between-registries
        run: |
          docker buildx imagetools create \
            --tag ${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_VERSION }} \
            ${{ inputs.isLatest && format('--tag {0}:latest', env.DOCKER_IMAGE) || '' }} \
            ${{ steps.build-camunda-docker.outputs.image }}
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}

  snyk:
    name: Snyk Monitor
    needs: [ zeebe-docker, release ]
    # skip if the version contains a dash as a quick test for -alpha, -rc, -SNAPSHOT, etc.
    if: ${{ !contains(inputs.releaseVersion, '-') }}
    concurrency:
      group: release-snyk-${{ inputs.releaseVersion }}
      cancel-in-progress: false
    uses: ./.github/workflows/zeebe-snyk.yml
    with:
      # Can't reference env.RELEASE_BRANCH directly due to https://github.com/actions/runner/issues/2372
      ref: ${{ needs.release.outputs.releaseBranch }}
      version: ${{ inputs.releaseVersion }}
      useMinorVersion: true
      # test instead of monitor during dry-runs
      monitor: ${{ !inputs.dryRun }}
      # the docker image will not be pushed during a dry-run, so we need to build it locally
      build: ${{ inputs.dryRun }}
      dockerImage: ${{ inputs.dryRun && '' || format('camunda/zeebe:{0}', inputs.releaseVersion) }}
    secrets: inherit


