---
name: Analyze test runs

description: Check for duplicated test runs from a maven build output file and fail if found.

inputs:
  buildOutputFilePath:
    description: 'Path to the build log file.'
    required: true
  skipSummary:
    description: "Whether to run the test-summary action, it might run into problems an large test outputs"
    default: "false"
    required: false

outputs:
  flakyTests:
    description: "A collection of flaky tests, if there are any"
    value: ${{ steps.find-flakes.outputs.FLAKY_TESTS }}

runs:
  using: composite
  steps:
  - name: Test Summary
    uses: test-summary/action@v2
    if: ${{ inputs.skipSummary == 'false' }}
    with:
      paths: |
        **/target/failsafe-reports/TEST-*.xml
        **/target/surefire-reports/TEST-*.xml
  - name: Find flaky tests
    id: find-flakes
    shell: bash
    env:
      BUILD_OUTPUT_FILE_PATH: ${{ inputs.buildOutputFilePath }}
    run: |
      set -eoux
      if [ ! -s "$BUILD_OUTPUT_FILE_PATH" ]; then
        echo "::error::Build output file does not exist or is empty!"
        exit 1
      fi

      # Extracting flaky tests
      # Based on old Jenkins script
      # https://github.com/camunda/camunda/blob/stable/8.1/.ci/scripts/lib/flaky-tests.sh
      if grep -q "\[WARNING\] Flakes:" "$BUILD_OUTPUT_FILE_PATH"; then
        irOutputFile=$(mktemp)

        # Extracting the essential lines
        awk '/^\[WARNING\] Flakes:.*$/{flag=1}/^\[ERROR\] Tests run:.*Flakes: [0-9]*$/{print;flag=0}flag' "$BUILD_OUTPUT_FILE_PATH" > ${irOutputFile}

        # To cover cases where we use parameterized tests like
        # [WARNING]  io.camunda.zeebe.engine.state.BanInstanceTest.shouldBanInstance[PROCESS_MESSAGE_SUBSCRIPTION DELETE should ban instance true]
        # We grep the WARNING line and set the first argument to an empty string
        flakyTests=$(grep -E "\[WARNING\] [a-z]+\." ${irOutputFile} | awk '{$1=""; print $0}')

        # To support multi-line string in output we have to work with EOF delimiter
        # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#example-of-a-multiline-string
        {
          echo 'FLAKY_TESTS<<EOF'
          echo "$flakyTests"
          echo EOF
        } >> $GITHUB_OUTPUT

        echo "::warning::Found flaky tests!\n ${flakyTests}"
      fi
  - name: Comment flaky tests on PR
    if: steps.find-flakes.outputs.FLAKY_TESTS != ''
    uses: actions/github-script@v7
    with:
      github-token: ${{ github.token }}
      script: |
        const flakyTests = `${{ steps.find-flakes.outputs.FLAKY_TESTS }}`;
        const prNumber = context.issue.number;
        const owner = context.repo.owner;
        const repo = context.repo.repo;

        console.log('ðŸš€ Starting flaky test analysis...');
        console.log(`ðŸ“‹ PR Number: ${prNumber}`);
        console.log(`ðŸ“¦ Repository: ${owner}/${repo}`);
        console.log(`ðŸ§ª Flaky tests found:\n${flakyTests}`);

        // Helper functions for better code organization and reusability
        const helpers = {
          extractTestClass(testLine) {
            const match = testLine.match(/([a-zA-Z][a-zA-Z0-9]*\.)+[a-zA-Z][a-zA-Z0-9]*\.[A-Z][a-zA-Z0-9]*(?:Test|IT)/);
            const result = match ? match[0] : null;
            console.log(`ðŸ” Extracting test class from: "${testLine}" â†’ ${result || 'NO MATCH'}`);
            return result;
          },

          generatePossiblePaths(testClass) {
            const classPath = testClass.replace(/\./g, '/');
            const paths = [
              `${classPath}.java`,
              `src/test/java/${classPath}.java`,
              `src/main/java/${classPath}.java`
            ];
            console.log(`ðŸ“ Generated possible paths for ${testClass}:`, paths);
            return paths;
          },

          findMatchingFile(testClass, changedFiles) {
          const possiblePaths = this.generatePossiblePaths(testClass);
          const className = testClass.split('.').pop();

          for (const possiblePath of possiblePaths) {
            const matchingFile = changedFiles.find(file =>
            file.endsWith(possiblePath) || file.includes(className)
            );
            if (matchingFile) {
              console.log(`âœ… Found matching file: ${matchingFile} for test class ${testClass}`);
              return matchingFile;
            }
          }
            console.log(`âŒ No matching file found for test class ${testClass}`);
            return null;
          },

          async findLastAuthor(commits, filename) {
            console.log(`ðŸ”Ž Finding last author for file: ${filename}`);

            for (const commit of [...commits].reverse()) {
              try {
                console.log(`ðŸ“ Checking commit ${commit.sha.substring(0, 7)} by ${commit.author?.login || 'unknown'}`);

                const { data: commitFiles } = await github.rest.repos.getCommit({
                  owner,
                  repo,
                  ref: commit.sha,
                });

                const modifiedFile = commitFiles.files?.find(file => file.filename === filename);
                if (modifiedFile) {
                  const author = commit.author?.login;
                  console.log(`âœ… Found last author for ${filename}: @${author} in commit ${commit.sha.substring(0, 7)}`);
                  return { author, commit };
                }
              } catch (error) {
                console.log(`âš ï¸ Could not fetch commit ${commit.sha.substring(0, 7)}: ${error.message}`);
                continue;
              }
            }

            console.log(`âŒ No author found for file: ${filename}`);
            return { author: null, commit: null };
          }
        };

        // Step 1: Fetch all required data upfront to minimize API calls
        console.log('\nðŸ“¡ Step 1: Fetching all PR data...');
          let prData = {};
          try {
            console.log('ðŸ”„ Making parallel API calls for PR files, commits, and details...');

            const [prFilesResponse, commitsResponse, pullRequestResponse] = await Promise.all([
              github.rest.pulls.listFiles({ owner, repo, pull_number: prNumber }),
              github.rest.pulls.listCommits({ owner, repo, pull_number: prNumber }),
              github.rest.pulls.get({ owner, repo, pull_number: prNumber })
            ]);

            prData = {
              files: prFilesResponse.data,
              commits: commitsResponse.data,
              pullRequest: pullRequestResponse.data
            };

            console.log(`âœ… Successfully fetched:`);
            console.log(`   ðŸ“„ ${prData.files.length} changed files`);
            console.log(`   ðŸ“ ${prData.commits.length} commits`);
            console.log(`   ðŸ”— PR head SHA: ${prData.pullRequest.head.sha.substring(0, 7)}`);

            const changedFiles = prData.files.map(file => file.filename);
            console.log(`ðŸ“‹ Changed files in this PR:`, changedFiles);

          } catch (error) {
            console.log(`âŒ Failed to fetch PR data: ${error.message}`);
            console.log('ðŸ›‘ Aborting flaky test analysis');
            return;
          }

        // Step 2: Process flaky tests and map to files/authors (reusing fetched data)
          console.log('\nðŸ” Step 2: Analyzing flaky tests and mapping to files...');

          const flakyTestLines = flakyTests.trim().split('\n').filter(line => line.trim());
          const changedFiles = prData.files.map(file => file.filename);

          console.log(`ðŸ§ª Processing ${flakyTestLines.length} flaky test lines...`);

          // Centralized data structure to avoid duplication
          const analysisResults = {
            touchedFiles: [],
            mentionedAuthors: new Set(),
            inlineTargets: new Map(), // Use Map to prevent duplicates by filename
            processedTestClasses: new Set()
          };

          for (let i = 0; i < flakyTestLines.length; i++) {
            const testLine = flakyTestLines[i];
            console.log(`\nðŸ”¬ Processing test ${i + 1}/${flakyTestLines.length}: ${testLine}`);

            const testClass = helpers.extractTestClass(testLine);
            if (!testClass) {
              console.log(`â­ï¸ Skipping - no test class found`);
              continue;
            }

            // Skip if we've already processed this test class
            if (analysisResults.processedTestClasses.has(testClass)) {
              console.log(`â­ï¸ Skipping - already processed test class: ${testClass}`);
              continue;
            }
            analysisResults.processedTestClasses.add(testClass);

            const matchingFile = helpers.findMatchingFile(testClass, changedFiles);
            if (!matchingFile) {
              console.log(`â­ï¸ Skipping - no matching file found for test class: ${testClass}`);
              continue;
            }

            // Reuse the commits data we already fetched
            console.log(`ðŸ”Ž Finding author for file: ${matchingFile} (reusing fetched commit data)`);
            const { author: fileAuthor, commit: fileCommit } = await helpers.findLastAuthor(prData.commits, matchingFile);

            if (fileAuthor && fileCommit) {
              const fileInfo = {
                file: matchingFile,
                testClass,
                author: fileAuthor,
                commit: fileCommit
              };

              analysisResults.touchedFiles.push(fileInfo);
              analysisResults.mentionedAuthors.add(fileAuthor);

              // Store for inline comments (Map prevents duplicates by filename)
              if (!analysisResults.inlineTargets.has(matchingFile)) {
                analysisResults.inlineTargets.set(matchingFile, fileInfo);
                console.log(`ðŸ“Œ Added to inline targets: ${matchingFile} â†’ @${fileAuthor}`);
              } else {
                console.log(`â­ï¸ File already in inline targets: ${matchingFile}`);
              }
            } else {
              console.log(`âŒ Could not find author for file: ${matchingFile}`);
            }
        }

          console.log(`\nðŸ“Š Analysis Results Summary:`);
          console.log(`   ðŸ“ ${analysisResults.touchedFiles.length} files with flaky tests`);
          console.log(`   ðŸ‘¥ ${analysisResults.mentionedAuthors.size} unique authors mentioned`);
          console.log(`   ðŸ’¬ ${analysisResults.inlineTargets.size} inline comments to create`);
          console.log(`   ðŸ§ª ${analysisResults.processedTestClasses.size} unique test classes processed`);

          // Step 3: Execute all GitHub API interactions in organized blocks
          console.log('\nðŸš€ Step 3: Creating GitHub interactions...');
          try{
              // 3a. Create inline review comments
              if (analysisResults.inlineTargets.size > 0) {
                console.log(`\nðŸ“ Creating ${analysisResults.inlineTargets.size} inline review comments...`);

                let successCount = 0;
                let failCount = 0;

                for (const [filename, target] of analysisResults.inlineTargets.entries()) {
                  console.log(`ðŸ“ Creating inline comment ${successCount + failCount + 1}/${analysisResults.inlineTargets.size} for: ${filename}`);

                  const inlineBody = `### Oh! We've got ourselves flaky ones!

        Hey @${target.author}! ðŸ‘‹

        This file contains the flaky test:
        \`\`\`
        ${flakyTests}
        \`\`\`

        Since you recently modified this file, would you mind taking a quick look?
        You might have insights into what could be causing the test instability.

        **What to check:**
        - Recent changes that might affect test timing
        - New dependencies or configurations
        - Race conditions or timing-sensitive code

        No pressure if you're busy, just thought you'd be the best person to investigate! ðŸ•µï¸â€â™‚ï¸`;

                  try {
                    await github.rest.pulls.createReviewComment({
                      owner,
                      repo,
                      pull_number: prNumber,
                      commit_id: prData.pullRequest.head.sha, // Reusing fetched data
                      path: target.file,
                      line: 1,
                      body: inlineBody
                    });
                    successCount++;
                    console.log(`âœ… Successfully created inline comment for ${filename}`);
                  } catch (reviewError) {
                    failCount++;
                  console.log(`âŒ Failed to create inline comment for ${filename}: ${reviewError.message}`);
                  }
                }
              console.log(`ðŸ“Š Inline comments summary: ${successCount} successful, ${failCount} failed`);
            } else {
              console.log(`â­ï¸ No inline comments to create`);
            }

              // 3b. Build and post/update the main PR comment
              console.log(`\nðŸ’¬ Creating main PR comment...`);
              let body = `### Oh! We've got ourselves flaky ones!

          \`\`\`
          ${flakyTests}
          \`\`\`

          Related to your code? Maybe.

          Fixable now? Maybe not.

          Please consider investigating if you have time. These tests might return, and

          ![I'll be back](https://media.tenor.com/p2Ie017Zwu8AAAAM/exterminador-do.gif)`;

                const comments = await github.rest.issues.listComments({
                    owner,
                    repo,
                    issue_number: prNumber,
                });

                  console.log(`ðŸ“‹ Found ${comments.data.length} existing comments`);

                  const marker = `${flakyTests}`;
                  const botComment = comments.data.find(comment =>
                    comment.user.type === "Bot" && comment.body.includes(marker)
                  );

                  if (botComment) {
                    console.log(`ðŸ”„ Updating existing bot comment (ID: ${botComment.id})`);
                      await github.rest.issues.updateComment({
                      owner,
                      repo,
                      comment_id: botComment.id,
                      body: body
                    });
                    console.log("âœ… Successfully updated existing flaky test comment");
                  } else {
                    console.log(`ðŸ“ Creating new bot comment`);
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: prNumber,
                      body: body
                    });
                    console.log("âœ… Successfully created new flaky test comment");
                }
          } catch (error) {
            console.log(`âŒ Failed to create GitHub interactions: ${error.message}`);
            console.log('ðŸ›‘ Aborting flaky test analysis');
            return;
          }


  - name: Unfinished tests
    if: failure() || cancelled()
    shell: bash
    env:
      BUILD_OUTPUT_FILE_PATH: ${{ inputs.buildOutputFilePath }}
    run: |
      if [ ! -s "$BUILD_OUTPUT_FILE_PATH" ]; then
        echo "::error::Build output file does not exist or is empty!"
        exit 1
      fi
      running=$(mktemp)
      finished=$(mktemp)
      unfinished=$(mktemp)
      grep -oP "\[INFO\] Running \K(.*)$" "$BUILD_OUTPUT_FILE_PATH" > "$running"
      grep -oP 'Tests run.*?-- in \K(.*)$' "$BUILD_OUTPUT_FILE_PATH" > "$finished"
      sort $running $finished | uniq -u > "$unfinished"
      if [ -s "$unfinished" ]; then
        echo "### âš ï¸ Unfinished test runs" >> $GITHUB_STEP_SUMMARY
        cat $unfinished >> $GITHUB_STEP_SUMMARY
      fi
      exit 0
