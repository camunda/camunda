---
name: Update Flaky Tests Comment

description: Creates or updates a PR comment with flaky test summary across all test jobs

inputs:
  flaky-tests-data:
    description: 'JSON array containing flaky test data from all jobs'
    required: true
  pr-number:
    description: 'Pull request number for the comment'
    required: true

runs:
  using: composite
  steps:
    - name: Update Flaky Tests Comment
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          // Parse the flaky tests data
          const flakyTestsData = JSON.parse(`${{ inputs.flaky-tests-data }}`);
          console.log('Received flaky tests data:', flakyTestsData);

          // Early exit if no flaky tests found
          if (!Array.isArray(flakyTestsData) || flakyTestsData.length === 0) {
            console.log('[flaky-tests] No flaky tests found - skipping comment update');
            return;
          }

          // Step 1: Process and structure the flaky test data
          const processedData = processFlakyTestsData(flakyTestsData);
          console.log('[flaky-tests] Processed data:', JSON.stringify(processedData, null, 2));

          // Step 2: Generate and post the PR comment
          const { main } = require('./.github/actions/update-flaky-tests-comment/src/comment-generator');
          console.log('[flaky-tests] ðŸš€ Generating comment...');
          await main(context, github, processedData, ${{ inputs.pr-number }});

          /**
          * Processes the raw flaky test data and organizes it by package.
          */
          function processFlakyTestsData(rawData) {
            const packageMap = new Map();

            rawData.forEach(({ job, flaky_tests }) => {
              if (!flaky_tests || flaky_tests.trim() === '') {
                console.log(`[flaky-tests] Skipping job "${job}" - no flaky tests`);
                return;
              }

              const testNames = flaky_tests
              .split(/\s+/)
              .map(t => t.trim())
              .filter(Boolean);

              console.log(`[flaky-tests] Job "${job}": found ${testNames.length} test(s)`);

              testNames.forEach(testName => {
                const parsedTest = parseTestName(testName);
                if (parsedTest) {
                  addTestToMap(packageMap, parsedTest, job);
                }
              });
            });

            return {
              tests: Array.from(packageMap.entries()).map(([packageName, tests]) => ({
                packageName,
                flakys: Array.from(tests.values())
              }))
            };
          }

          /**
          * Parses a test name string into structured components.
          */
          function parseTestName(testName) {
            const trimmed = testName?.trim();
            if (!trimmed) return null;

            // Pattern: full.package.ClassNameTest.methodName
            const testClassRegex = /^(.+)\.([A-Z][\w]*(?:Test|IT))\.(.+)$/;
            const match = trimmed.match(testClassRegex);

            if (match) {
              const [, packageName, className, methodName] = match;
              return {
                packageName,
                className,
                methodName: normalizeMethodName(methodName)
              };
            }

            // Fallback: try to extract package from last dot
            const lastDot = trimmed.lastIndexOf('.');
            if (lastDot !== -1) {
              return {
                packageName: trimmed.slice(0, lastDot),
                className: '',
                methodName: normalizeMethodName(trimmed.slice(lastDot + 1))
              };
            }

            // Final fallback
            return {
              packageName: 'unknown',
              className: '',
              methodName: normalizeMethodName(trimmed)
            };
          }

          /**
          * Normalizes method names by removing parameterization suffixes (e.g. `[1]`).
          */
          function normalizeMethodName(methodName) {
            const match = methodName.match(/^(.*)\[\d+\]$/);
            return match ? match[1] : methodName;
          }

          /**
          * Adds a parsed test to the package map.
          */
          function addTestToMap(packageMap, { packageName, className, methodName }, jobName) {
            if (!packageMap.has(packageName)) {
              packageMap.set(packageName, new Map());
            }

            const testsMap = packageMap.get(packageName);
            const testKey = className ? `${className}.${methodName}` : methodName;

            if (testsMap.has(testKey)) {
              const testEntry = testsMap.get(testKey);
              if (!testEntry.jobs.includes(jobName)) {
                testEntry.jobs.push(jobName);
              }
                testEntry.occurrences++;
              } else {
                testsMap.set(testKey, {
                  className,
                  methodName,
                  jobs: [jobName],
                  occurrences: 1
                });
              }
          }
