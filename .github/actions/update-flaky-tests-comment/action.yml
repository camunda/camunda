---
name: Update Flaky Tests Comment

description: Creates or updates a PR comment with flaky test summary across all test jobs

inputs:
  flaky-tests-data:
    description: 'JSON array containing flaky test data from all jobs'
    required: true
  pr-number:
    description: 'Pull request number for the comment'
    required: true
  branch-name:
    description: 'Branch name where the comment will be posted'
    required: true

runs:
  using: composite
  steps:
    - name: Update Flaky Tests Comment
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          // Parse the flaky tests data
          const flakyTestsData = JSON.parse(`${{ inputs.flaky-tests-data }}`);
          console.log('Received flaky tests data:', flakyTestsData);

          // Early exit if no flaky tests found
          if (!Array.isArray(flakyTestsData) || flakyTestsData.length === 0) {
            console.log('[flaky-tests] No flaky tests found - skipping comment update');
            return;
          }

          // Step 1: Process and structure the flaky test data
          const processedData = processFlakyTestsData(flakyTestsData);
          console.log('[flaky-tests] Processed data:', JSON.stringify(processedData, null, 2));

          // Step 2: Generate and post the PR comment
          const { main } = require('./.github/actions/update-flaky-tests-comment/src/comment-generator');
          console.log('[flaky-tests] ðŸš€ Generating comment...');
          await main(context, github, processedData, ${{ inputs.pr-number }}, '${{ inputs.branch-name }}');

          /**
          * Processes the raw flaky test data and organizes it by package.
          */
          function processFlakyTestsData(rawData) {
            const packageMap = new Map();

            rawData.forEach(({ job, flaky_tests }) => {
              if (!flaky_tests || flaky_tests.trim() === '') {
                console.log(`[flaky-tests] Skipping job "${job}" - no flaky tests`);
                return;
              }

              const testNames = flaky_tests
              .split(/\s+/)
              .map(t => t.trim())
              .filter(Boolean);

              console.log(`[flaky-tests] Job "${job}": found ${testNames.length} test(s)`);

              testNames.forEach(testName => {
                const parsedTest = parseTestName(testName);
                if (parsedTest) {
                  addTestToMap(packageMap, parsedTest, job);
                }
              });
            });

            return {
              tests: Array.from(packageMap.entries()).map(([packageName, tests]) => ({
                packageName,
                flakys: Array.from(tests.values())
              }))
            };
          }

          /**
          * Parses a test name string into structured components.
          */
          function parseTestName(testName) {
            const lastDotIndex = testName.lastIndexOf('.');

            if (lastDotIndex === -1) {
              console.warn(`[flaky-tests] Could not parse test name: ${testName}`);
              return null;
            }

            const fullyQualifiedClass = testName.slice(0, lastDotIndex);
            let methodName = testName.slice(lastDotIndex + 1);

            // Remove trailing [index] if it exists
            methodName = methodName.replace(/\[\d+\]\s*$/, '');

            const classParts = fullyQualifiedClass.split('.');
            const className = classParts[classParts.length - 1];
            const packageName = classParts.slice(0, -1).join('.');

            return {
              packageName,
              className,
              methodName
            };
          }

          /**
          * Adds a parsed test to the package map.
          */
          function addTestToMap(packageMap, { packageName, className, methodName }, jobName) {
            if (!packageMap.has(packageName)) {
              packageMap.set(packageName, new Map());
            }

            const testsMap = packageMap.get(packageName);
            const testKey = className ? `${className}.${methodName}` : methodName;

            if (testsMap.has(testKey)) {
              const testEntry = testsMap.get(testKey);
              if (!testEntry.jobs.includes(jobName)) {
                testEntry.jobs.push(jobName);
              }
                testEntry.occurrences++;
              } else {
                testsMap.set(testKey, {
                  className,
                  methodName,
                  jobs: [jobName],
                  occurrences: 1
                });
              }
          }
