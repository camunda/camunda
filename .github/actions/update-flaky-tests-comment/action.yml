---
name: Update Flaky Tests Comment

description: Creates or updates a PR comment with flaky test summary across all test jobs

inputs:
  flaky-tests-data:
    description: 'JSON array containing flaky test data from all jobs'
    required: true
  pr-number:
    description: 'Pull request number for the comment'
    required: true
  branch-name:
    description: 'Branch name where the comment will be posted'
    required: true

runs:
  using: composite
  steps:
    - name: Update Flaky Tests Comment
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          // Parse the flaky tests data
          const flakyTestsData = JSON.parse(`${{ inputs.flaky-tests-data }}`);
          console.log('Received flaky tests data:', flakyTestsData);

          // Early exit if no flaky tests found
          if (!Array.isArray(flakyTestsData) || flakyTestsData.length === 0) {
            console.log('[flaky-tests] No flaky tests found - skipping comment update');
            return;
          }

          // Step 1: Process and structure the flaky test data
          const processedData = processFlakyTestsData(flakyTestsData);
          console.log('[flaky-tests] Processed data:', JSON.stringify(processedData, null, 2));

          // Step 2: Generate and post the PR comment
          const { main } = require('./.github/actions/update-flaky-tests-comment/src/comment-generator');
          console.log('[flaky-tests] ðŸš€ Generating comment...');
          await main(context, github, processedData, ${{ inputs.pr-number }}, '${{ inputs.branch-name }}');

          /**
          * Processes the raw flaky test data and organizes it into a flat list.
          */
          function processFlakyTestsData(rawData) {
            const testMap = new Map();
            const getTestKey = (test) => `${test.packageName}.${test.className}.${test.methodName}`;

            rawData.forEach(({ job, flaky_tests }) => {
              if (!flaky_tests || flaky_tests.trim() === '') {
                console.log(`[flaky-tests] Skipping job "${job}" - no flaky tests`);
                return;
              }

              const testNames = flaky_tests
                .split(/\s+/)
                .map(t => t.trim())
                .filter(Boolean);

              console.log(`[flaky-tests] Job "${job}": found ${testNames.length} test(s)`);

              testNames.forEach(testName => {
                const parsedTest = parseTestName(testName);
                if (parsedTest) {
                  const key = getTestKey(parsedTest);
                  const existingTest = testMap.get(key);

                  if (existingTest) {
                    if (!existingTest.jobs.includes(job)) {
                      existingTest.jobs.push(job);
                    }
                    existingTest.occurrences++;
                  } else {
                    testMap.set(key, {
                      ...parsedTest,
                      jobs: [job],
                      occurrences: 1
                    });
                  }
                }
              });
            });

            return { flakys: Array.from(testMap.values()) };
          }

          /**
          * Parses a test name string into structured components.
          */
          function parseTestName(testName) {
            const lastDotIndex = testName.lastIndexOf('.');

            if (lastDotIndex === -1) {
              console.warn(`[flaky-tests] Could not parse test name: ${testName}`);
              return null;
            }

            const fullyQualifiedClass = testName.slice(0, lastDotIndex);
            let methodName = testName.slice(lastDotIndex + 1);

            // Remove trailing [index] if it exists
            methodName = methodName.replace(/\[\d+\]\s*$/, '');

            const classParts = fullyQualifiedClass.split('.');
            const className = classParts[classParts.length - 1];
            const packageName = classParts.slice(0, -1).join('.');

            return {
              packageName,
              className,
              methodName
            };
          }
